#region Common Public License Copyright Notice
/**************************************************************************\
* Natural Object-Role Modeling Architect for Visual Studio                 *
*                                                                          *
* Copyright Â© ORM Solutions, LLC. All rights reserved.                     *
*                                                                          *
* The use and distribution terms for this software are covered by the      *
* Common Public License 1.0 (http://opensource.org/licenses/cpl) which     *
* can be found in the file CPL.txt at the root of this distribution.       *
* By using this software in any fashion, you are agreeing to be bound by   *
* the terms of this license.                                               *
*                                                                          *
* You must not remove this notice, or any other, from this software.       *
\**************************************************************************/
#endregion

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Design;
using System.Security.Permissions;
using System.Linq;
using Microsoft.VisualStudio.Modeling;
using ORMSolutions.ORMArchitect.Framework;
using ORMSolutions.ORMArchitect.Framework.Design;
using ORMSolutions.ORMArchitect.RelationalModels.ConceptualDatabase;
using ORMSolutions.ORMArchitect.RelationalModels.ConceptualDatabase.Design;
using ORMSolutions.ORMArchitect.ORMAbstraction;
using ORMSolutions.ORMArchitect.ORMToORMAbstractionBridge;
using ORMSolutions.ORMArchitect.Core.ObjectModel;
using ORMSolutions.ORMArchitect.Core.ObjectModel.Design;

namespace ORMSolutions.ORMArchitect.ORMAbstractionToConceptualDatabaseBridge.Design
{
	/// <summary>
	/// Manage extension properties that relate a column back to the
	/// ORM model according through this bridge.
	/// </summary>
	public class ColumnProperties : IElementReference, IMappedColumnInfo
	{
		private readonly Column myColumn;
		private readonly ColumnValueType myColumnValueType;
		private bool myCheckedDefaultValueRole;
		private Role myDefaultValueRole;
		private bool? myUnaryDefault;
		private ColumnProperties(Column column, ColumnValueType columnValueType)
		{
			myColumn = column;
			myColumnValueType = columnValueType;
		}

		/// <summary>
		/// An <see cref="PropertyProvider"/> callback for adding extender properties to an <see cref="Column"/>
		/// </summary>
		public static void PopulateColumnProperties(object extendableElement, PropertyDescriptorCollection properties)
		{
			Column column;
			ColumnValueType? columnValueTypeTest;
			if (
				null != (column = extendableElement as Column) &&
				Utility.ValidateStore(column.Store) != null &&
				(columnValueTypeTest = GetAssociatedValueType(column)).HasValue
			)
			{
				ColumnValueType columnValueType = columnValueTypeTest.Value;
				ColumnProperties propertySet = new ColumnProperties(column, columnValueType);
				ObjectType valueType = columnValueType;
				properties = EditorUtility.GetEditablePropertyDescriptors(properties);

				// We always show the data type. It will be readonly if this is a fixed-type boolean column (unary or absorption indicator)
				// This is done as a wrapped and redirected property so we can filter the dropdown list.
				properties.Add(EditorUtility.RedirectPropertyDescriptor(propertySet, valueType == null ? DataTypeReadOnlyPropertyDescriptor : DataTypePropertyDescriptor, typeof(Column)));

				DataType dataType = valueType?.DataType;
				if (dataType != null)
				{
					bool showAutoGenerated = dataType.AutoGeneratable != AutoGenerationSupport.Never;
					bool showLength = dataType.LengthName != null; // Note that an empty string means 'default name' for scale and length, use explicit null check
					bool showScale = dataType.ScaleName != null;
					if (showAutoGenerated || showLength || showScale)
					{
						// Redirect other properties directly to the underlying value type
						PropertyDescriptorCollection valueTypeProperties = TypeDescriptor.GetProperties(valueType);
						if (showAutoGenerated)
						{
							properties.Add(EditorUtility.RedirectPropertyDescriptor(valueType, valueTypeProperties["DataTypeAutoGenerated"], typeof(Column)));
						}

						if (showLength)
						{
							properties.Add(EditorUtility.RedirectPropertyDescriptor(valueType, valueTypeProperties["DataTypeLength"], typeof(Column)));
						}

						if (showScale)
						{
							properties.Add(EditorUtility.RedirectPropertyDescriptor(valueType, valueTypeProperties["DataTypeScale"], typeof(Column)));
						}
					}
				}

				Role defaultValueRole;
				if (null != (defaultValueRole = propertySet.DefaultValueRole))
				{
					if (propertySet.UseUnaryDefaultValue)
					{
						properties.Add(EditorUtility.RedirectPropertyDescriptor(propertySet, UnaryDefaultValuePropertyDescriptor, typeof(Column)));
					}
					else
					{
						properties.Add(EditorUtility.ModifyPropertyDescriptorDisplay(EditorUtility.RedirectPropertyDescriptor(defaultValueRole, TypeDescriptor.GetProperties(defaultValueRole)["DefaultValue"], typeof(Column)), null, null, ResourceStrings.ColumnPropertyDefaultValueDescription, null));
					}

				}
			}
		}

		/// <summary>
		/// Resolve to the model element so we can use this
		/// </summary>
		object IElementReference.ReferencedElement
		{
			get
			{
				return myColumn;
			}
		}

		ColumnValueType IMappedColumnInfo.ValueType
		{
			get
			{
				return myColumnValueType;
			}
		}

		/// <summary>
		/// Calcule the default value role, if any
		/// </summary>
		private Role DefaultValueRole
		{
			get
			{
				Role defaultValueRole;
				if (!myCheckedDefaultValueRole)
				{
					Column column = myColumn;
					myCheckedDefaultValueRole = true;
					myDefaultValueRole = defaultValueRole = GetDefaultValueRole(column);
					if (defaultValueRole != null)
					{
						FactType factType = defaultValueRole.FactType;
						switch (factType.UnaryPattern)
						{
							case UnaryValuePattern.NotUnary:
							case UnaryValuePattern.OptionalWithoutNegation:
							case UnaryValuePattern.OptionalWithoutNegationDefaultTrue:
							case UnaryValuePattern.OptionalWithNegation:
							case UnaryValuePattern.RequiredWithNegation:
							case UnaryValuePattern.DeonticRequiredWithNegation:
								// Just use the role default value (empty)
								factType = null;
								break;
							case UnaryValuePattern.Negation:
								factType = factType.PositiveUnaryFactType;
								if (factType != null)
								{
									switch (factType.UnaryPattern)
									{
										case UnaryValuePattern.NotUnary:
										case UnaryValuePattern.OptionalWithoutNegation:
										case UnaryValuePattern.OptionalWithoutNegationDefaultTrue:
										case UnaryValuePattern.OptionalWithNegation:
										case UnaryValuePattern.RequiredWithNegation:
										case UnaryValuePattern.DeonticRequiredWithNegation:
											factType = null;
											break;
									}
								}
								break;
						}

						if (factType != null)
						{
							// The default value (if set) is always true on whatever unary role it is set on.
							// However, the column values are not always paired. Check the last step for negation.
							ColumnHasConceptTypeChild lastChild = ColumnHasConceptTypeChild.GetLinksToConceptTypeChildPath(column).LastOrDefault();
							if (lastChild != null && lastChild.InverseConceptTypeChild != null)
							{
								// Both states are represented, use true or false defaults depending on the pattern
								switch (factType.UnaryPattern)
								{
									case UnaryValuePattern.OptionalWithNegationDefaultTrue:
									case UnaryValuePattern.RequiredWithNegationDefaultTrue:
									case UnaryValuePattern.DeonticRequiredWithNegationDefaultTrue:
										myUnaryDefault = true;
										break;
									case UnaryValuePattern.OptionalWithNegationDefaultFalse:
									case UnaryValuePattern.RequiredWithNegationDefaultFalse:
									case UnaryValuePattern.DeonticRequiredWithNegationDefaultFalse:
										myUnaryDefault = false;
										break;
								}
							}
							else
							{
								myUnaryDefault = true;
							}
						}
					}
				}
				else
				{
					defaultValueRole = myDefaultValueRole;
				}
				return defaultValueRole;
			}
		}

		/// <summary>
		/// Determine if the unary default value needs to be used instead of redirecting the default to the role.
		/// </summary>
		private bool UseUnaryDefaultValue
		{
			get
			{
				return myUnaryDefault.HasValue;
			}
		}

		/// <summary>
		/// The column data type
		/// </summary>
		[Editor(typeof(ColumnDataTypePicker), typeof(UITypeEditor))]
		private DataType DataType
		{
			get
			{
				ColumnValueType columnValueType = myColumnValueType;
				ObjectType valueType = columnValueType;
				if (valueType == null)
				{
					return columnValueType.IsTrueOnlyBoolean ?
						myColumn.Store.ElementDirectory.FindElements<TrueLogicalDataType>(false).FirstOrDefault() as DataType :
						myColumn.Store.ElementDirectory.FindElements<TrueOrFalseLogicalDataType>(false).FirstOrDefault();
				}
				return valueType.DataType;
			}
			set
			{
				if (!myColumn.Store.InUndoRedoOrRollback)
				{
					ObjectType valueType = myColumnValueType;
					if (valueType != null)
					{
						valueType.DataType = (DataType)value;
					}
				}
			}
		}

		/// <summary>
		/// Provide a read-only property for paired unary columns.
		/// </summary>
		private string UnaryDefaultValue
		{
			get
			{
				return myUnaryDefault.HasValue ? myUnaryDefault.Value ? "True" : "False" : "";
			}
		}

		private static PropertyDescriptor myDataTypePropertyDescriptor;
		private static PropertyDescriptor DataTypePropertyDescriptor
		{
			get
			{
				PropertyDescriptor retVal = myDataTypePropertyDescriptor;
				if (retVal == null)
				{
					myDataTypePropertyDescriptor = retVal = EditorUtility.ReflectStoreEnabledPropertyDescriptor(typeof(ColumnProperties), "DataType", typeof(DataType), null, ResourceStrings.ColumnPropertyDataTypeDisplayName, ResourceStrings.ColumnPropertyDataTypeDescription, null);
				}
				return retVal;
			}
		}

		private static PropertyDescriptor myDataTypeReadOnlyPropertyDescriptor;
		private static PropertyDescriptor DataTypeReadOnlyPropertyDescriptor
		{
			get
			{
				PropertyDescriptor retVal = myDataTypeReadOnlyPropertyDescriptor;
				if (retVal == null)
				{
					myDataTypeReadOnlyPropertyDescriptor = retVal = EditorUtility.ModifyPropertyDescriptorDisplay(DataTypePropertyDescriptor, null, null, null, null, true);
				}
				return retVal;
			}
		}

		private static PropertyDescriptor myUnaryDefaultValuePropertyDescriptor;
		private static PropertyDescriptor UnaryDefaultValuePropertyDescriptor
		{
			get
			{
				PropertyDescriptor retVal = myUnaryDefaultValuePropertyDescriptor;
				if (retVal == null)
				{
					myUnaryDefaultValuePropertyDescriptor = retVal = EditorUtility.ReflectStoreEnabledPropertyDescriptor(typeof(ColumnProperties), "UnaryDefaultValue", typeof(string), null, ResourceStrings.ColumnPropertyDefaultValueDisplayName, ResourceStrings.ColumnPropertyDefaultValueDescription, null);
				}
				return retVal;
			}
		}

		/// <summary>
		/// Get information for the requested column, if available for this mapping.
		/// </summary>
		/// <param name="column">The column to test.</param>
		/// <returns>Requested information, or null if the column is not mapped by this bridge.</returns>
		public static IMappedColumnInfo GetColumnInfo(Column column)
		{
			ColumnValueType? valueType = GetAssociatedValueType(column);
			return valueType.HasValue ? new ColumnProperties(column, valueType.Value) : null;
		}

		private static ColumnValueType? GetAssociatedValueType(Column column)
		{
			ObjectType retVal = null;

			// Get the ConceptTypeChild elements associated with this column
			ReadOnlyCollection<ColumnHasConceptTypeChild> childLinks = ColumnHasConceptTypeChild.GetLinksToConceptTypeChildPath(column);
			int childLinkCount = childLinks.Count;
			if (childLinkCount != 0)
			{
				ColumnHasConceptTypeChild childLink = childLinks[childLinkCount - 1];
				if (childLink.AbsorptionIndicator)
				{
					return new ColumnValueType(childLink.InverseConceptTypeChild == null);
				}

				ConceptTypeChild child = childLink.ConceptTypeChild;
				InformationType informationType;
				LinkedElementCollection<FactType> factTypePath;
				Role targetRole;
				int factTypeCount;
				if (0 != (factTypeCount = (factTypePath = ConceptTypeChildHasPathFactType.GetPathFactTypeCollection(child)).Count) &&
					null != (targetRole = FactTypeMapsTowardsRole.GetTowardsRole(factTypePath[factTypeCount - 1])?.OppositeRole?.Role))
				{
					retVal = targetRole.RolePlayer;
				}
				else if (null != (informationType = child as InformationType))
				{
					InformationTypeFormat format = informationType.InformationTypeFormat;
					if (format.GetType() != typeof(InformationTypeFormat))
					{
						// The two other possibilities are PositiveUnaryInformationTypeFormat and NegativeUnaryInformationTypeFormat.
						// It doesn't really matter which we have because unpaired negative and positive forms both map to a true value
						// and we can check if the columnn is paired from the fact type path.
						return new ColumnValueType(childLink.InverseConceptTypeChild == null);
					}

					retVal = ConceptTypeIsForObjectType.GetObjectType(informationType.ConceptType);
				}

				if (retVal != null && !retVal.IsValueType)
				{
					retVal = null;
				}
			}
			return retVal != null ? (ColumnValueType)retVal : null;
		}

		/// <summary>
		/// Get a role that is appropriate for displaying a default value property
		/// for the provided column.
		/// </summary>
		/// <param name="column">The column to test.</param>
		/// <returns>An appropriate role, or null.</returns>
		/// <remarks>This shows the first value role after assimilated children. These correspond
		/// to the table columns. For reference columns, a default value will only be shown if
		/// the identifier is single-valued. These are all that are currently recorded in the ORM
		/// model. The remaining cases (default values on parts of foreign-keyed references) are
		/// very rare in practice and would require expension of either the relational or ORM
		/// default value models to include default values on non-value roles. Currently, default
		/// values are allowed on the same roles as value constraints.</remarks>
		private static Role GetDefaultValueRole(Column column)
		{
			Role retVal = null;
			foreach (ColumnHasConceptTypeChild childLink in ColumnHasConceptTypeChild.GetLinksToConceptTypeChildPath(column))
			{
				FactType firstFactType;
				RoleBase towardsRole;
				Role fromRole;
				ConceptTypeChild child = childLink.ConceptTypeChild;
				ConceptTypeAssimilatesConceptType assimilation;
				if (null != (assimilation = child as ConceptTypeAssimilatesConceptType))
				{
					if (
						childLink.AbsorptionIndicator &&
						!assimilation.RefersToSubtype &&
						null != (retVal = ConceptTypeIsForObjectType.GetObjectType(assimilation.AssimilatedConceptType)?.Objectification?.NestedFactType.UnaryRole)
					)
					{
						return retVal;
					}
					else if (!assimilation.IsMandatory)
					{
						// We don't do default values in the relational model for absorbed defaults
						return null;
					}
					continue;
				}
				else if (child is ConceptTypeRelatesToConceptType)
				{
					if (
						null != (firstFactType = ConceptTypeChildHasPathFactType.GetPathFactTypeCollection(child).FirstOrDefault()) &&
						null != (towardsRole = FactTypeMapsTowardsRole.GetTowardsRole(firstFactType)) &&
						null != (fromRole = towardsRole.OppositeRoleAlwaysResolveProxy?.Role) &&
						fromRole.IsValueRole
					)
					{
						retVal = fromRole;
					}
					break;
				}
				else if (child is InformationType)
				{
					if (null != (firstFactType = ConceptTypeChildHasPathFactType.GetPathFactTypeCollection(child).FirstOrDefault()))
					{
						if (firstFactType.UnaryPattern != UnaryValuePattern.NotUnary)
						{
							retVal = firstFactType.UnaryRole;
						}
						else if (
							null != (towardsRole = FactTypeMapsTowardsRole.GetTowardsRole(firstFactType)) &&
							null != (fromRole = towardsRole.OppositeRoleAlwaysResolveProxy?.Role)
						)
						{
							retVal = fromRole;
						}
					}
				}
			}
			return retVal;
		}
	}
}