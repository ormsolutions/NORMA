#region Common Public License Copyright Notice
/**************************************************************************\
* Neumont Object-Role Modeling Architect for Visual Studio                 *
*                                                                          *
* Copyright © Neumont University. All rights reserved.                     *
*                                                                          *
* The use and distribution terms for this software are covered by the      *
* Common Public License 1.0 (http://opensource.org/licenses/cpl) which     *
* can be found in the file CPL.txt at the root of this distribution.       *
* By using this software in any fashion, you are agreeing to be bound by   *
* the terms of this license.                                               *
*                                                                          *
* You must not remove this notice, or any other, from this software.       *
\**************************************************************************/
#endregion

using System;
using System.IO;
using System.Text;
using System.Xml;

namespace Neumont.Tools.ORM.SDK
{
	internal partial class VersionGenerator
	{
		private static int Main()
		{
			const string generatedWarning = " This file was generated by VersionGenerator.exe. It should NOT be directly modified. ";
			const string statusPrefix = "VersionGenerator.exe: ";

			Directory.SetCurrentDirectory(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location));
			FileInfo versionConfig = new FileInfo("VersionGenerator.exe.config");
			if (!versionConfig.Exists)
			{
				// If we don't have the configuration file, bad things are going to happen...
				Console.Error.WriteLine(statusPrefix + "VersionGenerator.exe.config not found!");
				return 1;
			}
			DateTime versionConfigLastModified = versionConfig.LastWriteTime;

			DateTime today = DateTime.Today;
			int build = ((Config.ReleaseYearMonth.Year - 2000) * 100) + Config.ReleaseYearMonth.Month;
			int month = ((today.Year - Config.RevisionStartYearMonth.Year) * 12) + (today.Month - Config.RevisionStartYearMonth.Month) + 1;
			int revision = (month * 100) + today.Day;

			string unquotedFileVersion = string.Format("{0}.{1}.{2}.{3}", Config.MajorVersion, Config.MinorVersion, build, revision);
			string quotedInformationalVersion = string.Format("\"{0} {1:yyyy-MM}{2}\"", unquotedFileVersion, Config.ReleaseYearMonth, Config.ReleaseType);
			string quotedProductVersion = string.Format("\"{0}.{1}.0.0\"", Config.MajorVersion, Config.MinorVersion);

			#region Version.h
			FileInfo versionH = new FileInfo("Version.h");
			if (!versionH.Exists || versionH.LastWriteTime.Date != today || versionH.LastWriteTime < versionConfigLastModified)
			{
				using (StreamWriter writer = versionH.CreateText())
				{
					writer.WriteLine("/*" + generatedWarning + "*/");
					writer.WriteLine("#define NORMA_FILEVERSION	" + unquotedFileVersion);
					writer.WriteLine("#define NORMA_FILEVERSION_STRING	" + quotedInformationalVersion);
					writer.WriteLine("#define NORMA_PRODUCTVERSION	{0},{1},0,0", Config.MajorVersion, Config.MinorVersion);
					writer.WriteLine("#define NORMA_PRODUCTVERSION_STRING	" + quotedProductVersion);
				}
				Console.WriteLine(statusPrefix + "Generated Version.h.");
			}
			else
			{
				Console.WriteLine(statusPrefix + "Version.h already up to date.");
			}
			#endregion

			#region Version.cs
			FileInfo versionCS = new FileInfo("Version.cs");
			if (!versionCS.Exists || versionCS.LastWriteTime.Date != today || versionCS.LastWriteTime < versionConfigLastModified)
			{
				using (StreamWriter writer = versionCS.CreateText())
				{
					writer.WriteLine("/*" + generatedWarning + "*/");
					writer.Write("[assembly: System.Reflection.AssemblyFileVersion(\"");
					writer.Write(unquotedFileVersion);
					writer.WriteLine("\")]");
					writer.Write("[assembly: System.Reflection.AssemblyInformationalVersion(");
					writer.Write(quotedInformationalVersion);
					writer.WriteLine(")]");
					writer.Write("[assembly: System.Reflection.AssemblyVersion(");
					writer.Write(quotedProductVersion);
					writer.WriteLine(")]");
					writer.Write("[assembly: System.Resources.SatelliteContractVersion(");
					writer.Write(quotedProductVersion);
					writer.WriteLine(")]");
				}
				Console.WriteLine(statusPrefix + "Generated Version.cs.");
			}
			else
			{
				Console.WriteLine(statusPrefix + "Version.cs already up to date.");
			}
			#endregion

			#region Version.wxi
			FileInfo versionWXI = new FileInfo("Version.wxi");
			if (!versionWXI.Exists || versionWXI.LastWriteTime.Date != today || versionWXI.LastWriteTime < versionConfigLastModified)
			{
				XmlWriterSettings settings = new XmlWriterSettings();
				settings.CloseOutput = true;
				using (XmlWriter writer = XmlWriter.Create(versionWXI.CreateText(), settings))
				{
					writer.WriteStartDocument();
					writer.WriteStartElement("Include", "http://schemas.microsoft.com/wix/2003/01/wi");
					writer.WriteComment(generatedWarning);
					writer.WriteProcessingInstruction("define", string.Format("MajorMinorVersion=\"{0}.{1}\"", Config.MajorVersion, Config.MinorVersion));
					writer.WriteProcessingInstruction("define", string.Format("MajorVersionHexits=\"{0:d2}\"", Config.MajorVersion));
					writer.WriteProcessingInstruction("define", string.Format("ProductVersion=\"{0}\"", unquotedFileVersion));
					writer.WriteProcessingInstruction("define", string.Format("VersionGuidSuffix=\"$(var.Debug)$(var.ExperimentalHive)$(var.Architecture)-$(var.MajorVersionHexits){0:d2}{1:d4}{2:d4}\"", Config.MinorVersion, build, revision));
					writer.WriteEndElement();
					writer.WriteEndDocument();
				}
				Console.WriteLine(statusPrefix + "Generated Version.wxi.");
			}
			else
			{
				Console.WriteLine(statusPrefix + "Version.wxi already up to date.");
			}
			#endregion

			Console.WriteLine("VersionGenerator.exe finished successfully.");
			return 0;
		}
	}
}
