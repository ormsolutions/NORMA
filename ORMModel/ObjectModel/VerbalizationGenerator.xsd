<?xml version="1.0" encoding="utf-8"?>
<xs:schema
	attributeFormDefault="unqualified"
	elementFormDefault="qualified"
	targetNamespace="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:cvg="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:ve="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:annotation>
		<xs:appinfo source="Common Public License Copyright Notice">
			Natural Object-Role Modeling Architect for Visual Studio

			Copyright © Neumont University. All rights reserved.
			Copyright © ORM Solutions, LLC. All rights reserved.

			The use and distribution terms for this software are covered by the
			Common Public License 1.0 (http://opensource.org/licenses/cpl) which
			can be found in the file CPL.txt at the root of this distribution.
			By using this software in any fashion, you are agreeing to be bound by
			the terms of this license.

			You must not remove this notice, or any other, from this software.
		</xs:appinfo>
	</xs:annotation>
	<xs:import namespace="http://schemas.neumont.edu/ORM/SDK/Verbalization" schemaLocation="VerbalizationCoreSnippets/VerbalizationCoreSnippets.xsd"/>
	<xs:simpleType name="PassEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="first"/>
			<xs:enumeration value="notFirst"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SpanEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
			<xs:enumeration value="allMinusOne"/>
			<xs:enumeration value="allMinusMoreThanOne"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="UniquenessConstraint"/>
			<xs:enumeration value="UniquenessConstraintVerbalizer"/>
			<xs:enumeration value="UniquenessPossibilityVerbalizer"/>
			<xs:enumeration value="UniquenessPreferredVerbalizer"/>
			<xs:enumeration value="MandatoryConstraint"/>
			<xs:enumeration value="SimpleMandatoryVerbalizer"/>
			<xs:enumeration value="DisjunctiveMandatoryVerbalizer"/>
			<xs:enumeration value="FrequencyConstraint"/>
			<xs:enumeration value="RingConstraint"/>
			<xs:enumeration value="ValueComparisonConstraint"/>
			<xs:enumeration value="SubsetConstraint"/>
			<xs:enumeration value="ExclusionConstraint"/>
			<xs:enumeration value="EqualityConstraint"/>
			<xs:enumeration value="RoleValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on roles.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ValueTypeValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on value types.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NearestValueConstraintVerbalizer">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on entity types.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="DefaultBinaryMissingUniquenessVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing default binary conditions. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CombinedMandatoryUniqueVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing combinations of uniqueness and mandatory constraints on binaries. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ImpliedUniqueVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing implied single-role internal uniqueness constraints. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ImpliedMandatoryVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing implied simple mandatory constraints. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ObjectTypeCardinalityConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes object type cardinality constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="UnaryRoleCardinalityConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes unary role cardinality constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AcyclicRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AntisymmetricRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AsymmetricRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IntransitiveRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="StronglyIntransitiveRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IrreflexiveRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ReflexiveRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PurelyReflexiveRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SymmetricRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="TransitiveRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ChildHelperForEnum">
		<xs:annotation>
			<xs:documentation>Used to specify child helper classes as nested classes inside this type.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="FactType">
				<xs:annotation>
					<xs:documentation>Use with the DefaultBinaryMissingUniquenessVerbalizer and CombinedMandatoryUniqueVerbalizer types</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ObjectType">
				<xs:annotation>
					<xs:documentation>Use with the ObjectTypeInstanceVerbalizer</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RingConstraint">
				<xs:annotation>
					<xs:documentation>Use for individual ringtype verbalizers.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MandatoryConstraint">
				<xs:annotation>
					<xs:documentation>Use for individual mandatory constraint verbalizers.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="UniquenessConstraint">
				<xs:annotation>
					<xs:documentation>Use for individual uniqueness constraint verbalizers.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Role">
				<xs:annotation>
					<xs:documentation>Use for child helpers of Role.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintPatternGroupEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalConstraint"/>
			<xs:enumeration value="SetConstraint"/>
			<xs:enumeration value="SetComparisonConstraint"/>
			<xs:enumeration value="RoleValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes role value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ValueTypeValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value type value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NearestValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes entity type value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ObjectTypeCardinalityConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes object type cardinality constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="UnaryRoleCardinalityConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes unary role cardinality constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchWithContextEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Context|Prefer[Non][Primary]LeadReading[InfixTextOnly|[NoFrontText|NoTrailingText]][[Lead]NotHyphenBound]} -->
			<xs:enumeration value="Context">
				<xs:annotation>
					<xs:documentation>Use the reading from the current ReadingChoice or ReadingContext elements</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ConditionalContext">
				<xs:annotation>
					<xs:documentation>Use the reading specified with the IterateRoles/@conditionalReading attribute.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferLeadReadingInfixTextOnly"/>
			<xs:enumeration value="PreferLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNoTrailingText"/>
			<xs:enumeration value="PreferLeadReadingNoTrailingTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNoTrailingTextNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferNonLeadReadingInfixTextOnly"/>
			<xs:enumeration value="PreferNonLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNoTrailingText"/>
			<xs:enumeration value="PreferNonLeadReadingNoTrailingTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNoTrailingTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingInfixTextOnly"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoTrailingText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoTrailingTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoTrailingTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReadingInfixTextOnly"/>
			<xs:enumeration value="PreferPrimaryLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoTrailingText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoTrailingTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoTrailingTextNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNotHyphenBound"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Prefer[Non][Primary]LeadReading[InfixTextOnly|[NoFrontText|NoTrailingText]][[Lead]NotHyphenBound]} -->
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferLeadReadingInfixTextOnly"/>
			<xs:enumeration value="PreferLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNoTrailingText"/>
			<xs:enumeration value="PreferLeadReadingNoTrailingTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNoTrailingTextNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferNonLeadReadingInfixTextOnly"/>
			<xs:enumeration value="PreferNonLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNoTrailingText"/>
			<xs:enumeration value="PreferNonLeadReadingNoTrailingTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNoTrailingTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingInfixTextOnly"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReadingInfixTextOnly"/>
			<xs:enumeration value="PreferPrimaryLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="PreferPrimaryLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNotHyphenBound"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoiceFullRequiredMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Require[All][Non][Primary]LeadReading[InfixTextOnly|[NoFrontText|NoTrailingText]][[Lead]NotHyphenBound]} -->
			<xs:enumeration value="RequireLeadReading"/>
			<xs:enumeration value="RequireLeadReadingInfixTextOnly"/>
			<xs:enumeration value="RequireLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="RequireLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="RequireLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="RequireLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReading"/>
			<xs:enumeration value="RequireNonLeadReadingInfixTextOnly"/>
			<xs:enumeration value="RequireNonLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireNonLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="RequireNonLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReading"/>
			<xs:enumeration value="RequirePrimaryLeadReadingInfixTextOnly"/>
			<xs:enumeration value="RequirePrimaryLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="RequirePrimaryLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingInfixTextOnly"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReading"/>
			<xs:enumeration value="RequireAllLeadReadingInfixTextOnly"/>
			<xs:enumeration value="RequireAllLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="RequireAllLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReading"/>
			<xs:enumeration value="RequireAllNonLeadReadingInfixTextOnly"/>
			<xs:enumeration value="RequireAllNonLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="RequireAllNonLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingInfixTextOnly"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingInfixTextOnly"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingInfixTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingInfixTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoFrontTextLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingTrailingTextOnly"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingTrailingTextOnlyLeadNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingTrailingTextOnlyNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNotHyphenBound"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CompactSimpleList"/>
			<xs:enumeration value="CompactSimpleOrList"/>
			<xs:enumeration value="CompoundList"/>
			<xs:enumeration value="DerivedFromList"/>
			<xs:enumeration value="FactTypeList"/>
			<xs:enumeration value="EqualsList"/>
			<xs:enumeration value="IdentityList"/>
			<xs:enumeration value="IdentityEqualityList"/>
			<xs:enumeration value="IndentedCompoundList"/>
			<xs:enumeration value="IndentedList"/>
			<xs:enumeration value="IndentedLogicalAndList"/>
			<xs:enumeration value="IndentedLogicalOrList"/>
			<xs:enumeration value="MultilineIndentedCompoundList"/>
			<xs:enumeration value="ObjectTypeInstanceList"/>
			<xs:enumeration value="SimpleList"/>
			<xs:enumeration value="SimpleLogicalAndList"/>
			<xs:enumeration value="SimpleLogicalOrList"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndList"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrList"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnumOrNull">
		<xs:union memberTypes="ListStyleEnum">
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="null"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="RoleIteratorContextMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="primary"/>
			<xs:enumeration value="secondary"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IterateRolesMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="constraintRoles"/>
			<xs:enumeration value="providedConstraintRoles">
				<xs:annotation>
					<xs:documentation>Role replacements are generated by a callback to the context path verbalizer, which will automatically subscript and quantify the role players.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="providedFactRoles">
				<xs:annotation>
					<xs:documentation>The current fact or query roles and iterated and replacements are generated by a callback to the context path verbalizer, which will automatically subscript and quantify the role players.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="preProjectionKeys">
				<xs:annotation>
					<xs:documentation>Iterate the set of pre-projection role path keys. Analog to providedConstraintRoles, which iterates the projected roles. Requires the preProjectionKeys block helper.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="preferredIdentifier"/>
			<xs:enumeration value="playedRoles"/>
			<xs:enumeration value="providedFactType">
				<xs:annotation>
					<xs:documentation>Use the implementation of the role iterator to verbalize a single provided fact type. No iterator is generated when this is set and it should be used with a null listStyle.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="FactArityAttributes">
		<xs:attribute name="factCount" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="factArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="constraintArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="minConstraintArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="minFactArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="maxFactArity" type="xs:unsignedByte" use="optional"/>
	</xs:attributeGroup>
	<xs:attributeGroup name="BlockHelperAttributes">
		<xs:attribute name="blockHelpers" use="optional">
			<xs:annotation>
				<xs:documentation>A list of helper patterns that should be defined inside a code block.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:list>
					<xs:simpleType>
						<xs:restriction base="xs:token">
							<xs:enumeration value="pathVerbalizer">
								<xs:annotation>
									<xs:documentation>Initialize a path verbalizer for the context join path.</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
							<xs:enumeration value="preProjectionKeys">
								<xs:annotation>
									<xs:documentation>Get keys for primary nodes in the join path that occur before the projected nodes.</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:list>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="SnippetLeafType">
		<xs:attribute name="ref" use="required">
			<xs:simpleType>
				<xs:union memberTypes="ve:SnippetTypeEnum">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="null"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:union>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="alternateSign" use="optional">
			<xs:annotation>
				<xs:documentation>Retrieve a snippet with a sign other than the one specified by the caller.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="opposite">
						<xs:annotation>
							<xs:documentation>Use the opposite of the requested sign.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="positive">
						<xs:annotation>
							<xs:documentation>Use a positively-signed snippet.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="negative">
						<xs:annotation>
							<xs:documentation>Use a negatively-signed snippet.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="applyTrailingOutdentHere" use="optional" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Use with a nested SequenceJoinPath@markTrailingOutdentStart to force outdent resolution in the snippet instead of while the list is generating.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SnippetLeafTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="ConditionalBlockContextType">
		<xs:annotation>
			<xs:documentation>Provide an extension point for adding extra context code at the beginning of a conditional block.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="ObjectifiedFactType">
				<xs:annotation>
					<xs:documentation>Used when object type is objectified fact type.</xs:documentation>
				</xs:annotation>				
			</xs:enumeration>
			<xs:enumeration value="BinaryLeadReading">
				<xs:annotation>
					<xs:documentation>Used to determine whether binary lead readings are available for some column of a two-column SetComparisonConstraint with no hyphen binding and the same role players.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SubtypeFactRolePlayers">
				<xs:annotation>
					<xs:documentation>Declare subtype and supertype variables for a SubtypeFact context.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PreferredFor">
				<xs:annotation>
					<xs:documentation>Declare a preferredFor variable for a UniquenessConstraint context.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SingleRangeBounds">
				<xs:annotation>
					<xs:documentation>Populate the range, rangeLowerBound, and rangeUpperBound variables for a single cardinality range.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="DataType">
				<xs:annotation>
					<xs:documentation>Retrieve the data type for an object type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="DerivedFromTypes">
				<xs:annotation>
					<xs:documentation>Declare variables for each of the expected derived from types (fact type, object type, set constraint, set comparison role sequence)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="JoinedSetComparisonConstraint">
				<xs:annotation>
					<xs:documentation>Declare a variable for the parent constraint of a joined set comparison sequence.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConditionalMatchPatternType">
		<xs:annotation>
			<xs:documentation>Provide an extension point for conditionally including snippets. If multiple conditions are specified, they are combined with 'or'.</xs:documentation>
		</xs:annotation>
		<xs:list>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="IsEntityType">
						<xs:annotation>
							<xs:documentation>True if the IsValueType property for the current object type is false.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsValueType">
						<xs:annotation>
							<xs:documentation>True if the IsValueType property for the current object type is true.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsObjectifiedFactType">
						<xs:annotation>
							<xs:documentation>True if the current object type objectifies a fact type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasVerbalizableQueryDerivationPath">
						<xs:annotation>
							<xs:documentation>True if there is a path-based verbalization available for a query object.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasVerbalizableSubtypeDerivationPath">
						<xs:annotation>
							<xs:documentation>True if there is a path-based subtype verbalization available for an object type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasVerbalizableDynamicRulePath">
						<xs:annotation>
							<xs:documentation>True if the dynamic rule defines a verbalizable path.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasStoredDerivationRule">
						<xs:annotation>
							<xs:documentation>True if there is a derivation rule defined that has a 'stored' setting.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DerivationRuleIsPartial">
						<xs:annotation>
							<xs:documentation>True if a path-based derivation rule has partial derivation completeness. Assumes that a derivation rule is already defined and in context.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DerivationRuleIsStored">
						<xs:annotation>
							<xs:documentation>True if a path-based derivation rule is stored. Assumes that a derivation rule is already defined and in context.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DerivationRuleIsPartialAndStored">
						<xs:annotation>
							<xs:documentation>True if a path-based derivation rule has partial derivation completeness and is stored. Assumes that a derivation rule is already defined and in context.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DerivedFactType">
						<xs:annotation>
							<xs:documentation>True if the current derived from element (meaning element is derived using the current context item) is a fact type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DerivedSubtype">
						<xs:annotation>
							<xs:documentation>True if the current derived from element (meaning element is derived using the current context item) is an object type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicRule">
						<xs:annotation>
							<xs:documentation>True if the current derived from element (meaning element is derived using the current context item) is a dynamic rule.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicRuleHasAddSection">
						<xs:annotation>
							<xs:documentation>True if the dynamic rule being verbalized has nodes in the 'add' section.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicRuleHasConditionSection">
						<xs:annotation>
							<xs:documentation>True if the dynamic rule being verbalized has nodes remaining in the role path for the 'condition' section.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicRuleHasStandaloneConditionSection">
						<xs:annotation>
							<xs:documentation>True if the dynamic rule being verbalized has nodes remaining in the role path for the 'condition' section and there are no quantifiers.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicRuleHasDeleteSection">
						<xs:annotation>
							<xs:documentation>True if the dynamic rule being verbalized has nodes in the 'delete' section.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicRuleHasHeadSection">
						<xs:annotation>
							<xs:documentation>True if the dynamic rule being verbalized has quantifier nodes in the 'head' section.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicStateAdded">
						<xs:annotation>
							<xs:documentation>True if the dynamicState variable has an 'Added' dynamic state.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicStateDeleted">
						<xs:annotation>
							<xs:documentation>True if the dynamicState variable has an 'Deleted' dynamic state.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="DynamicStateInitial">
						<xs:annotation>
							<xs:documentation>True if the dynamicState variable has an 'Initial' dynamic state.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="PathNodeFactTypeEntry">
						<xs:annotation>
							<xs:documentation>True if the path node represents a fact type entry.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasPortableDataType">
						<xs:annotation>
							<xs:documentation>True if the current object type has portable data type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasPortableDataTypeLengthAndScale">
						<xs:annotation>
							<xs:documentation>True if the current data type supports length (precision) and scale, and the scale is not zero. Assumes a block context of 'DataType' and that HasPortableDataType has been satisfied.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasPortableDataTypeLength">
						<xs:annotation>
							<xs:documentation>True if the current data type supports a length, which is displayed regardless of its current value UNLESS a scale is also supported, in which case a 0 is ignored. Assumes a block context of 'DataType' and that HasPortableDataType has been satisfied.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasNotes">
						<xs:annotation>
							<xs:documentation>True if the current object type has notes associated with it.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsIndependent">
						<xs:annotation>
							<xs:documentation>True if the current object type is independent.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasReferenceMode">
						<xs:annotation>
							<xs:documentation>True if the current object type has a reference mode.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasRoleName">
						<xs:annotation>
							<xs:documentation>True for a Role if the roleName variable is not null.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasRolePlayer">
						<xs:annotation>
							<xs:documentation>True for a Role if the rolePlayer variable is not null.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasSubscript">
						<xs:annotation>
							<xs:documentation>The value of the subscript variable is positive.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsParameterized">
						<xs:annotation>
							<xs:documentation>True if the current query has parameters defined. Used with QueryBase construct.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsNamedParameter">
						<xs:annotation>
							<xs:documentation>True if the current query parameter has a name. Used inside an IterateQueryParameters element.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasPreferredIdentifier">
						<xs:annotation>
							<xs:documentation>True if the current object type has preferred identifier.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasUnobjectifiedPreferredIdentifier">
						<xs:annotation>
							<xs:documentation>True if the current object type has a preferred identifier that is not an internal constraint on an objectified fact type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsPersonal">
						<xs:annotation>
							<xs:documentation>True if the IsPersonal property for the current role player is true.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsPreferredIdentifier">
						<xs:annotation>
							<xs:documentation>True if the current constraint is a preferred identifier.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedSetComparisonSequence">
						<xs:annotation>
							<xs:documentation>True if the current derived from element (meaning element is derived using the current context item) is a sequence from a set comparison constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedEqualityConstraint">
						<xs:annotation>
							<xs:documentation>Refinement of JoinedSetComparisonSequence and JoinedSetComparisonConstraint block helper for an equality constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedExclusionConstraint">
						<xs:annotation>
							<xs:documentation>Refinement of JoinedSetComparisonSequence and JoinedSetComparisonConstraint block helper for an exclusion constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedSubsetConstraint">
						<xs:annotation>
							<xs:documentation>Refinement of JoinedSetComparisonSequence and JoinedSetComparisonConstraint block helper for a subset constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedSetConstraint">
						<xs:annotation>
							<xs:documentation>True if the current derived from element (meaning element is derived using the current context item) is a set constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedFrequencyConstraint">
						<xs:annotation>
							<xs:documentation>Refinement of JoinedSetConstraint for a frequency constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedRingConstraint">
						<xs:annotation>
							<xs:documentation>Refinement of JoinedSetConstraint for a ring constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedUniquenessConstraint">
						<xs:annotation>
							<xs:documentation>Refinement of JoinedSetConstraint for a uniqueness constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="JoinedValueComparisonConstraint">
						<xs:annotation>
							<xs:documentation>Refinement of JoinedSetConstraint for a value comparison constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="BinaryWithRoleName">
						<xs:annotation>
							<xs:documentation>True if the current role is named and is playing a role within a binary fact type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="RolePlayerHasReferenceScheme">
						<xs:annotation>
							<xs:documentation>True if the current role player has a reference scheme</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsPositive">
						<xs:annotation>
							<xs:documentation>Matches if creating a positive verbalization.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsNegative">
						<xs:annotation>
							<xs:documentation>Matches if creating a negative verbalization.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsSingleValue">
						<xs:annotation>
							<xs:documentation>True if the value range collection has only one value range whose	min value is equal to the max value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsText">
						<xs:annotation>
							<xs:documentation>True if the current ValueConstraint has a text data type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsBinaryLeadReading">
						<xs:annotation>
							<xs:documentation>True if non-hyphenated lead readings start at lead column roles are available in a 2x2 set comparison constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IsBinaryLeadReadingReverse">
						<xs:annotation>
							<xs:documentation>True if non-hyphenated lead readings start at trailing column roles are available in a 2x2 set comparison constraint.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ExclusionIsExclusiveOrConstraint">
						<xs:annotation>
							<xs:documentation>True if the Exclusion constraint is an Exclusive Or Constraint</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinEqualsMax">
						<xs:annotation>
							<xs:documentation>Matches a value range whose min value is equal to the max value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinClosedMaxUnbounded">
						<xs:annotation>
							<xs:documentation>Matches a value range with a closed minimum value and an unbounded maximum value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinOpenMaxUnbounded">
						<xs:annotation>
							<xs:documentation>Matches a value range with an open minimum value and an unbounded maximum value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinUnboundedMaxClosed">
						<xs:annotation>
							<xs:documentation>Matches a value range with an unbounded minimum value and a closed maximum value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinUnboundedMaxOpen">
						<xs:annotation>
							<xs:documentation>Matches a value range with an unbounded minimum value and an open maximum value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinClosedMaxClosed">
						<xs:annotation>
							<xs:documentation>Matches a value range with a closed minimum value and an open maximum value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinClosedMaxOpen">
						<xs:annotation>
							<xs:documentation>Matches a value range with a closed minimum value and an open maximum value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinOpenMaxClosed">
						<xs:annotation>
							<xs:documentation>Matches a value range with an open minimum value and an open maximum value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MinOpenMaxOpen">
						<xs:annotation>
							<xs:documentation>Matches a value range with an open minimum value and an open maximum value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="FrequencyRangeExactlyOne">
						<xs:annotation>
							<xs:documentation>Matches a frequency range where the minimum and maximum frequencies are equal to 1.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="FrequencyRangeExact">
						<xs:annotation>
							<xs:documentation>Matches a frequency range where the minimum and maximum frequencies are equal.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="FrequencyRangeMaxUnbounded">
						<xs:annotation>
							<xs:documentation>Matches a frequency range with no upper bound.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="FrequencyRangeMinUnbounded">
						<xs:annotation>
							<xs:documentation>Matches a frequency range where the minimum is one.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="SingleRange">
						<xs:annotation>
							<xs:documentation>A single cardinality range is defined.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="RangeExactlyOne">
						<xs:annotation>
							<xs:documentation>The upper and lower bounds of a cardinality range are exactly one.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="RangeExact">
						<xs:annotation>
							<xs:documentation>The upper and lower bounds of a cardinality range are the same.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="RangeLowerUnbounded">
						<xs:annotation>
							<xs:documentation>The lower bound of a cardinality range is set at zero.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="RangeUpperUnbounded">
						<xs:annotation>
							<xs:documentation>The upper bound of a cardinality range is unbounded.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="SingleRoleRoleSequence">
						<xs:annotation>
							<xs:documentation>Matches a role sequence with exactly one role.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ObjectifyingInstance">
						<xs:annotation>
							<xs:documentation>The FactTypeInstance has an objectifying identifier that should be displayed</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="VerbalizeFactTypesWithBrowserObjectType">
						<xs:annotation>
							<xs:documentation>Verbalize the fact type list only if we're writing to the verbalization browser and have the correct option set.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasPreProjectionKeys">
						<xs:annotation>
							<xs:documentation>Verbalize only if pre-projection keys are available. Used with the 'preProjectionKeys' block helper.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="NoPreProjectionKeys">
						<xs:annotation>
							<xs:documentation>Verbalize only if no pre-projection keys are available. Used with the 'preProjectionKeys' block helper. Currently supported only after HasPreProjectionKeys has been used in a condition.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasSinglePreProjectionKey">
						<xs:annotation>
							<xs:documentation>There is exactly one pre-projection key.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasSingleLeadPreProjectionKey">
						<xs:annotation>
							<xs:documentation>There is exactly one pre-projection key and it corresponds to a variable that is verbalized by the role path before any other phrases.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="BinaryRingFactType">
						<xs:annotation>
							<xs:documentation>Check if the current binary fact type is a ring fact type. Binary is already assumed.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ValueComparisonOperatorLessThan">
						<xs:annotation>
							<xs:documentation>Check if the operator for the context ValueComparisonConstraint is 'less than'.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ValueComparisonOperatorLessThanOrEqual">
						<xs:annotation>
							<xs:documentation>Check if the operator for the context ValueComparisonConstraint is 'less than or equal'.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ValueComparisonOperatorGreaterThan">
						<xs:annotation>
							<xs:documentation>Check if the operator for the context ValueComparisonConstraint is 'greater than'.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ValueComparisonOperatorGreaterThanOrEqual">
						<xs:annotation>
							<xs:documentation>Check if the operator for the context ValueComparisonConstraint is 'greater than or equal'.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ValueComparisonOperatorEqual">
						<xs:annotation>
							<xs:documentation>Check if the operator for the context ValueComparisonConstraint is 'equal'.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ValueComparisonOperatorNotEqual">
						<xs:annotation>
							<xs:documentation>Check if the operator for the context ValueComparisonConstraint is 'not equal'.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="HasDefaultValue">
						<xs:annotation>
							<xs:documentation>The object type or role has a default value.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="UnaryPopulatedByDefault">
						<xs:annotation>
							<xs:documentation>The unary role is populated by default.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:list>
	</xs:simpleType>
	<xs:complexType name="SnippetType">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
				<xs:attribute name="closeSentence" type="xs:boolean" default="true">
					<xs:annotation>
						<xs:documentation>Do not capitalize and punctuation a top-level snippet.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:group name="ReplacementElementsGroup">
		<xs:choice>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="ContextName" type="ContextNameType"/>
			<xs:element name="DynamicRuleName" type="ContextNameType"/>
			<xs:element name="ObjectifyingInstanceIdentifierName" type="ObjectifyingInstanceIdentifierNameType"/>
			<xs:element name="ContextId" type="ElementIdType"/>
			<xs:element name="ContextSequenceNumber" type="ContextSequenceNumberType"/>
			<xs:element name="ExpressionBody" type="ExpressionBodyType"/>
			<xs:element name="NoteText" type="NoteTextType"/>
			<xs:element name="ReferenceMode" type="ReferenceModeType"/>
			<xs:element name="PortableDataType" type="PortableDataTypeType"/>
			<xs:element name="PortableDataTypeLength" type="PortableDataTypeLengthType"/>
			<xs:element name="PortableDataTypeScale" type="PortableDataTypeScaleType"/>
			<xs:element name="Notes" type="NotesType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
			<xs:element name="IterateSequences" type="IterateSequencesType"/>
			<xs:element name="IterateQueryParameters" type="IterateQueryParametersType"/>
			<xs:element name="IteratePathNodes" type="IteratePathNodesType"/>
			<xs:element name="IteratePathNodeLists" type="IteratePathNodeListsType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="DerivationPath" type="DerivationPathType"/>
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="IterateFacts" type="IterateFactsType"/>
			<xs:element name="JoinedSetConstraintName" type="ContextNameType"/>
			<xs:element name="JoinedSetComparisonSequenceConstraintName" type="ContextNameType"/>
			<xs:element name="ReferenceScheme" type="ReferenceSchemeType"/>
			<xs:element name="ConditionalReplacement" type="ConditionalReplacementType"/>
			<xs:element name="IterateValueRanges" type="IterateValueRangesType"/>
			<xs:element name="MinValue" type="MinValueType"/>
			<xs:element name="MaxValue" type="MaxValueType"/>
			<xs:element name="MinFrequencyValue" type="MinFrequencyValueType"/>
			<xs:element name="MaxFrequencyValue" type="MaxFrequencyValueType"/>
			<xs:element name="DefaultValue" type="DefaultValueType"/>
			<xs:element name="IterateRanges" type="IterateRangesType"/>
			<xs:element name="IterateDerivedFrom" type="IterateDerivedFromType"/>
			<xs:element name="RangeLowerBound" type="RangeLowerBoundType"/>
			<xs:element name="RangeUpperBound" type="RangeUpperBoundType"/>
			<xs:element name="IterateContextRoles" type="IterateContextRolesType"/>
			<xs:element name="PreferredIdentifierFor" type="PreferredIdentifierForType"/>
			<xs:element name="PreferredIdentifierForId" type="ElementIdType"/>
			<xs:element name="ProvidedRolePlayer" type="ProvidedRolePlayerType"/>
			<xs:element name="RoleName" type="RoleNameType"/>
			<xs:element name="RolePlayer" type="RolePlayerType"/>
			<xs:element name="RolePlayerName" type="RolePlayerNameType"/>
			<xs:element name="ParameterName" type="ParameterNameType"/>
			<xs:element name="RolePlayerReferenceMode" type="RolePlayerReferenceModeType"/>
			<xs:element name="SequenceJoinPath" type="SequenceJoinPathType"/>
			<xs:element name="Subscript" type="SubscriptType"/>
			<xs:element name="SubtypeName" type="SubtypeNameType"/>
			<xs:element name="SubtypeId" type="ElementIdType"/>
			<xs:element name="SupertypeName" type="SupertypeNameType"/>
			<xs:element name="SupertypeId" type="ElementIdType"/>
			<xs:element name="PathNodeVariable" type="PathNodeVariableType"/>
			<xs:element name="PathNodeFactType" type="PathNodeFactTypeType"/>
		</xs:choice>
	</xs:group>
	<xs:group name="ReplacementElementsWithConditionalMatchGroup">
		<xs:annotation>
			<xs:documentation>The elements listed in ReplacementElementsGroup with a
			conditionalMatch attribute added. Used inside the ConditionalReplacements element.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetTypeWithConditionalMatch"/>
			<xs:element name="IterateRoles">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateRolesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IteratePathNodes">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IteratePathNodesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IteratePathNodeLists">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IteratePathNodeListsType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="CompositeList">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="CompositeListType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ReferenceScheme">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ReferenceSchemeType"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="Fact">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="FactType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateFacts">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateFactsType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateSequences">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateSequencesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateQueryParameters">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateQueryParametersType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalReplacement">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ConditionalReplacementType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ReadingContext">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ReadingContextType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalReading">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ConditionalReadingType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateValueRanges">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateValueRangesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateRanges">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateRangesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MinValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MinValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MaxValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MaxValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MinFrequencyValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MinFrequencyValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MaxFrequencyValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MaxFrequencyValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RangeLowerBound">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RangeLowerBoundType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RangeUpperBound">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RangeUpperBoundType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateContextRoles">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateContextRolesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RoleName">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RoleNameType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RolePlayer">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RolePlayerType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RolePlayerReferenceMode">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RolePlayerReferenceModeType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ParameterName">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ParameterNameType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="SequenceJoinPath">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="SequenceJoinPathType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
							<xs:attribute name="leadVariableQuantifier" type="ve:SnippetTypeEnum">
								<xs:annotation>
									<xs:documentation>Use the HasSingleLeadPreProjectionKey conditional match to provide a snippet used to quantify the lead variable.</xs:documentation>
								</xs:annotation>
							</xs:attribute>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="PathNodeVariable">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="PathNodeVariableType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="PathNodeFactType">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="PathNodeFactTypeType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	
	<xs:complexType name="SnippetTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="SnippetType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
				<xs:attribute name="conditionalBlockContext" use="optional" type="ConditionalBlockContextType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConditionalSnippetType">
		<xs:annotation>
			<xs:documentation>Provides a commonly matchable pattern.  The ConditionalSnippet holds multiple potential
Snippets with match conditions, plus a fallback snippet.  The SnippetReplacements section
contains the replacement fields that will be used for all snippets.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetLeafTypeWithConditionalMatch"/>
			<xs:element name="SnippetReplacements" type="SnippetReplacementsType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ConditionalSnippetTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="ConditionalSnippetType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
				<xs:attribute name="conditionalBlockContext" use="optional" type="ConditionalBlockContextType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SnippetReplacementsType">
		<xs:annotation>
			<xs:documentation>Holds potential replacement fields for the conditional snippets listed above.
There must be at least as many replacement fields here as there are in the conditional snippet
which requires the most replacement fields.</xs:documentation>
		</xs:annotation>
		<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="ConditionalReplacementType">
		<xs:annotation>
			<xs:documentation>Provides a commonly matchable pattern similar to ConditionalSnippet.  Allows a conditional
selection of replacement contents anywhere a snippet can be used.</xs:documentation>
		</xs:annotation>
		<xs:group ref="ReplacementElementsWithConditionalMatchGroup" minOccurs="1" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="IterateValueRangesType">
		<xs:annotation>
			<xs:documentation>Iterates a value range collection.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateRangesType">
		<xs:annotation>
			<xs:documentation>Iterates a cardinality range collection.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateDerivedFromType">
		<xs:annotation>
			<xs:documentation>Iterates elements that use the context instance as part of the derivation.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<!-- This will be a SelfReference with conditional replacements -->
			<xs:element name="Snippet" type="SnippetType"/>
		</xs:sequence>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
	</xs:complexType>
	<xs:complexType name="PortableDataTypeType">
		<xs:annotation>
			<xs:documentation>Returns the portable data type of the object type.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PortableDataTypeLengthType">
		<xs:annotation>
			<xs:documentation>Returns the length value of a data type.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PortableDataTypeScaleType">
		<xs:annotation>
			<xs:documentation>Returns the scale value of a data type.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="NotesType">
		<xs:annotation>
			<xs:documentation>Returns the notes of the object type.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ContextNameType">
		<xs:annotation>
			<xs:documentation>Returns the name of the context (this) element.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="normalize" use="optional" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Specify if object type name normalization should be applied.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ObjectifyingInstanceIdentifierNameType">
		<xs:annotation>
			<xs:documentation>Returns the IdentifierName for an ObjectTypeInstance.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ParameterNameType">
		<xs:annotation>
			<xs:documentation>Returns the name of the current query parameter element.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ElementIdType">
		<xs:annotation>
			<xs:documentation>Returns the hyphenated string form of the id for the object type.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PreferredIdentifierForType">
		<xs:annotation>
			<xs:documentation>Returns the name of the identified ObjectType from the context of a UniquenessConstraint</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ObjectTypeInstanceValueType">
		<xs:annotation>
			<xs:documentation>Returns the value of the Object Type Instance</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="SubscriptType">
		<xs:annotation>
			<xs:documentation>Returns the value of the local subscript variable.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="SubtypeNameType">
		<xs:annotation>
			<xs:documentation>Returns the name of the sub type role player.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="SupertypeNameType">
		<xs:annotation>
			<xs:documentation>Returns the name of the sub type role player.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ExpressionBodyType">
		<xs:annotation>
			<xs:documentation>Returns the body of a derivation expression.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="NoteTextType">
		<xs:annotation>
			<xs:documentation>Returns the notes of the object type.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ReferenceModeType">
		<xs:annotation>
			<xs:documentation>Returns the reference mode of the object type.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MinValueType">
		<xs:annotation>
			<xs:documentation>Returns the minimum value of a value range constraint.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MaxValueType">
		<xs:annotation>
			<xs:documentation>Returns the maximum value of a value range constraint.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MinFrequencyValueType">
		<xs:annotation>
			<xs:documentation>Returns the minimum value of a frequency constraint.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MaxFrequencyValueType">
		<xs:annotation>
			<xs:documentation>Returns the maximum value of a frequency constraint.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RangeLowerBoundType">
		<xs:annotation>
			<xs:documentation>Returns the lower bound of a cardinality constraint.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RangeUpperBoundType">
		<xs:annotation>
			<xs:documentation>Returns the upper bound of a cardinality constraint.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="DefaultValueType">
		<xs:annotation>
			<xs:documentation>The resolved default value of a value type or role.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RoleNameType">
		<xs:annotation>
			<xs:documentation>Returns the name of a role.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RoleIndexType">
		<xs:annotation>
			<xs:documentation>Returns the index of the current role player in a context reading order. A context reading is required.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RolePlayerType">
		<xs:annotation>
			<xs:documentation>Returns the name of the current role player role.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RolePlayerNameType">
		<xs:annotation>
			<xs:documentation>Returns the normalized name of the current role player variable.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ProvidedRolePlayerType">
		<xs:annotation>
			<xs:documentation>Returns the role player formatted by path verbalizer for the given key.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="rolePlayerKey" use="required">
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="DerivationRule">
						<xs:annotation>
							<xs:documentation>Get the replacement based on the derivation key. Gets the current type (possibly subscripted) for a subtype derivation rule.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="SingleLeadRolePath">
						<xs:annotation>
							<xs:documentation>Get the replacement based on a single lead role path. For constraints with automatic opposite role players (trivial uniqueness and frequency patterns), this will be constrained object type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ConstraintRole">
						<xs:annotation>
							<xs:documentation>The role player for the constrained role in a role iterator context.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="QueryParameter">
						<xs:annotation>
							<xs:documentation>The parameter type for a query parameter in an IterateQueryParameters context.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="FactRole">
						<xs:annotation>
							<xs:documentation>The parameter type for a fact role parameter in a role iterator.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attributeGroup ref="RolePlayerRenderingOptions"/>
	</xs:complexType>
	<xs:complexType name="DerivationPathType">
		<xs:annotation>
			<xs:documentation>Defer to the path verbalizer to render the derivation path.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="thisContext" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Use the current this context instead of the 'derivationRule' variable.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="PathNodeVariableType">
		<xs:annotation>
			<xs:documentation>Retrieve a variable name from the context path node and path verbalizer.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PathNodeFactTypeType">
		<xs:annotation>
			<xs:documentation>Render a fact type for the context path node and path verbalizer.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RolePlayerReferenceModeType">
		<xs:annotation>
			<xs:documentation>Returns the reference mode scheme of the attached role player.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PredicateReplacementType">
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="ConditionalReplacement" type="ConditionalReplacementType">
				<xs:annotation>
					<xs:documentation>The {0} replacement field for snippets that are immediate children of this conditional replacement always corresponds to the role player name. Contained grandchild snippets are used as replacements for subsequent fields.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Snippet" type="SnippetType">
				<xs:annotation>
					<xs:documentation>The {0} replacement field for this snippet always corresponds to the role player name. Contained snippets are used as replacements for subsequent fields.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute name="match" use="optional" type="RoleIteratorContextMatchEnum"/>
		<xs:attribute name="alternateRolePlayer">
			<xs:annotation>
				<xs:documentation>Use with a binary constraint to use a role player other than the current role player.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="other">
						<xs:annotation>
							<xs:documentation>Use the role player for the other constraint role.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="primary">
						<xs:annotation>
							<xs:documentation>Use the role player for the primary role. This is equivalent to 'other' for the secondary role, but is easier to calculate because it is already tracked.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="subscript" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Explicitly use (or don't use) subscripts for this predicate replacement. Overrides the context EnableSubscripts/@custom or IterateRoles/@subscript values.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="overflowSubscript" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Add a subscript incremented beyond the normal required count for the factType. The specified value is added to the number of role players with this role player type that exist in the context fact type.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
		<xs:attribute name="once" use="optional" type="xs:string">
			<xs:annotation>
				<xs:documentation>Use this case one time only, tracked by the variable with the given name.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ProvidedPredicateReplacementType">
		<xs:choice minOccurs="0">
			<!--<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>-->
			<xs:element name="Snippet" type="SnippetType">
				<xs:annotation>
					<xs:documentation>Add a custom quantifier to the provided predicate replacement. Existential and back reference quantification is provided by the @quantify attribute, this allows other quantifiers.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute name="match" type="RoleIteratorContextMatchEnum" use="optional">
			<xs:annotation>
				<xs:documentation>Determine the type of constraint role to match.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="RolePlayerRenderingOptions"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:attributeGroup name="RolePlayerRenderingOptions">
		<xs:attribute name="quantify" default="false" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Quantify the returned replacement field.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="markAsHead" default="false" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Mark the returned variable as a head variable. Head variables are given back reference priority during automatic role path verbalization.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="minimizeHeadSubscripting" default="false" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Do not subscript a head variable of a type that is used for a single variable and also used fully existentially.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="FactTypeConstructType">
		<!-- Allow other secondary snippets to be included here. These come after the error reports. -->
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetTypeWithConditionalMatch" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="RoleConstructType">
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetTypeWithConditionalMatch" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SnippetContainerType" abstract="true">
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SubtypeConstructType">
		<xs:annotation>
			<xs:documentation>Returns the full verbalization for a subtype fact, i.e, Man is a subtype of Person.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SnippetContainerType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NoteConstructType">
		<xs:annotation>
			<xs:documentation>Returns the verbalization for the notes associated with an objectType.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SnippetContainerType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DerivationExpressionConstructType">
		<xs:annotation>
			<xs:documentation>Returns the verbalization for a derivation expression.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SnippetContainerType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ModelConstructType">
		<xs:annotation>
			<xs:documentation>Returns the verbalization for the ORMModel.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SnippetContainerType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectConstructType">
		<xs:annotation>
			<xs:documentation>Returns the full verbalization for an entity, value, or objectified fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetTypeWithConditionalMatch" />
			<xs:element name="ErrorReportHere" type="ErrorReportHereType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="DynamicRuleConstructType">
		<xs:annotation>
			<xs:documentation>Returns the full verbalization for a dynamic rule.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded" minOccurs="0">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetTypeWithConditionalMatch" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ErrorReportHereType">
		<xs:annotation>
			<xs:documentation>Add this tag between top-level snippets to indidate that the error report should be placed here instead of at the end.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="QueryConstructType">
		<xs:annotation>
			<xs:documentation>Returns the full verbalization for a query fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ErrorReportsType">
		<xs:annotation>
			<xs:documentation>Container for ErrorReport elements, which enable error generation of error reports without any additional verbalization.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ErrorReport" minOccurs="0" maxOccurs="unbounded">
				<xs:complexType>
					<xs:attributeGroup ref="childHelperAttributes"/>
					<xs:attribute name="type" use="required">
						<xs:annotation>
							<xs:documentation>The class name for the error report</xs:documentation>
						</xs:annotation>
						<xs:simpleType>
							<xs:restriction base="xs:token">
								<xs:enumeration value="ErrorReport">
									<xs:annotation>
										<xs:documentation>The class name for a standalone error report</xs:documentation>
									</xs:annotation>
								</xs:enumeration>
							</xs:restriction>
						</xs:simpleType>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FactType">
		<xs:annotation>
			<xs:documentation>Returns the full verbalization for a fact type, i.e, Company provides Product to Company.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="ProvidedPredicateReplacement" type="ProvidedPredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:choice>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchWithContextEnum"/>
		<xs:attribute name="subtypeMetaReading" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Use the 'Each A is an instance of B' meta reading for subtype facts instead of the 'A is B' instance reading.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="closeSentence" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Capitalize and punctuation the fact statement. Not applicable for top-level elements.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ReferenceSchemeType">
		<xs:annotation>
			<xs:documentation>Returns the reference scheme for an object, e.g. Country has CountryCode etc.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="IterateRolesNoListType">
		<xs:choice>
			<xs:sequence>
				<xs:element name="ReadingContext">
					<xs:annotation>
						<xs:documentation>If hyphenBind="true" on the parent and the pattern group contains multiple facts, then an additional ReadingContext needs to be set to support binding a reading of the current fact.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute name="match" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="Fact" type="FactType"/>
				<xs:element name="Snippet" type="SnippetType"/>
				<xs:element name="IterateContextRoles" type="IterateContextRolesType"/>
				<xs:element name="RolePlayer" type="RolePlayerType"/>
				<xs:element name="ProvidedRolePlayer" type="ProvidedRolePlayerType"/>
				<xs:element name="RoleIndex" type="RoleIndexType"/>
				<xs:element name="ConditionalReading" type="ConditionalReadingType"/>
			</xs:choice>
		</xs:choice>
		<xs:attribute name="match" type="IterateRolesMatchEnum" default="all"/>
		<xs:attributeGroup ref="FactArityAttributes"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
		<xs:attribute name="hyphenBind" type="xs:boolean" default="false"/>
		<xs:attribute name="subscript" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Explicitly use (or don't use) subscripts for predicate replacements in this contect. Overrides the context EnableSubscripts/@custom value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="LoopResetAttributes"/>
		<xs:attribute name="reverse" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Reverse the iteration order, processing the last item first.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conditionalReading">
			<xs:annotation>
				<xs:documentation>A filter based on the availability of the required reading for the specified context. Use with pass="first" to use a single reading only. The readingChoice for a nested Fact element should be ConditionalContext.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:union memberTypes="ReadingChoicePreferSingleMatchEnum ReadingChoiceFullRequiredMatchEnum"/>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="uniqueFactType" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Set to true if a visited FactTypes should be tracked. If this is set, then a later role with the same FactType will be ignored.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="verifyCanVerbalizeFactType" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Set to true if the FactType has not already been verified as have sufficient state to support verbalization.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="skipUnaryValueRole" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Set to true to filter out unary value roles.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="markProvidedConstraintRolesAsHead" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Used with the providedConstraintRoles match style. Mark the variable returned for the constrained role as a head variable. Head variables are given back reference priority during automatic role path verbalization.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="minimizeProvidedConstraintRoleHeadSubscripting" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Used with the providedConstraintRoles match style. Do not subscript a head variable of a type that is used for a single variable and also used fully existentially.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="resolveProvidedConstraintRoleSupertype" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Used with the providedConstraintRoles match style. Request that a resolved supertype variable be used in place of the role player directly associated with the constraint role.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="quantifyProvidedConstraintRoles" default="false" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Used with the providedConstraintRoles match style. Quantify the returned replacement field.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:attributeGroup name="LoopResetAttributes">
		<xs:attribute name="loopReset" use="optional">
			<xs:annotation>
				<xs:documentation>A list of helper patterns that generate code before an iterator loop processes the next element.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:list>
					<xs:simpleType>
						<xs:restriction base="xs:token">
							<xs:enumeration value="resetSubscripts">
								<xs:annotation>
									<xs:documentation>Reset the subscript counting on the subscript helper and role replacements.</xs:documentation>
								</xs:annotation>
							</xs:enumeration>
						</xs:restriction>
					</xs:simpleType>
				</xs:list>
			</xs:simpleType>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="IterateRolesType">
		<xs:complexContent>
			<xs:extension base="IterateRolesNoListType">
				<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IterateQueryParametersType">
		<xs:annotation>
			<xs:documentation>Iterates query parameters.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
	</xs:complexType>
	<xs:complexType name="SequenceJoinPathType">
		<xs:annotation>
			<xs:documentation>Use the join path for this sequence if it is available. Otherwise, verbalize the contents if provided.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0">
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
		</xs:choice>
		<xs:attribute name="markTrailingOutdentStart" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Strings returned for rendering a full role path should add an outdent replacement field immediately before the first of any trailing snippets that close an indentation.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pathPreValidated" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>The role path is validated as part of a condition. Do not call HasPathVerbalization before using the path.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ContextSequenceNumberType">
		<xs:annotation>
			<xs:documentation>The 1-based sequence number of context set comparison sequence.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="IterateSequencesType">
		<xs:choice>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
			<xs:element name="SequenceJoinPath" type="SequenceJoinPathType"/>
		</xs:choice>
		<xs:attributeGroup ref="FactArityAttributes"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
		<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
		<xs:attribute name="compositeList" type="xs:boolean" fixed="true">
			<xs:annotation>
				<xs:documentation>The listStyle represents a composite list. Ignored if listStyle is null. false is not currently supported.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="IterateInstancesType">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="ObjectTypeInstanceValue" type="ObjectTypeInstanceValueType"/>
		</xs:choice>
		<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
	</xs:complexType>
	<xs:complexType name="IterateFactsType">
		<xs:annotation>
			<xs:documentation>Returns the full verbalization for a list of fact types with the specified list style.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="ProvidedPredicateReplacement" type="ProvidedPredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:choice>
		<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
		<xs:attributeGroup ref="LoopResetAttributes"/>
		<xs:attribute name="reverse" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Reverse the iteration order, processing the last item first.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="IterateContextRolesNoListType">
		<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
		<xs:attribute name="match" type="RoleIteratorContextMatchEnum" use="optional"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
		<xs:attribute name="subscript" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Explicitly use (or don't use) subscripts for predicate replacements in this contect. Overrides the context EnableSubscripts/@custom value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="LoopResetAttributes"/>
		<xs:attribute name="reverse" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Reverse the iteration order, processing the last item first.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="IterateContextRolesType">
		<xs:complexContent>
			<xs:extension base="IterateContextRolesNoListType">
				<xs:attribute name="listStyle" type="ListStyleEnumOrNull" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IteratePathNodeListsType">
		<xs:annotation>
			<xs:documentation>Iterates lists of role path nodes.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="ConditionalReplacement" type="ConditionalReplacementType"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
		<xs:attribute name="match">
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="quantifiers">
						<xs:annotation>
							<xs:documentation>Iterate nodes from the head of the current dynamic role path. The items are in the two-item tuple form the dynamic state and path node lists.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="IteratePathNodesType">
		<xs:annotation>
			<xs:documentation>Iterates role path nodes.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="ConditionalReplacement" type="ConditionalReplacementType"/>
			<xs:element name="PathNodeVariable" type="PathNodeVariableType"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
		<xs:attribute name="match">
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="pathNodeList">
						<xs:annotation>
							<xs:documentation>Iterate nodes the context pathNodeList variable, such as when supplied by IteratePathNodeLists.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="add">
						<xs:annotation>
							<xs:documentation>Iterate nodes from the 'add' section the current dynamic role path.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="delete">
						<xs:annotation>
							<xs:documentation>Iterate nodes from the 'delete' section the current dynamic role path.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="BaseReadingContextType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ReadingChoiceType">
		<xs:complexContent>
			<xs:extension base="BaseReadingContextType">
				<xs:attribute name="match" use="optional" type="ReadingChoiceFullRequiredMatchEnum"/>
				<xs:attributeGroup ref="BlockHelperAttributes"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConditionalReadingType">
		<xs:sequence>
			<xs:element name="ReadingChoice" type="ReadingChoiceType" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReadingContextType">
		<xs:complexContent>
			<xs:extension base="BaseReadingContextType">
				<xs:attribute name="match" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompositeListType">
		<xs:choice>
			<xs:element name="IterateRoles" type="IterateRolesNoListType" minOccurs="2" maxOccurs="unbounded"/>
			<xs:element name="IterateContextRoles" type="IterateContextRolesNoListType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum" use="required"/>
	</xs:complexType>
	<xs:complexType name="ConstraintsConstructType">
		<xs:sequence>
			<xs:element name="Constraint" type="ConstraintType" minOccurs="1" maxOccurs="unbounded">
				<xs:unique name="ConstrainedRolesFilter">
					<xs:selector xpath="cvg:ConstrainedRoles"/>
					<xs:field xpath="@span"/>
					<xs:field xpath="@factArity"/>
					<xs:field xpath="@minFactArity"/>
					<xs:field xpath="@maxFactArity"/>
				</xs:unique>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SampleInstancesConstructType">
		<xs:annotation>
			<xs:documentation>Allows for generation of Verbalizers for Instances</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="SampleInstance" type="SampleInstanceType"/>
			<xs:element name="SingleSnippet" type="SingleSnippetType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ChildHelpersConstructType">
		<xs:annotation>
			<xs:documentation>Allows generation of custom child verbalizers.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="ChildVerbalizer" type="ChildVerbalizerType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ChildVerbalizerType">
		<xs:annotation>
			<xs:documentation>Create a custom child helper, which is a partial class instantiated with an IVerbalizeCustomChildren implementation.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetTypeWithConditionalMatch" />
		</xs:choice>
		<xs:attribute name="type" use="required">
			<xs:annotation>
				<xs:documentation>The generated class name.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="childHelperFor" use="optional">
			<xs:annotation>
				<xs:documentation>The containing class that will instantiate this helper.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="EnableSubscriptsType">
		<xs:attribute name="minFactArity" type="xs:positiveInteger"/>
		<xs:attribute name="maxFactArity" type="xs:positiveInteger"/>
		<xs:attribute name="factArity" type="xs:positiveInteger"/>
		<xs:attribute name="factCount" type="xs:positiveInteger"/>
		<xs:attribute name="minFactCount" type="xs:positiveInteger"/>
		<xs:attribute name="maxFactCount" type="xs:positiveInteger"/>
		<xs:attribute name="nonOptimizedFrequencyPattern" type="xs:boolean"/>
		<xs:attribute name="custom">
			<xs:annotation>
				<xs:documentation>Should replacement fields be generated for both subscripted and non-subscripted names?</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="defaultPlain">
						<xs:annotation>
							<xs:documentation>By default, use predicate replacements values without subscripts.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="defaultSubscript">
						<xs:annotation>
							<xs:documentation>By default, use predicate replacements values with subscripts.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="RingTypeEnum">
		<xs:restriction base="xs:token">
			<xs:enumeration value="Acyclic"/>
			<xs:enumeration value="Antisymmetric"/>
			<xs:enumeration value="Asymmetric"/>
			<xs:enumeration value="Intransitive"/>
			<xs:enumeration value="StronglyIntransitive"/>
			<xs:enumeration value="Irreflexive"/>
			<xs:enumeration value="Symmetric"/>
			<xs:enumeration value="Reflexive"/>
			<xs:enumeration value="PurelyReflexive"/>
			<xs:enumeration value="Transitive"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="FrequencyRangePatternEnum">
		<xs:restriction base="xs:token">
			<xs:enumeration value="Exact">
				<xs:annotation>
					<xs:documentation>The min and max frequency are equal</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnbounded">
				<xs:annotation>
					<xs:documentation>The min frequency is default (1, maps to no explicit bound)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MaxUnbounded">
				<xs:annotation>
					<xs:documentation>The max frequency is unbounded</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Both">
				<xs:annotation>
					<xs:documentation>The min and max frequency are both specified to non-default values</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ConstraintType">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="EnableSubscripts" type="EnableSubscriptsType"/>
			<xs:element name="ConstrainedRoles">
				<xs:complexType>
					<xs:choice minOccurs="1" maxOccurs="unbounded">
						<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
						<xs:element name="IterateRoles" type="IterateRolesType"/>
						<xs:element name="CompositeList" type="CompositeListType"/>
						<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
						<xs:element name="ConditionalReading" type="ConditionalReadingType">
							<xs:unique name="ConditionalReadingReadingChoice">
								<xs:selector xpath="cvg:ReadingChoice"/>
								<xs:field xpath="@match"/>
							</xs:unique>
						</xs:element>
						<xs:element name="ReadingContext" type="ReadingContextType"/>
					</xs:choice>
					<xs:attribute name="span" type="SpanEnum" use="optional"/>
					<xs:attribute name="sign" type="ve:SignEnum" use="optional"/>
					<xs:attribute name="ringType" type="RingTypeEnum" use="optional"/>
					<xs:attribute name="columnArity" type="xs:positiveInteger" use="optional"/>
					<xs:attribute name="sameConstraintRolePlayers" type="xs:boolean" use="optional">
						<xs:annotation>
							<xs:documentation>Used for a constraint with two roles that have the same role players. Use with set constraints.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="rolePlayerLimitedToConstraintRoles" type="xs:boolean" use="optional">
						<xs:annotation>
							<xs:documentation>Used to verify that the role players for the constraint roles are not used elsewhere in the fact type. Use after sameConstraintRolePlayers.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="frequencyRangePattern" type="FrequencyRangePatternEnum" use="optional">
						<xs:annotation>
							<xs:documentation>The frequency range pattern to check</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="trivialOppositeRolePath" type="xs:boolean" use="optional">
						<xs:annotation>
							<xs:documentation>A join path must be in place, and that join path must have a trivial opposite role player pattern, meaning that there is a shared opposite role player in binary fact types for all constraint roles.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attributeGroup ref="FactArityAttributes"/>
					<xs:attributeGroup ref="BlockHelperAttributes"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
		</xs:choice>
		<xs:attribute name="type" type="ConstraintTypeEnum" use="required"/>
		<xs:attribute name="patternGroup" type="ConstraintPatternGroupEnum" use="required"/>
		<xs:attribute name="automaticJoinPathPattern" use="optional">
			<xs:annotation>
				<xs:documentation>The verbalization leverages automatically created join paths. Add preliminary tests to see if automatic join paths are defined.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="OppositeRole">
						<xs:annotation>
							<xs:documentation>Test if the automatic join path was created for a single opposite role player.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="impliedConstraint" use="optional">
			<xs:annotation>
				<xs:documentation>This is verbalizing an implied single-role constraint on the proxy role for an implied fact type.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="Always">
						<xs:annotation>
							<xs:documentation>The constraint is verbalizing for a proxy role on an implied fact type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Check">
						<xs:annotation>
							<xs:documentation>The constraint may be verbalizing for a proxy role on an implied fact type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="compatibleColumns" type="xs:boolean" default="false"/>
		<xs:attributeGroup ref="childHelperAttributes"/>
		<xs:attribute name="deferMatchesTo" type="xs:string">
			<xs:annotation>
				<xs:documentation>Perform standard error handling, but defer all pattern matches to the specified function. Designed to work with either fully custom verbalization, or with wrapper code around generated helper classes.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:attributeGroup name="childHelperAttributes">
		<xs:attribute name="childHelperFor" type="ChildHelperForEnum" use="optional">
			<xs:annotation>
				<xs:documentation>Generate a nested helper class that can conditionally used by the parent class to verbalize custom children or with deferred verbalization.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="childHelperErrorReport" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Enable error report generation for a child helper.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="SampleInstanceType">
		<xs:annotation>
			<xs:documentation>Constructs IVerbalizer implementations for Sample Instance Data</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element name="IterateInstances" type="IterateInstancesType"/>
			<xs:sequence>
				<xs:element name="FactInstance">
					<xs:complexType/>
				</xs:element>
				<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
			</xs:sequence>
		</xs:choice>
		<xs:attribute name="type" use="required"/>
		<xs:attributeGroup ref="childHelperAttributes"/>
	</xs:complexType>
	<xs:complexType name="SingleSnippetType">
		<xs:annotation>
			<xs:documentation>Constructs IVerbalizer implementation to verbalize a single snippet</xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="required"/>
		<xs:attributeGroup ref="childHelperAttributes"/>
		<xs:attribute name="snippetRef" use="required" type="ve:SnippetTypeEnum"/>
	</xs:complexType>
	<xs:element name="VerbalizationRoot">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Copyright" minOccurs="0">
					<xs:annotation>
						<xs:documentation>Copyright notice.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="CopyrightLine" type="xs:string" maxOccurs="unbounded"/>
						</xs:sequence>
						<xs:attribute name="name" type="xs:string" use="required"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="Constructs" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:all>
							<xs:element name="FactType" type="FactTypeConstructType"/>
							<xs:element name="SubtypeFact" type="SubtypeConstructType"/>
							<xs:element name="Role" type="RoleConstructType"/>
							<xs:element name="Constraints" type="ConstraintsConstructType"/>
							<xs:element name="SampleInstances" type="SampleInstancesConstructType"/>
							<xs:element name="ObjectType" type="ObjectConstructType" />
							<xs:element name="QueryBase" type="QueryConstructType" />
							<xs:element name="Definition" type="NoteConstructType" />
							<xs:element name="Note" type="NoteConstructType" />
							<xs:element name="DerivationNote" type="DerivationExpressionConstructType"/>
							<xs:element name="ORMModel" type="ModelConstructType"/>
							<xs:element name="DynamicRule" type="DynamicRuleConstructType"/>
							<xs:element name="ChildHelpers" type="ChildHelpersConstructType"/>
							<xs:element name="ErrorReports" type="ErrorReportsType"/>
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="snippetsLocation" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>The relative location of the file containing the snippets</xs:documentation>
				</xs:annotation>
			</xs:attribute>
			<xs:attribute name="snippetsSchemaLocation" type="xs:string" use="optional">
				<xs:annotation>
					<xs:documentation>The relative location of the file containing the snippets schema, which is expected to redefine the SnippetTypeEnum from VerbalizationUntypedSnippets.xsd</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
</xs:schema>
