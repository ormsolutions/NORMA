<?xml version="1.0" encoding="utf-8"?>
<!-- Todo: Is external on object type?  What am I supposed to do with object shapes and data types? -->
<xs:schema targetNamespace="http://schemas.neumont.edu/ORM/2006-04/ORMCore" 
	elementFormDefault="qualified" attributeFormDefault="unqualified" 
	xmlns="http://schemas.neumont.edu/ORM/2006-04/ORMCore"
	xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:annotation>
		<xs:appinfo source="zlib/libpng License Copyright Notice">
			Copyright © Neumont University. All rights reserved.
			Copyright © ORM Solutions, LLC. All rights reserved.

			This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
			Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
			1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
			2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
			3. This notice may not be removed or altered from any source distribution.
		</xs:appinfo>
	</xs:annotation>
	<xs:complexType name="ExtensionsType">
		<xs:annotation>
			<xs:documentation>Standard container for extension data related to the containing element.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:any namespace="##other" processContents="strict"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="ORMModel" type="ORMModelType"/>
	<xs:complexType name="ORMModelType">
		<xs:annotation>
			<xs:documentation>Definition of elements used in the primary definition of an ORM model.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="Objects" type="ObjectTypesType" minOccurs="0"/>
			<xs:element name="Facts" type="FactTypesType" minOccurs="0"/>
			<xs:element name="Constraints" type="ConstraintsType" minOccurs="0"/>
			<xs:element name="DataTypes" type="DataTypesType" minOccurs="0"/>
			<xs:element name="Functions" type="FunctionsType" minOccurs="0"/>
			<xs:element name="CustomReferenceModes" type="CustomReferenceModesType" minOccurs="0"/>
			<xs:element name="ModelNotes" type="ModelNotesType" minOccurs="0"/>
			<xs:element name="ModelErrors" type="ModelErrorsType" minOccurs="0"/>
			<xs:element name="ReferenceModeKinds" type="ReferenceModeKindsType" minOccurs="0"/>
			<xs:element name="RecognizedPhrases" type="RecognizedPhrasesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:all>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The name of the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:attributeGroup name="idAttribute">
		<xs:attribute name="id" type="xs:ID" use="required">
			<xs:annotation>
				<xs:documentation>A unique identifier for this element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="idAttributeOptional">
		<xs:attribute name="id" type="xs:ID">
			<xs:annotation>
				<xs:documentation>A unique identifier for this element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="refAttribute">
		<xs:attribute name="ref" type="xs:IDREF" use="required">
			<xs:annotation>
				<xs:documentation>The value of the referenced element's unique id.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="ORMModelRef">
		<xs:annotation>
			<xs:documentation>Reference to an ORM model element.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--End ORMModel-->
	<xs:element name="ModelErrorDisplayFilter" type="ModelErrorDisplayFilterType"/>
	<xs:complexType name="ModelErrorDisplayFilterType">
		<xs:annotation>
			<xs:documentation>Validation error display filters based on error type and category.</xs:documentation>
		</xs:annotation>
		<!-- UNDONE: Temporary to pass XSD validation -->
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:any namespace="##any" processContents="skip"/>
		</xs:choice>
		<xs:anyAttribute namespace="##any" processContents="skip"/>
	</xs:complexType>
	<xs:complexType name="DefinitionsType">
		<xs:annotation>
			<xs:documentation>The container for informal description elements.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="Definition" type="DefinitionType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DefinitionType">
		<xs:annotation>
			<xs:documentation>An information description for the containing element.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Text" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Plain text description.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="AliasesType">
		<xs:annotation>
			<xs:documentation>Alternative names for the containing named element.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Alias" type="AliasType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="AliasType">
		<xs:annotation>
			<xs:documentation>An alternative name for the containing named element</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The alternative name</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="NameConsumer" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The type of consumer for this form of the name. NameConsumer types are provided by extension models.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="NameUsage" type="xs:string">
			<xs:annotation>
				<xs:documentation>Additional extension-provided categorization type for how a name should be used.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="NotesType">
		<xs:annotation>
			<xs:documentation>The container for note elements.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="Note" type="NoteType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NoteType">
		<xs:annotation>
			<xs:documentation>A note for the containing element.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Text" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Plain text note.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ModelNotesType">
		<xs:annotation>
			<xs:documentation>Container for miscellaneous notest associated with this model.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="ModelNote" type="ModelNoteType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ModelNoteType">
		<xs:annotation>
			<xs:documentation>A miscellaneous note for this model.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NoteType">
				<xs:sequence minOccurs="0">
					<xs:element name="ReferencedBy" type="ModelNoteReferencedByType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ModelNoteReferencedByType">
		<xs:annotation>
			<xs:documentation>A reference from a model note indicating a related element discussed by the note.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="FactType" type="FactTypeRef"/>
			<xs:element name="ObjectType" type="ObjectTypeRef"/>
			<xs:element name="SetConstraint" type="SetConstraintRef"/>
			<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
		</xs:choice>
	</xs:complexType>
	<!--Objects and Object Types-->
	<xs:complexType name="ObjectTypeRef">
		<xs:annotation>
			<xs:documentation>A reference to an object type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ObjectTypesType">
		<xs:annotation>
			<xs:documentation>Container for all object types in the model.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="EntityType" type="EntityTypeType"/>
			<xs:element name="ObjectifiedType" type="ObjectifiedTypeType"/>
			<xs:element name="ValueType" type="ValueTypeType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ObjectTypeType" abstract="true">
		<xs:sequence>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="Abbreviations" type="AliasesType" minOccurs="0"/>
			<xs:element name="PlayedRoles" type="PlayedRolesType" minOccurs="0"/>
			<xs:element name="SubtypeDerivationRule" type="SubtypeDerivationRuleType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Name" use="required" type="xs:string">
			<xs:annotation>
				<xs:documentation>The object type name. Validation errors will be present for any object type name that is not unique within the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="IsIndependent" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>An instance of this object type can exist without playing any non-identifying roles.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="IsExternal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This object type is externally defined (not used).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="IsPersonal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This object type refers to a person, not a thing. A directive to tell the verbalization to use personal pronouns.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="EntityTypeType">
		<xs:annotation>
			<xs:documentation>An object type with an external identification scheme.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ObjectTypeType">
				<xs:sequence>
					<xs:element name="PreferredIdentifier" type="UniquenessConstraintRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A reference to the uniqueness constraint that provides the preferred identification scheme for this entity type.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Instances" type="EntityTypeInstancesType" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<!--ReferenceMode is derived.-->
				<xs:attribute name="_ReferenceMode" type="xs:string">
					<xs:annotation>
						<xs:documentation>The name of the reference mode pattern used to identify this element. Derived from a single-role preferred identifier with a ValueType role player.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--The fact that an object is an ObjectifiedType is derrived.-->
	<xs:complexType name="ObjectifiedTypeType">
		<xs:annotation>
			<xs:documentation>An entity type that objectifies a fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ObjectTypeType">
				<xs:sequence>
					<xs:element name="PreferredIdentifier" type="UniquenessConstraintRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A reference to the uniqueness constraint that provides the preferred identification scheme for this entity type.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="NestedPredicate" type="ObjectifiedFactTypeRef"/>
					<xs:element name="Instances" type="EntityTypeInstancesType" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<!--ReferenceMode is derived.-->
				<xs:attribute name="_ReferenceMode" type="xs:string">
					<xs:annotation>
						<xs:documentation>The name of the reference mode pattern used to identify this element. Derived from a single-role preferred identifier with a ValueType role player.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--The fact that an object is a valuetype is derrived-->
	<xs:complexType name="ValueTypeType">
		<xs:annotation>
			<xs:documentation>An object type representing a self-identifying value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ObjectTypeType">
				<xs:sequence>
					<xs:element name="ConceptualDataType" type="DataTypeRef"/>
					<xs:element name="ValueRestriction" type="ValueTypeValueRestrictionType" minOccurs="0"/>
					<xs:element name="Instances" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Container for instances of this value type.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="ValueTypeInstance" type="ValueTypeInstanceType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="IsImplicitBooleanValue" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>True if this is an implied boolean value type. The implied boolean values are automatically created to provide a binarized form of a unary fact type.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SubtypeDerivationRuleType">
		<xs:annotation>
			<xs:documentation>The formal derivation rule defining a subtype.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SubtypeDerivationExpression" type="DerivationExpressionType" minOccurs="0"/>
			<xs:element name="SubtypeDerivationPath" type="SubtypeDerivationPathType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--End Objects and Object Types-->
	<!--ObjectTypeInstances-->
	<xs:complexType name="ObjectTypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to an object type instance. An object type instance may be a value instance, an entity instance, or a subtype instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeInstancesType">
		<xs:annotation>
			<xs:documentation>Container for instances associated with an entity type.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="EntityTypeInstance" type="EntityTypeInstanceType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="EntityTypeSubtypeInstance" type="EntityTypeSubtypeInstanceType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="EntityTypeInstanceType">
		<xs:annotation>
			<xs:documentation>An instance of a directly identified entity type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleInstances" type="EntityTypeRoleInstancesType" minOccurs="0"/>
			<xs:element name="ObjectifiedInstance" type="FactTypeInstanceRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A reference to the fact instance associated with this entity instance.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeSubtypeInstanceType">
		<xs:annotation>
			<xs:documentation>An instance of a subtype instance defined as a relationship to an instance of the identifying supertype.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SupertypeInstance" type="EntityTypeInstanceRef" minOccurs="0"/>
			<xs:element name="ObjectifiedInstance" type="FactTypeInstanceRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A reference to the fact instance associated with this subtype instance.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to an entity type instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeSubtypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to an entity type subtype instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeRoleInstancesType">
		<xs:annotation>
			<xs:documentation>Container for the role instances associated with an entity instance.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="EntityTypeRoleInstance" type="ObjectTypeRoleInstanceRef" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ObjectTypeRoleInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to a role instance, which is a use of an object instance by a role in a single entity instance or fact instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ValueTypeInstanceType">
		<xs:annotation>
			<xs:documentation>Value instance. All other instance specifications are ultimately combinations of value instances.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Value" type="xs:string">
				<xs:annotation>
					<xs:documentation>The text form of an instance value.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ValueTypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to a value instance</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RoleInstancesType">
		<xs:annotation>
			<xs:documentation>Container for relationships between instances of the role player and roles used in other complex instance definitions.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="EntityTypeRoleInstance" type="RoleInstanceType"/>
			<xs:element name="ValueTypeRoleInstance" type="RoleInstanceType"/>
			<xs:element name="FactTypeRoleInstance" type="RoleInstanceType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="RoleInstanceType">
		<xs:annotation>
			<xs:documentation>An identified reference to an object type instance. An object type instance may be a value instance, an entity instance, or a subtype instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeInstancesType">
		<xs:annotation>
			<xs:documentation>Container for instances associated with a fact type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="FactTypeInstance" type="FactTypeInstanceType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FactTypeInstanceType">
		<xs:annotation>
			<xs:documentation>A fact instance defined by a population of the fact roles.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleInstances" type="FactTypeRoleInstancesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to a fact instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeRoleInstancesType">
		<xs:annotation>
			<xs:documentation>Container for the role instances associated with a fact instance.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="FactTypeRoleInstance" type="ObjectTypeRoleInstanceRef" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--end ObjectTypeInstances-->
	<!--DataType -->
	<!--DataTypeRef indicates a reference to a datatype -->
	<xs:complexType name="DataTypeRef">
		<xs:annotation>
			<xs:documentation>A use of a data type, including facet information.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttributeOptional"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="Scale" type="xs:int">
			<xs:annotation>
				<xs:documentation>The value of the Scale facet.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Length" type="xs:int">
			<xs:annotation>
				<xs:documentation>The value of the Length facet. Holds the Precision fact for Decimal and Money data types.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DataTypeRefRef">
		<xs:annotation>
			<xs:documentation>A reference to the use of a data type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--end DataTypeRef-->
	<xs:complexType name="DataTypesType">
		<xs:annotation>
			<xs:documentation>Container for all data types used in the model.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="UnspecifiedDataType" type="UnspecifiedDataTypeType"/>
			<xs:element name="FixedLengthTextDataType" type="FixedLengthTextDataTypeType"/>
			<xs:element name="VariableLengthTextDataType" type="VariableLengthTextDataTypeType"/>
			<xs:element name="LargeLengthTextDataType" type="LargeLengthTextDataTypeType"/>
			<xs:element name="SignedIntegerNumericDataType" type="SignedIntegerNumericDataTypeType"/>
			<xs:element name="SignedSmallIntegerNumericDataType" type="SignedSmallIntegerNumericDataTypeType"/>
			<xs:element name="SignedLargeIntegerNumericDataType" type="SignedLargeIntegerNumericDataTypeType"/>
			<xs:element name="UnsignedIntegerNumericDataType" type="UnsignedIntegerNumericDataTypeType"/>
			<xs:element name="UnsignedTinyIntegerNumericDataType" type="UnsignedTinyIntegerNumericDataTypeType"/>
			<xs:element name="UnsignedSmallIntegerNumericDataType" type="UnsignedSmallIntegerNumericDataTypeType"/>
			<xs:element name="UnsignedLargeIntegerNumericDataType" type="UnsignedLargeIntegerNumericDataTypeType"/>
			<xs:element name="AutoCounterNumericDataType" type="AutoCounterNumericDataTypeType"/>
			<xs:element name="FloatingPointNumericDataType" type="FloatingPointNumericDataTypeType"/>
			<xs:element name="SinglePrecisionFloatingPointNumericDataType" type="SinglePrecisionFloatingPointNumericDataTypeType"/>
			<xs:element name="DoublePrecisionFloatingPointNumericDataType" type="DoublePrecisionFloatingPointNumericDataTypeType"/>
			<xs:element name="DecimalNumericDataType" type="DecimalNumericDataTypeType"/>
			<xs:element name="MoneyNumericDataType" type="MoneyNumericDataTypeType"/>
			<xs:element name="FixedLengthRawDataDataType" type="FixedLengthRawDataDataTypeType"/>
			<xs:element name="VariableLengthRawDataDataType" type="VariableLengthRawDataDataTypeType"/>
			<xs:element name="LargeLengthRawDataDataType" type="LargeLengthRawDataDataTypeType"/>
			<xs:element name="PictureRawDataDataType" type="PictureRawDataDataTypeType"/>
			<xs:element name="OleObjectRawDataDataType" type="OleObjectRawDataDataTypeType"/>
			<xs:element name="AutoTimestampTemporalDataType" type="AutoTimestampTemporalDataTypeType"/>
			<xs:element name="TimeTemporalDataType" type="TimeTemporalDataTypeType"/>
			<xs:element name="DateTemporalDataType" type="DateTemporalDataTypeType"/>
			<xs:element name="DateAndTimeTemporalDataType" type="DateAndTimeTemporalDataTypeType"/>
			<xs:element name="TrueOrFalseLogicalDataType" type="TrueOrFalseLogicalDataTypeType"/>
			<xs:element name="YesOrNoLogicalDataType" type="YesOrNoLogicalDataTypeType"/>
			<xs:element name="RowIdOtherDataType" type="RowIdOtherDataTypeType"/>
			<xs:element name="ObjectIdOtherDataType" type="ObjectIdOtherDataTypeType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="DataType" abstract="true">
		<xs:annotation>
			<xs:documentation>The base type for all data types</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:choice>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="UnspecifiedDataTypeType">
		<xs:annotation>
			<xs:documentation>Placeholder for an unspecified data type. Each use of this type results in a DataTypeNotSpecified model validation error.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FixedLengthTextDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of fixed length strings. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="VariableLengthTextDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of variable length strings. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LargeLengthTextDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of large length strings. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SignedIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 4-byte signed integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SignedSmallIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 2-byte signed integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SignedLargeIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 8-byte signed integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnsignedIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 4-byte unsigned integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnsignedTinyIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of unsigned byte integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnsignedSmallIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 2-byte unsigned integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnsignedLargeIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 8-byte unsigned integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AutoCounterNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of automatically generated unsigned long integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FloatingPointNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of floating point numbers. Supports the Precision facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SinglePrecisionFloatingPointNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 4-byte floating point numbers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DoublePrecisionFloatingPointNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 8-byte floating point numbers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DecimalNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of moveable decimal point exact numbers. Supports the Precision and Scale facets.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MoneyNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of moveable decimal point exact numbers. Supports the Precision and Scale facets.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FixedLengthRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of fixed length binary data. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="VariableLengthRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of variable length binary data. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LargeLengthRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of large length binary data. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PictureRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of binary data representing an image.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OleObjectRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of binary data representing an embedded OLE object.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AutoTimestampTemporalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of automatically generated timestamps.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TimeTemporalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values represent time information.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DateTemporalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values represent date information.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DateAndTimeTemporalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values represent date and time information.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TrueOrFalseLogicalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are either true or false.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="YesOrNoLogicalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are either yes or no.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RowIdOtherDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of row identifiers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectIdOtherDataTypeType">
		<xs:annotation>
			<xs:documentation>Values represent an object identifier.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<!--End DataType -->
	<!--Roles-->
	<!-- RoleRef, RoleSequence and  RoleSequences define references to roles and collections of roles and collections of collections of roles-->
	<xs:complexType name="ConstraintRoleSequencesType">
		<xs:annotation>
			<xs:documentation>Container for constraint role sequences.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleSequence" type="ConstraintRoleSequenceWithIdType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PlayedRolesType">
		<xs:annotation>
			<xs:documentation>Container for the roles played an entity type. Duplicates the RolePlayer information specified on the played roles.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Role" type="RoleRef"/>
			<xs:element name="SubtypeMetaRole" type="RoleRef"/>
			<xs:element name="SupertypeMetaRole" type="RoleRef"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ReadingRoleSequenceType">
		<xs:annotation>
			<xs:documentation>An order sequence of roles in a single fact type.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Role" type="RoleRef"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleSequenceType">
		<xs:annotation>
			<xs:documentation>A sequence of constraint roles.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Role" type="RoleSequenceRoleRef" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="JoinPath" type="JoinPathType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleSequenceWithIdType">
		<xs:annotation>
			<xs:documentation>A sequence of constraint roles with an identifier.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ConstraintRoleSequenceType">
				<xs:attributeGroup ref="idAttribute"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RoleSequenceRoleRef">
		<xs:complexContent>
			<xs:extension base="RoleRef">
				<xs:sequence>
					<xs:element name="ProjectionJoin" type="JoinRef" minOccurs="0"/>
				</xs:sequence>
				<xs:attributeGroup ref="idAttributeOptional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RoleRef">
		<xs:annotation>
			<xs:documentation>A reference to a role.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--end RoleRef, RoleSequence and  RoleSequences-->
	<xs:complexType name="JoinPathType">
		<xs:annotation>
			<xs:documentation>A path linking roles from different fact types in the same constraint role sequence. (preliminary)</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Join" type="JoinType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="JoinType">
		<xs:annotation>
			<xs:documentation>A between two roles with the same role player.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="InputRole" type="RoleRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A reference to the input role of the join operation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OutputRole" type="RoleRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A reference to the output role of the join operation.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="JoinType" type="JoinCombinationValues" default="Inner"/>
	</xs:complexType>
	<xs:simpleType name="JoinCombinationValues">
		<xs:annotation>
			<xs:documentation>Specify whether instances used by the input role but not the output role are included in the join.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="Inner">
				<xs:annotation>
					<xs:documentation>Use inner join semantics. An instance must be used by both the input and output roles.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Outer">
				<xs:annotation>
					<xs:documentation>Use outer join semantics. An instance used by the input role must not be used by the output role.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="JoinRef">
		<xs:annotation>
			<xs:documentation>A reference to a join.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactRolesType">
		<xs:annotation>
			<xs:documentation>Container for roles in a fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Role" type="RoleType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ImpliedFactRolesType">
		<xs:annotation>
			<xs:documentation>Container for roles in a fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:sequence>
				<xs:element name="Role" type="RoleType"/>
				<xs:choice>
					<xs:element name="RoleProxy" type="RoleProxyType"/>
					<xs:element name="ObjectifiedUnaryRole" type="ObjectifiedUnaryRoleType"/>
				</xs:choice>
			</xs:sequence>
			<xs:sequence>
				<xs:choice>
					<xs:element name="RoleProxy" type="RoleProxyType"/>
					<xs:element name="ObjectifiedUnaryRole" type="ObjectifiedUnaryRoleType"/>
				</xs:choice>
				<xs:element name="Role" type="RoleType"/>
			</xs:sequence>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SubtypeRolesType">
		<xs:annotation>
			<xs:documentation>Container for the meta roles associated with a subtype fact.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="SupertypeMetaRole" type="RoleType">
				<xs:annotation>
					<xs:documentation>The meta role associated with the supertype role player.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SubtypeMetaRole" type="RoleType">
				<xs:annotation>
					<xs:documentation>The meta role associated with the subtype role player.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:all>
	</xs:complexType>
	<xs:complexType name="RoleBaseType" abstract="true">
		<xs:sequence>
			<xs:element name="RolePlayer" type="ObjectTypeRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A reference to the object type that plays this role.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ValueRestriction" type="RoleValueRestrictionType" minOccurs="0"/>
			<xs:element name="DerivationSource" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The node in the derivation path used to populate this role in a derived fact type.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice minOccurs="0">
						<xs:element name="PathedRole" type="PathedRoleRef"/>
						<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
						<xs:element name="Constant" type="PathConstantType"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
			<xs:element name="RoleInstances" type="RoleInstancesType"  minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>An explicit name for this role.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<!--Derived-->
		<xs:attribute name="_IsMandatory" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Derived attribute set to true if this role is associated with a simple mandatory constraint.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!--Derived-->
		<xs:attribute name="_Multiplicity" type="MultiplicityValues" default="ZeroToOne"/>
	</xs:complexType>
	<xs:complexType name="RoleType">
		<xs:annotation>
			<xs:documentation>A primary role declaration.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RoleBaseType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RoleProxyType">
		<xs:annotation>
			<xs:documentation>The role in an implied fact type that corresponds to a role in the objectified fact type. In terms of constraints, the role proxy is treated as the same role. The only normal role relationship allowed on a proxy role is inclusion in a reading order.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Role" type="RoleRef"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ObjectifiedUnaryRoleType">
		<xs:annotation>
			<xs:documentation>A role representing the identifying role in the fact type implied between the object type that objectifies a unary role and the unary role player. There is an implied equality constraint between this role and the referenced unary role.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RoleBaseType">
				<xs:sequence>
					<xs:element name="UnaryRole" type="RoleRef">
						<xs:annotation>
							<xs:documentation>A reference to the objectified unary role.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--Look up enum values.-->
	<xs:simpleType name="MultiplicityValues">
		<xs:annotation>
			<xs:documentation>The UML-style multiplicity for a role in a binary fact type. Derived from internal uniqueness and mandatory constraints.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Unspecified">
				<xs:annotation>
					<xs:documentation>No internal constraints are specified.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Indeterminate">
				<xs:annotation>
					<xs:documentation>Specified internal constraints are inconsistent, resulting in a multiplicity that cannot be determined.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ZeroToOne">
				<xs:annotation>
					<xs:documentation>At most one instance of this role player may be associated with the opposite role player. Corresponds to a single role uniqueness constraint on the opposite role.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ZeroToMany">
				<xs:annotation>
					<xs:documentation>Zero or more instances of this role player can be associated a single instance of the opposite role player.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ExactlyOne">
				<xs:annotation>
					<xs:documentation>Exactly one instance of this role player may be associated with the opposite role player. Corresponds to single role uniqueness and mandatory constraints on the opposite role.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="OneToMany">
				<xs:annotation>
					<xs:documentation>One or more instances of this role player can be associated a single instance of the opposite role player.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--End Roles-->
	<!-- Facts -->
	<!--Fact Ref defines a reference to a fact-->
	<xs:complexType name="FactTypeRef">
		<xs:annotation>
			<xs:documentation>A reference to a fact type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ObjectifiedFactTypeRef">
		<xs:annotation>
			<xs:documentation>A reference to the fact type, representing the objectification relationship between the entity type and the referenced fact type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="IsImplied" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>True if the objectification relationship is implied by a spanning uniqueness constraint on a binary fact type or an n-ary fact type where n&gt;2. The objectifying entity type for an implied fact type is always independent.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ObjectificationRef">
		<xs:annotation>
			<xs:documentation>A reference to an objectification relationship.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--end Fact Ref-->
	<xs:complexType name="FactTypesType">
		<xs:annotation>
			<xs:documentation>Container for all fact types in the model.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactTypeType"/>
			<xs:element name="SubtypeFact" type="SubtypeFactTypeType"/>
			<xs:element name="ImpliedFact" type="ImpliedFactTypeType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="FactTypeType">
		<xs:annotation>
			<xs:documentation>A fact type directly specified by the modeler.</xs:documentation>
		</xs:annotation>
		<!-- These are duplicated in ImpliedFactTypeType and SubtypeFactTypeType without type extension -->
		<xs:sequence minOccurs="0">
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="FactRoles" type="FactRolesType" minOccurs="0"/>
			<xs:element name="ReadingOrders" type="ReadingOrdersType" minOccurs="0"/>
			<xs:element name="InternalConstraints" type="InternalConstraintsType" minOccurs="0"/>
			<xs:element name="DerivationRule" type="FactTypeDerivationRuleType" minOccurs="0"/>
			<xs:element name="Instances" type="FactTypeInstancesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="_Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>A name generated from the first reading of the first reading order, or the name of the objectifying entity type.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="IsExternal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This fact type is externally defined (not used).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ImpliedFactTypeType">
		<xs:annotation>
			<xs:documentation>A fact type representing the implied relationship between an objectifying entity type and the role player of a role in the objectified fact type.</xs:documentation>
		</xs:annotation>
		<!-- This is a straight copy from Fact with a change to FactRoles -->
		<xs:sequence minOccurs="0">
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="FactRoles" type="ImpliedFactRolesType" minOccurs="0"/>
			<xs:element name="ReadingOrders" type="ReadingOrdersType" minOccurs="0"/>
			<xs:element name="InternalConstraints" type="InternalConstraintsType" minOccurs="0"/>
			<xs:element name="DerivationRule" type="FactTypeDerivationRuleType" minOccurs="0"/>
			<xs:element name="ImpliedByObjectification" type="ObjectificationRef">
				<xs:annotation>
					<xs:documentation>A reference to the objectification relationship that implies this fact type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="_Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>A name generated from the first reading of the first reading order.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="IsExternal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This fact type is externally defined (not used).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SubtypeFactTypeType">
		<xs:annotation>
			<xs:documentation>A fact type representing the subtype meta relationship between a subtype and a supertype.</xs:documentation>
		</xs:annotation>
		<!-- This is a straight copy from FactTypeType with a change to FactRoles -->
		<xs:sequence minOccurs="0">
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="FactRoles" type="SubtypeRolesType"/>
			<xs:element name="ReadingOrders" type="ReadingOrdersType" minOccurs="0"/>
			<xs:element name="InternalConstraints" type="InternalConstraintsType" minOccurs="0"/>
			<!-- UNDONE: Remove SubtypeFactTypeType.DerivationRule when file format is officially updated -->
			<xs:element name="DerivationRule" type="FactTypeDerivationRuleType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>(deprecated) Subtype derivation rules are expressed directly on the subtype, not the subtype fact relationship.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Instances" type="FactTypeInstancesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="_Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>A name generated from the implied reading for subtype fact, name 'AIsASubtypeOfB'.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="IsExternal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This fact type is externally defined (not used).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="IsPrimary" type="xs:boolean" default="false">
			<xs:annotation>
				<!-- UNDONE: Remove IsPrimary when file format is officially updated -->
				<xs:documentation>Deprecated property, use PreferredIdentificationPath instead.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PreferredIdentificationPath" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>The subtype fact is a possible path through the subtype graph for retrieving the identifying supertype for the subtype. The identifying supertype can be a direct or indirect supertype.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--Derived FactType-->
	<xs:complexType name="FactTypeDerivationRuleType">
		<xs:annotation>
			<xs:documentation>The formal derivation rule defining a fact type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DerivationExpression" type="FactTypeDerivationExpressionType" minOccurs="0"/>
			<xs:element name="FactTypeDerivationPath" type="FactTypeDerivationPathType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DerivationExpressionType">
		<xs:annotation>
			<xs:documentation>A derivation expression.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Body" type="xs:string">
				<xs:annotation>
					<xs:documentation>A textual derivation expression. This will be replaced in the future with a formal definition involving role paths and other relationships.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeDerivationExpressionType">
		<xs:complexContent>
			<xs:extension base="DerivationExpressionType">
				<xs:attribute name="DerivationStorage" type="DerivationExpressionStorageValues" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="DerivationExpressionStorageValues">
		<xs:annotation>
			<xs:documentation>Specify how instances of derived fact type are stored.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Derived">
				<xs:annotation>
					<xs:documentation>The fact instance population is calculated on demand.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="DerivedAndStored">
				<xs:annotation>
					<xs:documentation>The fact instance population is calculated immediately and stored.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PartiallyDerived">
				<xs:annotation>
					<xs:documentation>The fact instance population can be asserted as well as derived.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PartiallyDerivedAndStored">
				<xs:annotation>
					<xs:documentation>The fact instance population can be asserted as well as calculated immediately and stored.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--End Derived FactType-->
	<!-- End Facts -->
	<!-- Role Paths -->
	<xs:complexType name="FunctionsType">
		<xs:annotation>
			<xs:documentation>A container for all Function definitions used in the model.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Function" type="FunctionType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FunctionType">
		<xs:annotation>
			<xs:documentation>Specifies a function definition used for calculating values.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Parameters" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A container for function parameters</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Parameter" type="FunctionParameterType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The name of the function.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="IsBoolean" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>True if this function or operator returns a boolean value, making it appropriate for use as a path condition.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="OperatorSymbol" type="xs:string">
			<xs:annotation>
				<xs:documentation>A symbol used to display this function as an operator. Treated as an infix operator for binary functions and a prefix operator for unary functions.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="FunctionRef">
		<xs:annotation>
			<xs:documentation>A reference to an function.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FunctionParameterType">
		<xs:annotation>
			<xs:documentation>A function parameter, defines the type of function input.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The name of the function parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="BagInput" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Set to true if this functions takes a bag input instead of a single value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="FunctionParameterRef">
		<xs:annotation>
			<xs:documentation>A reference to an function parameter.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RolePathType" abstract="true">
		<xs:sequence>
			<xs:element name="PathedRoles" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A container for PathedRole elements.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="PathedRole" type="PathedRoleType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SubPaths" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A container for SubPath elements.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="SubPath" type="RoleSubPathType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="SplitIsNegated" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Should all sub paths split from this path be treated as negations?</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="SplitCombinationOperator" type="LogicalCombinationOperatorType" default="And">
			<xs:annotation>
				<xs:documentation>Specify how sub paths split from this path should be combined.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RoleSubPathType">
		<xs:annotation>
			<xs:documentation>A role path that extends a parent path with a split condition.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RolePathType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PathedRoleType">
		<xs:annotation>
			<xs:documentation>A role in connected path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="CorrelatedWith" type="PathedRoleRef" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="Purpose" type="PathedRolePurposeType" use="required"/>
		<xs:attribute name="IsNegated" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>The path step is treated as a negation.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="PathedRoleRef">
		<xs:annotation>
			<xs:documentation>A reference to an pathed role.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:simpleType name="PathedRolePurposeType">
		<xs:annotation>
			<xs:documentation>Specify how a role in a path is used to step within and between fact types.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="StartRole">
				<xs:annotation>
					<xs:documentation>The role is the beginning of a path and directly attached to the root object type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SameFactType">
				<xs:annotation>
					<xs:documentation>The role is the same fact type as the previous join or start role.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PostInnerJoin">
				<xs:annotation>
					<xs:documentation>The role represents an inner over a role player shared with the previous role in the path.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PostOuterJoin">
				<xs:annotation>
					<xs:documentation>The role represents an outer join over a role player shared with the previous role in the path.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="LogicalCombinationOperatorType">
		<xs:annotation>
			<xs:documentation>Specifies the logical operator used to combine 2 or more elements.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="And">
				<xs:annotation>
					<xs:documentation>All values must be true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Or">
				<xs:annotation>
					<xs:documentation>At least one value must be true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Xor">
				<xs:annotation>
					<xs:documentation>Applied to two values, exactly one value must be true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="PrimaryRolePathType" abstract="true">
		<xs:complexContent>
			<xs:extension base="RolePathType">
				<xs:sequence>
					<xs:element name="RootObjectType" minOccurs="0" type="ObjectTypeRef"/>
					<xs:element name="CalculatedValues" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A container for calculated values applied to any roles in the primary role path.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="CalculatedValue" type="CalculatedValueType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="Conditions" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A list of calculated boolean results that are necessary conditions for this role path.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="CalculatedCondition" type="CalculatedValueRef" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CalculatedValueType">
		<xs:annotation>
			<xs:documentation>Specifies the function, scope, and inputs used for an algorithmic calculation.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Function" type="FunctionRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The function used to perform the calculation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Scope" type="PathedRoleRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The pathed role that provides the context for this calculation. Generally used to defined the extent of elements based to a bag parameter.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Inputs" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Inputs passed to the function used for the calculation.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Input" type="CalculatedValueInputType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="CalculatedValueInputType">
		<xs:annotation>
			<xs:documentation>An input to the function used to calculate a value.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Parameter" type="FunctionParameterRef" minOccurs="0"/>
			<xs:element name="Source" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The source of value or bag passed to this parameter.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice minOccurs="0">
						<xs:element name="PathedRole" type="PathedRoleRef"/>
						<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
						<xs:element name="Constant" type="PathConstantType"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="PathConstantType">
		<xs:annotation>
			<xs:documentation>A constant value used in a role path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Value" type="xs:string">
				<xs:annotation>
					<xs:documentation>The lexical constant value. The value is interpreted based on context.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="CalculatedValueRef">
		<xs:annotation>
			<xs:documentation>A reference to a calculated value.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeDerivationPathType">
		<xs:annotation>
			<xs:documentation>A role path with projected nodes used to define the population of a derived fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="PrimaryRolePathType">
				<xs:attribute name="DerivationCompleteness" type="DerivationCompletenessValues" default="FullyDerived"/>
				<xs:attribute name="DerivationStorage" type="DerivationStorageValues" default="NotStored"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="DerivationCompletenessValues">
		<xs:annotation>
			<xs:documentation>Specify if instances of a derived fact can also be directly asserted.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="FullyDerived">
				<xs:annotation>
					<xs:documentation>The fact instance population is calculated on demand.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PartiallyDerived">
				<xs:annotation>
					<xs:documentation>The fact instance population can be both calculated and asserted.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DerivationStorageValues">
		<xs:annotation>
			<xs:documentation>Specify if derived fact instances should be recalculated on demand, or calculated on change and stored.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="NotStored">
				<xs:annotation>
					<xs:documentation>Fact instances are recalculated on demand.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Stored">
				<xs:annotation>
					<xs:documentation>Fact instances are calculated on change and stored.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="SubtypeDerivationPathType">
		<xs:annotation>
			<xs:documentation>A role path used to define the population of a derived subtype.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="PrimaryRolePathType">
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- End Role Paths -->
	<!--Constraints-->
	<xs:complexType name="EqualityConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to an equality constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ExclusionConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to an exclusion constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="MandatoryConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a mandatory constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a frequency constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RingConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a ring constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ConstraintsType">
		<xs:annotation>
			<xs:documentation>Container for SetConstraints and SetComparisonConstraints.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="EqualityConstraint" type="EqualityConstraintType"/>
			<xs:element name="ExclusionConstraint" type="ExclusionConstraintType"/>
			<xs:element name="SubsetConstraint" type="SubsetConstraintType"/>
			<xs:element name="FrequencyConstraint" type="FrequencyConstraintType"/>
			<xs:element name="MandatoryConstraint" type="MandatoryConstraintType"/>
			<xs:element name="UniquenessConstraint" type="UniquenessConstraintType"/>
			<xs:element name="RingConstraint" type="RingConstraintType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ConstraintType" abstract="true">
		<xs:sequence>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The constraint name. Validation errors will be present for any constraint name that is not unique within the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Modality" type="ConstraintModalityValues" default="Alethic"/>
	</xs:complexType>
	<!-- SetComparison constraints-->
	<xs:complexType name="SetComparisonConstraintType" abstract="true">
		<xs:complexContent>
			<xs:extension base="ConstraintType">
				<xs:sequence>
					<xs:element name="RoleSequences" type="ConstraintRoleSequencesType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EqualityConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that two set populations must be equal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetComparisonConstraintType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ExclusionConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that two set populations must not be equal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetComparisonConstraintType">
				<xs:sequence>
					<xs:element name="ExclusiveOrMandatoryConstraint" type="MandatoryConstraintRef" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SubsetConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that the population of one set must be included in the population of another set.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetComparisonConstraintType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SetComparisonConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a subset, equality, or exclusion constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="SetConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a mandatory, uniqueness, frequency, or ring constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ValueConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a role or value type value constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!-- end SetComparison constraints-->
	<!--Set constraints-->
	<xs:complexType name="SetConstraintType" abstract="true">
		<xs:complexContent>
			<xs:extension base="ConstraintType">
				<xs:sequence>
					<xs:element name="RoleSequence" type="ConstraintRoleSequenceType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying the number of times an instance must occur in a set population. Applies only if the instance appears at all.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="MinFrequency" type="xs:int">
					<xs:annotation>
						<xs:documentation>The minimum number of times an instance must be played by the constrained role(s).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="MaxFrequency" type="xs:int">
					<xs:annotation>
						<xs:documentation>The maximum number of times an instance must be played by the constrained role(s).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MandatoryConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that a set must be populated.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintType">
				<xs:sequence>
					<xs:element name="ExclusiveOrExclusionConstraint" type="ExclusionConstraintRef" minOccurs="0"/>
					<xs:element name="ImpliedByObjectType" type="ObjectTypeRef" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="IsSimple" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>True if this is an internal constraint associated with a single role.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="IsImplied" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>True if this constraint is implied by a lack of a mandatory role on any non-existential role on the non-independent role player. An implied mandatory constraint may have a single role or multiple roles, but IsSimple is never true for an implied mandatory constraint.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UniquenessConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that the population of a set must be unique.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintType">
				<xs:sequence>
					<xs:element name="PreferredIdentifierFor" type="ObjectTypeRef" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="IsInternal" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>If true, this uniqueness constraint is internal to a single fact type.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RingConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying relationships between elements of the same type in a set population.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="Type" type="RingConstraintTypeValues" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="RingConstraintTypeValues">
		<xs:annotation>
			<xs:documentation>Restrictions on the intersections of instances associated with roles in a ring constraint.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Undefined">
				<xs:annotation>
					<xs:documentation>The ring type is undefined. Corresponds to a model validation error.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PurelyReflexive">
				<xs:annotation>
					<xs:documentation>Each instance plays itself and cannot play another instance.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Irreflexive">
				<xs:annotation>
					<xs:documentation>No instance can play itself.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Acyclic">
				<xs:annotation>
					<xs:documentation>Cycles are not allowed.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Intransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B and instance B plays instance C, then instance A cannot play instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Symmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then intance B plays instance A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Asymmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then instance B cannot play instance A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Antisymmetric">
				<xs:annotation>
					<xs:documentation>If instance A is not equal to instance B and A plays B, then B cannot play A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AcyclicIntransitive">
				<xs:annotation>
					<xs:documentation>Cycles are not allowed; and if instance A plays instance B and instance B plays instance C, then instance A cannot play instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SymmetricIrreflexive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then intance B plays instance A. No instance can play itself.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SymmetricIntransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then intance B plays instance A. If instance A plays instance B and instance B plays instance C, then instance A cannot play instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AsymmetricIntransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then instance B cannot play instance A. If instance A plays instance B and instance B plays instance C, then instance A cannot play instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--End Set constraints-->
	<!--InternalConstraint -->
	<xs:complexType name="InternalConstraintsType">
		<xs:annotation>
			<xs:documentation>Container for references to set constraints that are internal to a fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="UniquenessConstraint" type="UniquenessConstraintRef"/>
			<xs:element name="MandatoryConstraint" type="MandatoryConstraintRef"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="UniquenessConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--End InternalConstraint-->
	<!--End Constraints-->
	<!--Fact Readings and reading Orders-->
	<xs:complexType name="ReadingRef">
		<xs:annotation>
			<xs:documentation>A reference to a predicate reading.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ReadingOrdersType">
		<xs:annotation>
			<xs:documentation>Container for reading orders.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="ReadingOrder" type="ReadingOrderType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReadingOrderType">
		<xs:annotation>
			<xs:documentation>A sequence of roles from a single fact type representing representing a complete role traversal. Also called a predicate.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Readings" type="ReadingsType"/>
			<xs:element name="RoleSequence" type="ReadingRoleSequenceType"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ReadingsType">
		<xs:annotation>
			<xs:documentation>Container for readings corresponding to a reading order.</xs:documentation>
		</xs:annotation>
		<xs:sequence maxOccurs="unbounded">
			<xs:element name="Reading" type="ReadingType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReadingType">
		<xs:annotation>
			<xs:documentation>Predicate text corresponding to a specific role traversal.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Data" type="xs:string">
				<xs:annotation>
					<xs:documentation>Reading text with numbered replacemented fields in the format {n}, where n is a zero-based index into the corresponding role traversal order. n is also strictly increasing, so the first replacement field corresponds to the first role, etc. Reading text also includes hyphen-binding specifications, where 'WORD- ' (or ' -WORD') binds WORD and all intermediate words to the nearest right (left) placeholder.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<!--End Fact Readings and reading Orders-->
	<!-- Should Model errors be part of the core schema or in another namespace?-->
	<!--ModelErrors-->
	<xs:complexType name="ModelErrorsType">
		<xs:annotation>
			<xs:documentation>Container for all model validation errors.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ref="ExtensionModelError"/>
			<xs:element name="ConstraintDuplicateNameError" type="ConstraintDuplicateNameErrorType"/>
			<xs:element name="ObjectTypeDuplicateNameError" type="ObjectTypeDuplicateNameErrorType"/>
			<xs:element name="RecognizedPhraseDuplicateNameError" type="RecognizedPhraseDuplicateNameErrorType"/>
			<xs:element name="GroupDuplicateNameError" type="GroupDuplicateNameErrorType"/>
			<xs:element name="FunctionDuplicateNameError" type="FunctionDuplicateNameErrorType"/>
			<xs:element name="GroupMembershipContradictionError" type="GroupMembershipContradictionErrorType"/>
			<xs:element name="ExternalConstraintRoleSequenceArityMismatchError" type="ExternalConstraintRoleSequenceArityMismatchErrorType"/>
			<xs:element name="FactTypeRequiresInternalUniquenessConstraintError" type="FactTypeRequiresInternalUniquenessConstraintErrorType"/>
			<xs:element name="FactTypeRequiresReadingError" type="FactTypeRequiresReadingErrorType"/>
			<xs:element name="TooFewEntityTypeRoleInstancesError" type="TooFewEntityTypeRoleInstancesErrorType"/>
			<xs:element name="TooFewFactTypeRoleInstancesError" type="TooFewFactTypeRoleInstancesErrorType"/>
			<xs:element name="TooFewReadingRolesError" type="TooFewReadingRolesErrorType"/>
			<xs:element name="ReadingRequiresUserModificationError" type="ReadingRequiresUserModificationErrorType"/>
			<xs:element name="TooFewRoleSequencesError" type="TooFewRoleSequencesErrorType"/>
			<xs:element name="TooManyReadingRolesError" type="TooManyReadingRolesErrorType"/>
			<xs:element name="TooManyRoleSequencesError" type="TooManyRoleSequencesErrorType"/>
			<xs:element name="DataTypeNotSpecifiedError" type="DataTypeNotSpecifiedErrorType"/>
			<xs:element name="NMinusOneError" type="NMinusOneErrorType"/>
			<xs:element name="CompatibleRolePlayerTypeError" type="CompatibleRolePlayerTypeErrorType"/>
			<xs:element name="RolePlayerRequiredError" type="RolePlayerRequiredErrorType"/>
			<!-- UNDONE: Remove EqualityImpliedByMandatoryError when file format is officially updated -->
			<xs:element name="EqualityImpliedByMandatoryError" type="EqualityImpliedByMandatoryErrorType"/>
			<xs:element name="EntityTypeRequiresReferenceSchemeError" type="EntityTypeRequiresReferenceSchemeErrorType"/>
			<xs:element name="FrequencyConstraintMinMaxError" type="FrequencyConstraintMinMaxErrorType"/>
			<xs:element name="FrequencyConstraintExactlyOneError" type="FrequencyConstraintExactlyOneErrorType"/>
			<!-- UNDONE: Remove FrequencyConstraintContradictsInternalUniquenessConstraintError when file format is officially updated -->
			<xs:element name="FrequencyConstraintContradictsInternalUniquenessConstraintError" type="FrequencyConstraintContradictsInternalUniquenessConstraintErrorType"/>
			<xs:element name="FrequencyConstraintViolatedByUniquenessConstraintError" type="FrequencyConstraintViolatedByUniquenessConstraintErrorType"/>
			<xs:element name="MinValueMismatchError" type="MinValueMismatchErrorType"/>
			<xs:element name="MaxValueMismatchError" type="MaxValueMismatchErrorType"/>
			<xs:element name="ValueRangeOverlapError" type="ValueRangeOverlapErrorType"/>
			<xs:element name="ValueTypeDetachedError" type="ValueTypeDetachedErrorType"/>
			<xs:element name="RingConstraintTypeNotSpecifiedError" type="RingConstraintTypeNotSpecifiedErrorType"/>
			<xs:element name="ImplicationError" type="ImplicationErrorType"/>
			<xs:element name="SubsetConstraintImpliedByMandatoryConstraintsError" type="SubsetConstraintImpliedByMandatoryConstraintsErrorType"/>
			<xs:element name="EqualityConstraintImpliedByMandatoryConstraintsError" type="EqualityConstraintImpliedByMandatoryConstraintsErrorType"/>
			<xs:element name="ExclusionContradictsMandatoryError" type="ExclusionContradictsMandatoryErrorType"/>
			<xs:element name="NotWellModeledSubsetAndMandatoryError" type="NotWellModeledSubsetAndMandatoryErrorType"/>
			<xs:element name="ImpliedInternalUniquenessConstraintError" type="ImpliedInternalUniquenessConstraintErrorType"/>
			<!-- UNDONE: Remove ObjectTypeRequiresPrimarySupertypeError when file format is officially updated -->
			<xs:element name="ObjectTypeRequiresPrimarySupertypeError" type="ObjectTypeRequiresPrimarySupertypeErrorType"/>
			<xs:element name="PreferredIdentifierRequiresMandatoryError" type="PreferredIdentifierRequiresMandatoryErrorType"/>
			<xs:element name="CompatibleSupertypesError" type="CompatibleSupertypesErrorType"/>
			<xs:element name="ObjectifyingInstanceRequiredError" type="ObjectifyingInstanceRequiredErrorType"/>
			<xs:element name="ObjectifiedInstanceRequiredError" type="ObjectifiedInstanceRequiredErrorType"/>
			<xs:element name="CompatibleValueTypeInstanceValueError" type="CompatibleValueTypeInstanceValueErrorType"/>
			<xs:element name="PopulationMandatoryError" type="PopulationMandatoryErrorType"/>
			<xs:element name="PopulationUniquenessError" type="PopulationUniquenessErrorType"/>
			<xs:element name="ExclusionContradictsEqualityError" type="ExclusionContradictsEqualityErrorType"/>
			<xs:element name="ExclusionContradictsSubsetError" type="ExclusionContradictsSubsetErrorType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ModelError" abstract="true">
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Description of the model validation error.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="ExtensionModelError" type="ModelError" abstract="true">
		<xs:annotation>
			<xs:documentation>Extension point for model validation errors in extension models.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="ConstraintDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple constraints share the same name.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraints">
						<xs:annotation>
							<xs:documentation>Like-named constraints.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice minOccurs="2" maxOccurs="unbounded">
								<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
								<xs:element name="SetConstraint" type="SetConstraintRef"/>
								<xs:element name="ValueConstraint" type="ValueConstraintRef"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectTypeDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple object types share the same name.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Objects">
						<xs:annotation>
							<xs:documentation>Like-named object types.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="Object" type="ObjectTypeRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RecognizedPhraseDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple recognized phrases have the same text.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="RecognizedPhrases">
						<xs:annotation>
							<xs:documentation>Like-named phrases.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="RecognizedPhrase" type="RecognizedPhraseRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FunctionDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple functions have the same name.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Functions">
						<xs:annotation>
							<xs:documentation>Like-named functions.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="Function" type="FunctionRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EntityTypeRequiresReferenceSchemeErrorType">
		<xs:annotation>
			<xs:documentation>An entity type requires a reference scheme or a supertype that provides a preferred identification path.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="EntityType" type="ObjectTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ExternalConstraintRoleSequenceArityMismatchErrorType">
		<xs:annotation>
			<xs:documentation>A SetComparisonConstraint has an inconsistent number of columns.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraint" type="SetComparisonConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FactTypeRequiresInternalUniquenessConstraintErrorType">
		<xs:annotation>
			<xs:documentation>A ground fact type does not have at least on internal uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Fact" type="FactTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FactTypeRequiresReadingErrorType">
		<xs:annotation>
			<xs:documentation>A predicate reading has not been specified for a fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Fact" type="FactTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooFewReadingRolesErrorType">
		<xs:annotation>
			<xs:documentation>Reading text has more placeholders than the fact type has roles.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Reading" type="ReadingRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ReadingRequiresUserModificationErrorType">
		<xs:annotation>
			<xs:documentation>A reading has been automatically modified and must be edited by the user to restore its meaning.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:choice>
						<xs:element name="Reading" type="ReadingRef"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooFewRoleSequencesErrorType">
		<xs:annotation>
			<xs:documentation>An external constraint requires multiple roles (SetConstraint) or multiple role sequences (SetComparisonConstraint).</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:choice>
						<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
						<xs:element name="SetConstraint" type="SetConstraintRef"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooFewEntityTypeRoleInstancesErrorType">
		<xs:annotation>
			<xs:documentation>An entity instance is missing instance associations for some of the roles in its preferred identifier.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="EntityTypeInstance" type="EntityTypeInstanceRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooFewFactTypeRoleInstancesErrorType">
		<xs:annotation>
			<xs:documentation>A fact instance is missing instance associations for some roles in the fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="FactTypeInstance" type="FactTypeInstanceRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooManyReadingRolesErrorType">
		<xs:annotation>
			<xs:documentation>Reading text does not have enough placeholders for all roles.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Reading" type="ReadingRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DataTypeNotSpecifiedErrorType">
		<xs:annotation>
			<xs:documentation>A value type is using the unspecified data type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ConceptualDataType" type="DataTypeRefRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintMinMaxErrorType">
		<xs:annotation>
			<xs:documentation>A frequency constraints maximum values is less that its minimum value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintExactlyOneErrorType">
		<xs:annotation>
			<xs:documentation>A frequency constraint with a minimum and maximum range of 1 should be represented by a uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- UNDONE: Remove FrequencyConstraintContradictsInternalUniquenessConstraintErrorType when file format is officially updated -->
	<xs:complexType name="FrequencyConstraintContradictsInternalUniquenessConstraintErrorType">
		<xs:annotation>
			<xs:documentation>(Deprecated by FrequencyConstraintViolatedByUniquenessConstraintErrorType) A frequency constraint requires more role players than are allowed by an internal uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:all>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
					<xs:element name="Fact" type="FactTypeRef"/>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintViolatedByUniquenessConstraintErrorType">
		<xs:annotation>
			<xs:documentation>A frequency constraint covers the same roles as a uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:all>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MaxValueMismatchErrorType">
		<xs:annotation>
			<xs:documentation>The maximum value of a value range cannot be interpreted as the specified data type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueRange" type="ValueRangeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MinValueMismatchErrorType">
		<xs:annotation>
			<xs:documentation>The minimum value of a value range cannot be interpreted as the specified data type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueRange" type="ValueRangeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ValueRangeOverlapErrorType">
		<xs:annotation>
			<xs:documentation>Two value ranges for the same value constraint have overlapping ranges.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueConstraint" type="ValueConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ValueTypeDetachedErrorType">
		<xs:annotation>
			<xs:documentation>A role value constraint is specified for a role that is no longer associated with a value type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueConstraint" type="ValueConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ImpliedInternalUniquenessConstraintErrorType">
		<xs:annotation>
			<xs:documentation>One or more internal uniqueness constraints in a fact type are implied by other internal uniqueness constraints on the same fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Fact" type="FactTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- UNDONE: Remove ObjectTypeRequiresPrimarySupertypeError when file format is officially updated -->
	<xs:complexType name="ObjectTypeRequiresPrimarySupertypeErrorType">
		<xs:annotation>
			<xs:documentation>Deprecated along with SubtypeFact.IsPrimary property</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ObjectType" type="ObjectTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PreferredIdentifierRequiresMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>The roles opposite a preferred identifier must have at least one mandatory constraint that covers a subset of the opposite roles.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ObjectType" type="ObjectTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompatibleSupertypesErrorType">
		<xs:annotation>
			<xs:documentation>Multiple supertypes are specified that do not share a common ancestor, or a supertype is specified that is implied by other supertypes.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ObjectType" type="ObjectTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RingConstraintTypeNotSpecifiedErrorType">
		<xs:annotation>
			<xs:documentation>The type of a ring constraint is not specified.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="RingConstraint" type="RingConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="ImplicationErrorType">
		<xs:annotation>
			<xs:documentation>A constraint is implied by another constraint in the model.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:choice>
						<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
						<xs:element name="SetConstraint" type="SetConstraintRef"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="ExclusionContradictsMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>Exclusion and mandatory constraints defined on intersecting roles contradict.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
					<xs:sequence>
						<xs:element name="Constraints">
							<xs:annotation>
								<xs:documentation>The contradictory constraints.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:choice minOccurs="2" maxOccurs="unbounded">
									<xs:element name="MandatoryConstraint" type="MandatoryConstraintRef"/>
									<xs:element name="ExclusionConstraint" type="SetComparisonConstraintRef"/>
								</xs:choice>
							</xs:complexType>
						</xs:element>
					</xs:sequence>				
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="NotWellModeledSubsetAndMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>Subset and mandatory constraints on intersecting roles are incorrectly modeled.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraints">
						<xs:annotation>
							<xs:documentation>Conflicting constraints.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:all>
								<xs:element name="MandatoryConstraint" type="MandatoryConstraintRef"/>
								<xs:element name="SubsetConstraint" type="SetComparisonConstraintRef"/>
							</xs:all>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="SubsetConstraintImpliedByMandatoryConstraintsErrorType">
		<xs:annotation>
			<xs:documentation>A subset constraint is implied by one or more mandatory constraints.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
				<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="SubsetConstraint" type="SetComparisonConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="EqualityConstraintImpliedByMandatoryConstraintsErrorType">
		<xs:annotation>
			<xs:documentation>An equality constraint is implied by one or more mandatory constraints.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="EqualityConstraint" type="SetComparisonConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="ExclusionContradictsSubsetErrorType">
		<xs:annotation>
			<xs:documentation>Exclusion and subset constraints defined on intersecting roles contradict.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraints">
						<xs:annotation>
							<xs:documentation>The contradictory constraints.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice maxOccurs="unbounded">
								<xs:element name="ExclusionConstraintThatContradictsWithSubset" type="SetComparisonConstraintRef" minOccurs="1"/>
								<xs:element name="SubsetConstraint" type="SetComparisonConstraintRef" minOccurs="1"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="ExclusionContradictsEqualityErrorType">
		<xs:annotation>
			<xs:documentation>Exclusion and equality constraints defined on intersecting roles contradict.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraints">
						<xs:annotation>
							<xs:documentation>The contradictory constraints.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice maxOccurs="unbounded">
								<xs:element name="ExclusionConstraintThatContradictsWithEquality" type="SetComparisonConstraintRef" minOccurs="1"/>
								<xs:element name="EqualityConstraint" type="SetComparisonConstraintRef" minOccurs="1"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="TooManyRoleSequencesErrorType">
		<xs:annotation>
			<xs:documentation>A SetConstraint has too many roles for the constraint type, or a SetComparisonConstraint has too many role sequences.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:choice>
						<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
						<xs:element name="SetConstraint" type="SetConstraintRef"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompatibleRolePlayerTypeErrorType">
		<xs:annotation>
			<xs:documentation>The roles in a SetConstraint or a column of a SetComparisonConstraint have incompatible role players.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
					<xs:element name="SetConstraint" type="SetConstraintRef"/>
				</xs:choice>
				<xs:attribute name="Column" type="xs:int" use="optional">
					<xs:annotation>
						<xs:documentation>The zero-based column with incompatible types (specified with a SetComparisonConstraint).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RolePlayerRequiredErrorType">
		<xs:annotation>
			<xs:documentation>A role must have a specified role player.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="Role" type="RoleRef"/>
				</xs:choice>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<!-- UNDONE: Remove EqualityImpliedByMandatoryError when file format is officially updated -->
	<xs:complexType name="EqualityImpliedByMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>An equality constraint is implied by a mandatory constraint (deprecated, replaced by EqualityConstraintImpliedByMandatoryConstraintsError).</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="EqualityConstraint" type="EqualityConstraintRef"/>
				</xs:choice>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NMinusOneErrorType">
		<xs:annotation>
			<xs:documentation>An internal uniqueness constraint must span at least n minus one roles, where n is the number of roles in the fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="UniquenessConstraint" type="UniquenessConstraintRef"/>
				</xs:sequence>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompatibleValueTypeInstanceValueErrorType">
		<xs:annotation>
			<xs:documentation>The value of an instance is not compatible with the data type of the corresponding value type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueTypeInstance" type="ValueTypeInstanceRef"/>
				</xs:sequence>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PopulationMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>The role player of the roles in a mandatory constraint has an instance that is not used by any of the roles.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:all>
					<xs:element name="ObjectTypeInstance" type="ObjectTypeInstanceRef"/>
					<xs:element name="MandatoryConstraint" type="MandatoryConstraintRef"/>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PopulationUniquenessErrorType">
		<xs:annotation>
			<xs:documentation>An instance is used twice by a role with a single-column uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="RoleInstances">
						<xs:annotation>
							<xs:documentation>Conflicting role instances.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice minOccurs="2" maxOccurs="unbounded">
								<xs:element name="FactTypeRoleInstance" type="ObjectTypeRoleInstanceRef"/>
								<xs:element name="EntityTypeRoleInstance" type="ObjectTypeRoleInstanceRef"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectifyingInstanceRequiredErrorType">
		<xs:annotation>
			<xs:documentation>An instance of an objectified fact type does not have an associated instance for the objectifying entity type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="FactTypeInstance" type="FactTypeInstanceRef"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectifiedInstanceRequiredErrorType">
		<xs:annotation>
			<xs:documentation>An instance an objectifying entity does not have an associated instance for the objectifed fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="EntityTypeInstance" type="EntityTypeInstanceRef"/>
					<xs:element name="EntityTypeSubtypeInstance" type="EntityTypeSubtypeInstanceRef"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--End ModelErrors-->
	<!--Custom Reference Modes-->
	<!--Reference Modes and Kinds-->
	<xs:complexType name="ReferenceModeKindsType">
		<xs:annotation>
			<xs:documentation>Container for the reference mode kinds.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element maxOccurs="unbounded" name="ReferenceModeKind" type="ReferenceModeKindType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReferenceModeKindRef">
		<xs:annotation>
			<xs:documentation>A reference to a reference mode kind.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ReferenceModeKindType">
		<xs:annotation>
			<xs:documentation>Setting for a specific kind of reference mode pattern.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="FormatString" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>A string with replacement fields representing a custom format for a value type name based on the entity type name (replacement field {0}) and reference mode name (replacement field {1}). Given an entity type name and a value type name, reference mode FormatStrings are used to determine the associated reference mode and reference mode kind.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ReferenceModeType" type="ReferenceModeKindValues" use="required"/>
	</xs:complexType>
	<xs:simpleType name="ReferenceModeKindValues">
		<xs:annotation>
			<xs:documentation>Classification of reference mode patterns.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="General">
				<xs:annotation>
					<xs:documentation>The reference mode patterns resolves to a value type with no special semantics.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Popular">
				<xs:annotation>
					<xs:documentation>The reference mode patterns resolves to a value type with a name based on the identified entity type. The value type identifies exactly one entity type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="UnitBased">
				<xs:annotation>
					<xs:documentation>The reference mode patterns resolves to a value type that is associated with a measurable unit.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ValueRangeRef">
		<xs:annotation>
			<xs:documentation>A reference to a value range.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--Reference Mdoes and Kinds-->
	<xs:complexType name="CustomReferenceModesType">
		<xs:annotation>
			<xs:documentation>Container for custom reference mode pattern definitions.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="CustomReferenceMode" type="CustomReferenceModeType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CustomReferenceModeType">
		<xs:annotation>
			<xs:documentation>Definition of a custom reference mode pattern.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="CustomFormatString" type="xs:string">
				<xs:annotation>
					<xs:documentation>A string with replacement fields representing a custom format for a value type name based on the entity type name (replacement field {0}) and reference mode name (replacement field {1}). If not specified, defaults to the ReferenceModeKind FormatString attribute.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Kind" type="ReferenceModeKindRef"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The reference mode name.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--End Custom Reference Modes-->
	<xs:complexType name="ValueTypeValueRestrictionType">
		<xs:annotation>
			<xs:documentation>Restrict the values allowed for any instance of the containing value type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ValueConstraint" type="ValueConstraintType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ValueConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint limiting the set of allowed values.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="ValueRanges" type="ValueRangesType"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The constraint name. Validation errors will be present for any constraint name that is not unique within the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="RoleValueRestrictionType">
		<xs:annotation>
			<xs:documentation>Restrict the values allowed for role players associated with this role.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleValueConstraint" type="ValueConstraintType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ValueRangesType">
		<xs:annotation>
			<xs:documentation>Container for value ranges. A value instance must be contained in the union of these ranges.</xs:documentation>
		</xs:annotation>
		<xs:sequence maxOccurs="unbounded">
			<xs:element name="ValueRange" type="ValueRangeType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="RangeInclusionValues">
		<xs:annotation>
			<xs:documentation>Specify whether the endpoint of a range is included in the range.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="NotSet">
				<xs:annotation>
					<xs:documentation>Inclusion not explicitly set.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Open">
				<xs:annotation>
					<xs:documentation>The endpoint is not included in the range of values.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Closed">
				<xs:annotation>
					<xs:documentation>The endpoint is included in the range of values.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ValueRangeType">
		<xs:annotation>
			<xs:documentation>A simple value range.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="MinValue" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The lower bound for the range.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxValue" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The upper bound of the range. Duplicate of the MinValue for a single value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MinInclusion" type="RangeInclusionValues" default="NotSet">
			<xs:annotation>
				<xs:documentation>Does the range include the lower bound?</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxInclusion" type="RangeInclusionValues" default="NotSet">
			<xs:annotation>
				<xs:documentation>Does the range include the upper bound?</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="ConstraintModalityValues">
		<xs:annotation>
			<xs:documentation>The strength of a constraint.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Alethic">
				<xs:annotation>
					<xs:documentation>A strong constraint that is enforced by the structure of a generated system.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Deontic">
				<xs:annotation>
					<xs:documentation>A weak constraint that should not be violated. Instances violating a deontic constraint can be structurally stored in a generated system.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:element name="NameGenerator" type="NameGeneratorType"/>
	<xs:complexType name="NameGeneratorType">
		<xs:annotation>
			<xs:documentation>Name generation settings</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
			<xs:element name="Refinements" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Container specifying additional name generator instances that provide settings for a more specific use of the generated names.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element ref="NameGenerator" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="CasingOption" default="None">
			<xs:annotation>
				<xs:documentation>Specify casing modifications for name parts and combinations.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="None">
						<xs:annotation>
							<xs:documentation>No casing options specified.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Camel">
						<xs:annotation>
							<xs:documentation>Generate names using camel casing (first letter of first word lower case, first letter of subsequent words upper case).</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Pascal">
						<xs:annotation>
							<xs:documentation>Generate names using Pascal casing (first letter of all words upper case).</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Upper">
						<xs:annotation>
							<xs:documentation>Generate names using all upper case letters.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Lower">
						<xs:annotation>
							<xs:documentation>Generate names using all lower case letters.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="SpacingFormat" default="Retain">
			<xs:annotation>
				<xs:documentation>Specify how name spaces are treated during name generation.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="Retain">
						<xs:annotation>
							<xs:documentation>Keep any spaces specified in names used in the ORM model.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Remove">
						<xs:annotation>
							<xs:documentation>Generate names using all upper case letters.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ReplaceWith">
						<xs:annotation>
							<xs:documentation>Replace one or more spaces in model names with the character specified in the SpacingReplacement attribute.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="SpacingReplacement" default="" type="xs:string">
			<xs:annotation>
				<xs:documentation>The string used in place of spaces when the SpacingFormat attribute is ReplaceWith</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="NameUsage" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>The usage associated with this Name Generator</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="AutomaticallyShortenNames" default="true" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Whether the namegeneration system should automatically shorten names if they exceed the max length</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="UserDefinedMaximum" default="128" type="xs:integer">
			<xs:annotation>
				<xs:documentation>The maximum name length set by user</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="UseTargetDefaultMaximum" default="true" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>The maximum name length set by user</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RecognizedPhrasesType">
		<xs:annotation>
			<xs:documentation>Container for recognized phrases.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RecognizedPhrase" type="RecognizedPhraseType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RecognizedPhraseType">
		<xs:annotation>
			<xs:documentation>A phrase with one or more words that can be abbreviated during name generation.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Abbreviations" type="AliasesType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>A recognized word or phrase to map to a different text value during name generation. Generally a common word such as 'has' or 'the'. Allows mapping to an empty alias value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="RecognizedPhraseRef">
		<xs:annotation>
			<xs:documentation>A reference to a recognized phrase.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:element name="GenerationState" type="GenerationStateType"/>
	<xs:complexType name="GenerationStateType">
		<xs:annotation>
			<xs:documentation>State information relating to automatic mapping algorithms.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="GenerationSettings" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Container for extension-defined data relating to how elements were generated from the ORM model.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence minOccurs="0" maxOccurs="unbounded">
						<xs:element ref="GenerationSetting"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:element name="GenerationSetting" type="GenerationSettingType" abstract="true"/>
	<xs:complexType name="GenerationSettingType">
		<xs:annotation>
			<xs:documentation>A generation setting representing the extension-defined algorithm used to generate elements from the ORM elements.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:element name="Grouping" type="GroupingType"/>
	<xs:complexType name="GroupingType">
		<xs:annotation>
			<xs:documentation>User-defined and rule-based element groupings.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ORMModel" type="ORMModelRef">
				<xs:annotation>
					<xs:documentation>The ORMModel element associated with these groups.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Groups" type="GroupsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="GroupsType">
		<xs:annotation>
			<xs:documentation>Container for Group elements.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Group" type="GroupType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="GroupRef">
		<xs:annotation>
			<xs:documentation>A reference to a group</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="GroupType">
		<xs:annotation>
			<xs:documentation>References to set of related elements.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="GroupTypes" type="GroupTypesType" minOccurs="0"/>
			<xs:element name="Elements" type="GroupElementsType" minOccurs="0"/>
			<xs:element name="NestedGroups" type="NestedGroupsType" minOccurs="0"/>
		</xs:all>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" use="required" type="xs:string">
			<xs:annotation>
				<xs:documentation>The group name. Validation errors will be present for any object type name that is not unique within the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Priority" default="0" type="xs:int">
			<xs:annotation>
				<xs:documentation>The priority of this group, used to determine precedence if the same element is included in more than one group with the same group type. Higher numbers have higher priority.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="TypeCompliance" default="NotExcluded">
			<xs:annotation>
				<xs:documentation>Determine how strictly group types control the group contents.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="NotExcluded">
						<xs:annotation>
							<xs:documentation>Allow any element that is not explicitly blocked by a group type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="PartiallyApproved">
						<xs:annotation>
							<xs:documentation>At least one associated group type recognizes the element.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="FullyApproved">
						<xs:annotation>
							<xs:documentation>All associated group types recognize the element.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="GroupTypesType">
		<xs:annotation>
			<xs:documentation>Container for group types.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="GroupType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="GroupTypeType">
		<xs:annotation>
			<xs:documentation>Extension point for an instance of a group type, which associates meaning with elements contained in a group.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:element name="GroupType" type="GroupTypeType" abstract="true"/>
	<xs:complexType name="GroupElementsType">
		<xs:annotation>
			<xs:documentation>Container for elements associated with a group.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="IncludedElement" type="ElementRef">
				<xs:annotation>
					<xs:documentation>A reference to an element included in this group.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ExcludedElement" type="ElementRef">
				<xs:annotation>
					<xs:documentation>A reference to an element automatically included in this group by a group type but explicitly excluded from the group by the user.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ElementRef">
		<xs:annotation>
			<xs:documentation>A reference to any directly identified element.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="NestedGroupsType">
		<xs:annotation>
			<xs:documentation>Container for groups whose elements are included or excluded from the containing group.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="IncludedGroup" type="GroupRef">
				<xs:annotation>
					<xs:documentation>All included elements from the referenced group are included in the containing group.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ExcludedGroup" type="GroupRef">
				<xs:annotation>
					<xs:documentation>All included elements from the referenced group are excluded from the containing group.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="GroupDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple groups share the same name.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Groups">
						<xs:annotation>
							<xs:documentation>Link-named groups.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="Group" type="GroupRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GroupMembershipContradictionErrorType">
		<xs:annotation>
			<xs:documentation>A group member is required by one group type and blocked by another group type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:all>
					<xs:element name="Group">
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="GroupRef">
									<xs:sequence>
										<xs:element name="Element" type="ElementRef">
											<xs:annotation>
												<xs:documentation>A reference to the conflicting element.</xs:documentation>
											</xs:annotation>
										</xs:element>
									</xs:sequence>
									<xs:attributeGroup ref="idAttribute"/>
								</xs:extension>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="DynamicColor" type="DynamicColorType" abstract="true"/>
	<xs:complexType name="DynamicColorType">
		<xs:annotation>
			<xs:documentation>Dynamic color information used by extension models with shape representations.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="ColorRole" type="xs:token">
			<xs:annotation>
				<xs:documentation>The name of a role indicating use of the color. Correspond to an item in a color set enum.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ColorValue" type="xs:string">
			<xs:annotation>
				<xs:documentation>The name of the color played by this role.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
</xs:schema>
