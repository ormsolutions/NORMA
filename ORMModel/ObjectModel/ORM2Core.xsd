<?xml version="1.0" encoding="utf-8"?>
<!-- Todo: Is external on object type?  What am I supposed to do with object shapes and data types? -->
<xs:schema targetNamespace="http://schemas.neumont.edu/ORM/2006-04/ORMCore" 
	elementFormDefault="qualified" attributeFormDefault="unqualified" 
	xmlns="http://schemas.neumont.edu/ORM/2006-04/ORMCore"
	xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:annotation>
		<xs:appinfo source="zlib/libpng License Copyright Notice">
			Copyright © Neumont University. All rights reserved.
			Copyright © ORM Solutions, LLC. All rights reserved.

			This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
			Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
			1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
			2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
			3. This notice may not be removed or altered from any source distribution.
		</xs:appinfo>
	</xs:annotation>
	<xs:complexType name="ExtensionsType">
		<xs:annotation>
			<xs:documentation>Standard container for extension data related to the containing element.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:any namespace="##other" processContents="strict"/>
		</xs:sequence>
	</xs:complexType>
	<xs:element name="ORMModel" type="ORMModelType"/>
	<xs:complexType name="ORMModelType">
		<xs:annotation>
			<xs:documentation>Definition of elements used in the primary definition of an ORM model.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="Objects" type="ObjectTypesType" minOccurs="0"/>
			<xs:element name="Facts" type="FactTypesType" minOccurs="0"/>
			<xs:element name="Constraints" type="ConstraintsType" minOccurs="0"/>
			<xs:element name="DataTypes" type="DataTypesType" minOccurs="0"/>
			<xs:element name="Functions" type="FunctionsType" minOccurs="0"/>
			<xs:element name="CustomReferenceModes" type="CustomReferenceModesType" minOccurs="0"/>
			<xs:element name="ModelNotes" type="ModelNotesType" minOccurs="0"/>
			<xs:element name="ModelErrors" type="ModelErrorsType" minOccurs="0"/>
			<xs:element name="ReferenceModeKinds" type="ReferenceModeKindsType" minOccurs="0"/>
			<xs:element name="RecognizedPhrases" type="RecognizedPhrasesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:all>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The name of the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:attributeGroup name="idAttribute">
		<xs:attribute name="id" type="xs:ID" use="required">
			<xs:annotation>
				<xs:documentation>A unique identifier for this element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="idAttributeOptional">
		<xs:attribute name="id" type="xs:ID">
			<xs:annotation>
				<xs:documentation>A unique identifier for this element.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:attributeGroup name="refAttribute">
		<xs:attribute name="ref" type="xs:IDREF" use="required">
			<xs:annotation>
				<xs:documentation>The value of the referenced element's unique id.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:attributeGroup>
	<xs:complexType name="ORMModelRef">
		<xs:annotation>
			<xs:documentation>Reference to an ORM model element.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--End ORMModel-->
	<xs:element name="ModelErrorDisplayFilter" type="ModelErrorDisplayFilterType"/>
	<xs:complexType name="ModelErrorDisplayFilterType">
		<xs:annotation>
			<xs:documentation>Validation error display filters based on error type and category.</xs:documentation>
		</xs:annotation>
		<!-- UNDONE: Temporary to pass XSD validation -->
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:any namespace="##any" processContents="skip"/>
		</xs:choice>
		<xs:anyAttribute namespace="##any" processContents="skip"/>
	</xs:complexType>
	<xs:complexType name="DefinitionsType">
		<xs:annotation>
			<xs:documentation>The container for informal description elements.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="Definition" type="DefinitionType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DefinitionType">
		<xs:annotation>
			<xs:documentation>An informal description for the containing element.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Text" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Plain text description.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="AliasesType">
		<xs:annotation>
			<xs:documentation>Alternative names for the containing named element.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Alias" type="AliasType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="AliasType">
		<xs:annotation>
			<xs:documentation>An alternative name for the containing named element</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element minOccurs="0" name="RefinedInstance" type="RefinedInstanceType"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The alternative name</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="NameConsumer" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The type of consumer for this form of the name. NameConsumer types are provided by extension models.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="NameUsage" type="xs:string">
			<xs:annotation>
				<xs:documentation>Additional extension-provided categorization type for how a name should be used.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RefinedInstanceType">
		<xs:annotation>
			<xs:documentation>Bind an Alias or NameGenerator to a specific generated instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:element name="RefinesGeneratedInstance" type="RefinedInstanceType" abstract="true"/>
	<xs:complexType name="NotesType">
		<xs:annotation>
			<xs:documentation>The container for note elements.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="Note" type="NoteType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="NoteType">
		<xs:annotation>
			<xs:documentation>A note for the containing element.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Text" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Plain text note.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ModelNotesType">
		<xs:annotation>
			<xs:documentation>Container for miscellaneous notest associated with this model.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="ModelNote" type="ModelNoteType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ModelNoteType">
		<xs:annotation>
			<xs:documentation>A miscellaneous note for this model.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="NoteType">
				<xs:sequence minOccurs="0">
					<xs:element name="ReferencedBy" type="ModelNoteReferencedByType"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ModelNoteReferencedByType">
		<xs:annotation>
			<xs:documentation>A reference from a model note indicating a related element discussed by the note.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="FactType" type="FactTypeRef"/>
			<xs:element name="ObjectType" type="ObjectTypeRef"/>
			<xs:element name="SetConstraint" type="SetConstraintRef"/>
			<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
		</xs:choice>
	</xs:complexType>
	<!--Objects and Object Types-->
	<xs:complexType name="ObjectTypeRef">
		<xs:annotation>
			<xs:documentation>A reference to an object type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ObjectTypesType">
		<xs:annotation>
			<xs:documentation>Container for all object types in the model.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="EntityType" type="EntityTypeType"/>
			<xs:element name="ObjectifiedType" type="ObjectifiedTypeType"/>
			<xs:element name="ValueType" type="ValueTypeType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ObjectTypeType" abstract="true">
		<xs:sequence>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="Abbreviations" type="AliasesType" minOccurs="0"/>
			<xs:element name="CardinalityRestriction" type="ObjectTypeCardinalityRestrictionType" minOccurs="0"/>
			<xs:element name="PlayedRoles" type="PlayedRolesType" minOccurs="0"/>
			<xs:element name="SubtypeDerivationRule" type="SubtypeDerivationRuleType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Name" use="required" type="xs:string">
			<xs:annotation>
				<xs:documentation>The object type name. Validation errors will be present for any object type name that is not unique within the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="IsIndependent" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>An instance of this object type can exist without playing any non-identifying roles.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="IsExternal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This object type is externally defined (not used).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="IsPersonal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This object type refers to a person, not a thing. A directive to tell the verbalization to use personal pronouns.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="EntityTypeType">
		<xs:annotation>
			<xs:documentation>An object type with an external identification scheme.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ObjectTypeType">
				<xs:sequence>
					<xs:element name="PreferredIdentifier" type="UniquenessConstraintRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A reference to the uniqueness constraint that provides the preferred identification scheme for this entity type.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Instances" type="EntityTypeInstancesType" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<!--ReferenceMode is derived.-->
				<xs:attribute name="_ReferenceMode" type="xs:string">
					<xs:annotation>
						<xs:documentation>The name of the reference mode pattern used to identify this element. Derived from a single-role preferred identifier with a ValueType role player.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--The fact that an object is an ObjectifiedType is derrived.-->
	<xs:complexType name="ObjectifiedTypeType">
		<xs:annotation>
			<xs:documentation>An entity type that objectifies a fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ObjectTypeType">
				<xs:sequence>
					<xs:element name="PreferredIdentifier" type="UniquenessConstraintRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A reference to the uniqueness constraint that provides the preferred identification scheme for this entity type.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="NestedPredicate" type="ObjectifiedFactTypeRef"/>
					<xs:element name="Instances" type="EntityTypeInstancesType" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<!--ReferenceMode is derived.-->
				<xs:attribute name="_ReferenceMode" type="xs:string">
					<xs:annotation>
						<xs:documentation>The name of the reference mode pattern used to identify this element. Derived from a single-role preferred identifier with a ValueType role player.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--The fact that an object is a valuetype is derrived-->
	<xs:complexType name="ValueTypeType">
		<xs:annotation>
			<xs:documentation>An object type representing a self-identifying value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ObjectTypeType">
				<xs:sequence>
					<xs:element name="ConceptualDataType" type="DataTypeRef"/>
					<xs:element name="ValueRestriction" type="ValueTypeValueRestrictionType" minOccurs="0"/>
					<xs:element name="Instances" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Container for instances of this value type.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="ValueTypeInstance" type="ValueTypeInstanceType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="IsImplicitBooleanValue" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>True if this is an implied boolean value type. The implied boolean values are automatically created to provide a binarized form of a unary fact type.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SubtypeDerivationRuleType">
		<xs:annotation>
			<xs:documentation>The formal derivation rule defining a subtype.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SubtypeDerivationExpression" type="DerivationExpressionType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>(Deprecated) A derivation expression. Use SubtypeDerivationPath/InformalRule/DerivationNote instead.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SubtypeDerivationPath" type="SubtypeDerivationPathType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--End Objects and Object Types-->
	<!--ObjectTypeInstances-->
	<xs:complexType name="ObjectTypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to an object type instance. An object type instance may be a value instance, an entity instance, or a subtype instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeInstancesType">
		<xs:annotation>
			<xs:documentation>Container for instances associated with an entity type.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="EntityTypeInstance" type="EntityTypeInstanceType" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="EntityTypeSubtypeInstance" type="EntityTypeSubtypeInstanceType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="EntityTypeInstanceType">
		<xs:annotation>
			<xs:documentation>An instance of a directly identified entity type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleInstances" type="EntityTypeRoleInstancesType" minOccurs="0"/>
			<xs:element name="ObjectifiedInstance" type="FactTypeInstanceRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A reference to the fact instance associated with this entity instance.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeSubtypeInstanceType">
		<xs:annotation>
			<xs:documentation>An instance of a subtype instance defined as a relationship to an instance of the identifying supertype.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SupertypeInstance" type="EntityTypeInstanceRef" minOccurs="0"/>
			<xs:element name="ObjectifiedInstance" type="FactTypeInstanceRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A reference to the fact instance associated with this subtype instance.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to an entity type instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeSubtypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to an entity type subtype instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="EntityTypeRoleInstancesType">
		<xs:annotation>
			<xs:documentation>Container for the role instances associated with an entity instance.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="EntityTypeRoleInstance" type="ObjectTypeRoleInstanceRef" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ObjectTypeRoleInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to a role instance, which is a use of an object instance by a role in a single entity instance or fact instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ValueTypeInstanceType">
		<xs:annotation>
			<xs:documentation>Value instance. All other instance specifications are ultimately combinations of value instances.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="Value" type="xs:string">
				<xs:annotation>
					<xs:documentation>The text form of an instance value.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="InvariantValue" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A culture-invariant form of the instance value. This will not be set for data types with data that is not culture dependent.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:all>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ValueTypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to a value instance</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RoleInstancesType">
		<xs:annotation>
			<xs:documentation>Container for relationships between instances of the role player and roles used in other complex instance definitions.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="EntityTypeRoleInstance" type="RoleInstanceType"/>
			<xs:element name="ValueTypeRoleInstance" type="RoleInstanceType"/>
			<xs:element name="FactTypeRoleInstance" type="RoleInstanceType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="RoleInstanceType">
		<xs:annotation>
			<xs:documentation>An identified reference to an object type instance. An object type instance may be a value instance, an entity instance, or a subtype instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeInstancesType">
		<xs:annotation>
			<xs:documentation>Container for instances associated with a fact type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="FactTypeInstance" type="FactTypeInstanceType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FactTypeInstanceType">
		<xs:annotation>
			<xs:documentation>A fact instance defined by a population of the fact roles.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleInstances" type="FactTypeRoleInstancesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeInstanceRef">
		<xs:annotation>
			<xs:documentation>A reference to a fact instance.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeRoleInstancesType">
		<xs:annotation>
			<xs:documentation>Container for the role instances associated with a fact instance.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="FactTypeRoleInstance" type="ObjectTypeRoleInstanceRef" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--end ObjectTypeInstances-->
	<!--DataType -->
	<!--DataTypeRef indicates a reference to a datatype -->
	<xs:complexType name="DataTypeRef">
		<xs:annotation>
			<xs:documentation>A use of a data type, including facet information.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttributeOptional"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="Scale" type="xs:int">
			<xs:annotation>
				<xs:documentation>The value of the Scale facet.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Length" type="xs:int">
			<xs:annotation>
				<xs:documentation>The value of the Length facet. Holds the Precision fact for Decimal and Money data types.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DataTypeRefRef">
		<xs:annotation>
			<xs:documentation>A reference to the use of a data type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--end DataTypeRef-->
	<xs:complexType name="DataTypesType">
		<xs:annotation>
			<xs:documentation>Container for all data types used in the model.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="UnspecifiedDataType" type="UnspecifiedDataTypeType"/>
			<xs:element name="FixedLengthTextDataType" type="FixedLengthTextDataTypeType"/>
			<xs:element name="VariableLengthTextDataType" type="VariableLengthTextDataTypeType"/>
			<xs:element name="LargeLengthTextDataType" type="LargeLengthTextDataTypeType"/>
			<xs:element name="SignedIntegerNumericDataType" type="SignedIntegerNumericDataTypeType"/>
			<xs:element name="SignedSmallIntegerNumericDataType" type="SignedSmallIntegerNumericDataTypeType"/>
			<xs:element name="SignedLargeIntegerNumericDataType" type="SignedLargeIntegerNumericDataTypeType"/>
			<xs:element name="UnsignedIntegerNumericDataType" type="UnsignedIntegerNumericDataTypeType"/>
			<xs:element name="UnsignedTinyIntegerNumericDataType" type="UnsignedTinyIntegerNumericDataTypeType"/>
			<xs:element name="UnsignedSmallIntegerNumericDataType" type="UnsignedSmallIntegerNumericDataTypeType"/>
			<xs:element name="UnsignedLargeIntegerNumericDataType" type="UnsignedLargeIntegerNumericDataTypeType"/>
			<xs:element name="AutoCounterNumericDataType" type="AutoCounterNumericDataTypeType"/>
			<xs:element name="FloatingPointNumericDataType" type="FloatingPointNumericDataTypeType"/>
			<xs:element name="SinglePrecisionFloatingPointNumericDataType" type="SinglePrecisionFloatingPointNumericDataTypeType"/>
			<xs:element name="DoublePrecisionFloatingPointNumericDataType" type="DoublePrecisionFloatingPointNumericDataTypeType"/>
			<xs:element name="DecimalNumericDataType" type="DecimalNumericDataTypeType"/>
			<xs:element name="MoneyNumericDataType" type="MoneyNumericDataTypeType"/>
			<xs:element name="FixedLengthRawDataDataType" type="FixedLengthRawDataDataTypeType"/>
			<xs:element name="VariableLengthRawDataDataType" type="VariableLengthRawDataDataTypeType"/>
			<xs:element name="LargeLengthRawDataDataType" type="LargeLengthRawDataDataTypeType"/>
			<xs:element name="PictureRawDataDataType" type="PictureRawDataDataTypeType"/>
			<xs:element name="OleObjectRawDataDataType" type="OleObjectRawDataDataTypeType"/>
			<xs:element name="AutoTimestampTemporalDataType" type="AutoTimestampTemporalDataTypeType"/>
			<xs:element name="TimeTemporalDataType" type="TimeTemporalDataTypeType"/>
			<xs:element name="DateTemporalDataType" type="DateTemporalDataTypeType"/>
			<xs:element name="DateAndTimeTemporalDataType" type="DateAndTimeTemporalDataTypeType"/>
			<xs:element name="TrueOrFalseLogicalDataType" type="TrueOrFalseLogicalDataTypeType"/>
			<xs:element name="YesOrNoLogicalDataType" type="YesOrNoLogicalDataTypeType"/>
			<xs:element name="RowIdOtherDataType" type="RowIdOtherDataTypeType"/>
			<xs:element name="ObjectIdOtherDataType" type="ObjectIdOtherDataTypeType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="DataType" abstract="true">
		<xs:annotation>
			<xs:documentation>The base type for all data types</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:choice>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="UnspecifiedDataTypeType">
		<xs:annotation>
			<xs:documentation>Placeholder for an unspecified data type. Each use of this type results in a DataTypeNotSpecified model validation error.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FixedLengthTextDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of fixed length strings. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="VariableLengthTextDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of variable length strings. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LargeLengthTextDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of large length strings. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SignedIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 4-byte signed integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SignedSmallIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 2-byte signed integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SignedLargeIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 8-byte signed integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnsignedIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 4-byte unsigned integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnsignedTinyIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of unsigned byte integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnsignedSmallIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 2-byte unsigned integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UnsignedLargeIntegerNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 8-byte unsigned integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AutoCounterNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of automatically generated unsigned long integers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FloatingPointNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of floating point numbers. Supports the Precision facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SinglePrecisionFloatingPointNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 4-byte floating point numbers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DoublePrecisionFloatingPointNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of 8-byte floating point numbers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DecimalNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of moveable decimal point exact numbers. Supports the Precision and Scale facets.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MoneyNumericDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of moveable decimal point exact numbers. Supports the Precision and Scale facets.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FixedLengthRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of fixed length binary data. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="VariableLengthRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of variable length binary data. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LargeLengthRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of large length binary data. Supports the Length facet.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PictureRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of binary data representing an image.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="OleObjectRawDataDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of binary data representing an embedded OLE object.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="AutoTimestampTemporalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of automatically generated timestamps.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TimeTemporalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values represent time information.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DateTemporalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values represent date information.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DateAndTimeTemporalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values represent date and time information.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TrueOrFalseLogicalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are either true or false.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="YesOrNoLogicalDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are either yes or no.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RowIdOtherDataTypeType">
		<xs:annotation>
			<xs:documentation>Values are in the set of row identifiers.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectIdOtherDataTypeType">
		<xs:annotation>
			<xs:documentation>Values represent an object identifier.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DataType"/>
		</xs:complexContent>
	</xs:complexType>
	<!--End DataType -->
	<!--Roles-->
	<!-- RoleRef, RoleSequence and  RoleSequences define references to roles and collections of roles and collections of collections of roles-->
	<xs:complexType name="ConstraintRoleSequencesType">
		<xs:annotation>
			<xs:documentation>Container for constraint role sequences.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleSequence" type="ConstraintRoleSequenceWithJoinAndIdType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PlayedRolesType">
		<xs:annotation>
			<xs:documentation>Container for the roles played an entity type. Duplicates the RolePlayer information specified on the played roles.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Role" type="RoleRef"/>
			<xs:element name="SubtypeMetaRole" type="RoleRef"/>
			<xs:element name="SupertypeMetaRole" type="RoleRef"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ReadingRoleSequenceType">
		<xs:annotation>
			<xs:documentation>An order sequence of roles in a single fact type.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Role" type="RoleRef"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleSequenceType">
		<xs:annotation>
			<xs:documentation>A sequence of constraint roles.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Role" type="RoleSequenceRoleRef" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleSequenceWithJoinType">
		<xs:annotation>
			<xs:documentation>A sequence of constraint roles and possible join path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Role" type="RoleSequenceWithProjectionRoleRef" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="JoinRule" type="JoinRuleType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleSequenceWithJoinAndIdType">
		<xs:annotation>
			<xs:documentation>A sequence of constraint roles with an identifier.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ConstraintRoleSequenceWithJoinType">
				<xs:attributeGroup ref="idAttribute"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RoleSequenceRoleRef">
		<xs:complexContent>
			<xs:extension base="RoleRef">
				<xs:attributeGroup ref="idAttributeOptional"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RoleSequenceWithProjectionRoleRef">
		<xs:complexContent>
			<xs:extension base="RoleSequenceRoleRef">
				<xs:sequence>
					<xs:element name="ProjectedFrom" minOccurs="0">
						<xs:annotation>
							<xs:documentation>(Deprecated, use JoinPath/JoinPathProjections) The node in the join path used to populate this role in a derived fact type.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice minOccurs="0">
								<xs:element name="PathedRole" type="PathedRoleRef"/>
								<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
								<xs:element name="Constant" type="PathConstantType"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RoleRef">
		<xs:annotation>
			<xs:documentation>A reference to a role.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--end RoleRef, RoleSequence and  RoleSequences-->
	<xs:complexType name="JoinRuleType">
		<xs:annotation>
			<xs:documentation>A rule indicating how roles from different fact types in the same constraint role sequence are connected.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="JoinPath" type="ConstraintRoleSequenceJoinPathType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FactRolesType">
		<xs:annotation>
			<xs:documentation>Container for roles in a fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Role" type="RoleType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ImpliedFactRolesType">
		<xs:annotation>
			<xs:documentation>Container for roles in a fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:sequence>
				<xs:element name="Role" type="RoleType"/>
				<xs:choice>
					<xs:element name="RoleProxy" type="RoleProxyType"/>
					<xs:element name="ObjectifiedUnaryRole" type="ObjectifiedUnaryRoleType"/>
				</xs:choice>
			</xs:sequence>
			<xs:sequence>
				<xs:choice>
					<xs:element name="RoleProxy" type="RoleProxyType"/>
					<xs:element name="ObjectifiedUnaryRole" type="ObjectifiedUnaryRoleType"/>
				</xs:choice>
				<xs:element name="Role" type="RoleType"/>
			</xs:sequence>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SubtypeRolesType">
		<xs:annotation>
			<xs:documentation>Container for the meta roles associated with a subtype fact.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="SupertypeMetaRole" type="RoleType">
				<xs:annotation>
					<xs:documentation>The meta role associated with the supertype role player.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SubtypeMetaRole" type="RoleType">
				<xs:annotation>
					<xs:documentation>The meta role associated with the subtype role player.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:all>
	</xs:complexType>
	<xs:complexType name="RoleBaseType" abstract="true">
		<xs:sequence>
			<xs:element name="RolePlayer" type="ObjectTypeRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A reference to the object type that plays this role.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ValueRestriction" type="RoleValueRestrictionType" minOccurs="0"/>
			<xs:element name="CardinalityRestriction" type="UnaryRoleCardinalityRestrictionType" minOccurs="0"/>
			<!-- UNDONE: Remove direct DerivationSource support when the format is upgraded -->
			<xs:element name="DerivationSource" minOccurs="0">
				<xs:annotation>
					<xs:documentation>(Deprecated, replaced with FactTypeDerivationPath/DerivationProjections) The node in the derivation path used to populate this role in a derived fact type.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice minOccurs="0">
						<xs:element name="PathedRole" type="PathedRoleRef"/>
						<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
						<xs:element name="Constant" type="PathConstantType"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
			<xs:element name="RoleInstances" type="RoleInstancesType"  minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>An explicit name for this role.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<!--Derived-->
		<xs:attribute name="_IsMandatory" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Derived attribute set to true if this role is associated with a simple mandatory constraint.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<!--Derived-->
		<xs:attribute name="_Multiplicity" type="MultiplicityValues" default="ZeroToOne"/>
	</xs:complexType>
	<xs:complexType name="RoleType">
		<xs:annotation>
			<xs:documentation>A primary role declaration.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RoleBaseType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RoleProxyType">
		<xs:annotation>
			<xs:documentation>The role in an implied fact type that corresponds to a role in the objectified fact type. In terms of constraints, the role proxy is treated as the same role. The only normal role relationship allowed on a proxy role is inclusion in a reading order.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Role" type="RoleRef"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ObjectifiedUnaryRoleType">
		<xs:annotation>
			<xs:documentation>A role representing the identifying role in the fact type implied between the object type that objectifies a unary role and the unary role player. There is an implied equality constraint between this role and the referenced unary role.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RoleBaseType">
				<xs:sequence>
					<xs:element name="UnaryRole" type="RoleRef">
						<xs:annotation>
							<xs:documentation>A reference to the objectified unary role.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--Look up enum values.-->
	<xs:simpleType name="MultiplicityValues">
		<xs:annotation>
			<xs:documentation>The UML-style multiplicity for a role in a binary fact type. Derived from internal uniqueness and mandatory constraints.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Unspecified">
				<xs:annotation>
					<xs:documentation>No internal constraints are specified.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Indeterminate">
				<xs:annotation>
					<xs:documentation>Specified internal constraints are inconsistent, resulting in a multiplicity that cannot be determined.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ZeroToOne">
				<xs:annotation>
					<xs:documentation>At most one instance of this role player may be associated with the opposite role player. Corresponds to a single role uniqueness constraint on the opposite role.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ZeroToMany">
				<xs:annotation>
					<xs:documentation>Zero or more instances of this role player can be associated a single instance of the opposite role player.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ExactlyOne">
				<xs:annotation>
					<xs:documentation>Exactly one instance of this role player may be associated with the opposite role player. Corresponds to single role uniqueness and mandatory constraints on the opposite role.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="OneToMany">
				<xs:annotation>
					<xs:documentation>One or more instances of this role player can be associated a single instance of the opposite role player.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--End Roles-->
	<!-- Facts -->
	<!--Fact Ref defines a reference to a fact-->
	<xs:complexType name="FactTypeRef">
		<xs:annotation>
			<xs:documentation>A reference to a fact type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ObjectifiedFactTypeRef">
		<xs:annotation>
			<xs:documentation>A reference to the fact type, representing the objectification relationship between the entity type and the referenced fact type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="IsImplied" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>True if the objectification relationship is implied by a spanning uniqueness constraint on a binary fact type or an n-ary fact type where n&gt;2. The objectifying entity type for an implied fact type is always independent.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ObjectificationRef">
		<xs:annotation>
			<xs:documentation>A reference to an objectification relationship.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--end Fact Ref-->
	<xs:complexType name="FactTypesType">
		<xs:annotation>
			<xs:documentation>Container for all fact types in the model.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactTypeType"/>
			<xs:element name="SubtypeFact" type="SubtypeFactTypeType"/>
			<xs:element name="ImpliedFact" type="ImpliedFactTypeType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="FactTypeType">
		<xs:annotation>
			<xs:documentation>A fact type directly specified by the modeler.</xs:documentation>
		</xs:annotation>
		<!-- These are duplicated in ImpliedFactTypeType, SubtypeFactTypeType, and QueryType without type extension -->
		<xs:sequence minOccurs="0">
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="FactRoles" type="FactRolesType" minOccurs="0"/>
			<xs:element name="ReadingOrders" type="ReadingOrdersType" minOccurs="0"/>
			<xs:element name="InternalConstraints" type="InternalConstraintsType" minOccurs="0"/>
			<xs:element name="DerivationRule" type="FactTypeDerivationRuleType" minOccurs="0"/>
			<xs:element name="Instances" type="FactTypeInstancesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="_Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>A name generated from the first reading of the first reading order, or the name of the objectifying entity type.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="IsExternal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This fact type is externally defined (not used).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ImpliedFactTypeType">
		<xs:annotation>
			<xs:documentation>A fact type representing the implied relationship between an objectifying entity type and the role player of a role in the objectified fact type.</xs:documentation>
		</xs:annotation>
		<!-- This is a straight copy from Fact with a change to FactRoles -->
		<xs:sequence minOccurs="0">
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="FactRoles" type="ImpliedFactRolesType" minOccurs="0"/>
			<xs:element name="ReadingOrders" type="ReadingOrdersType" minOccurs="0"/>
			<xs:element name="InternalConstraints" type="InternalConstraintsType" minOccurs="0"/>
			<xs:element name="DerivationRule" type="FactTypeDerivationRuleType" minOccurs="0"/>
			<xs:element name="ImpliedByObjectification" type="ObjectificationRef">
				<xs:annotation>
					<xs:documentation>A reference to the objectification relationship that implies this fact type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="_Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>A name generated from the first reading of the first reading order.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="IsExternal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This fact type is externally defined (not used).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SubtypeFactTypeType">
		<xs:annotation>
			<xs:documentation>A fact type representing the subtype meta relationship between a subtype and a supertype.</xs:documentation>
		</xs:annotation>
		<!-- This is a straight copy from FactTypeType with a change to FactRoles -->
		<xs:sequence minOccurs="0">
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="FactRoles" type="SubtypeRolesType"/>
			<xs:element name="ReadingOrders" type="ReadingOrdersType" minOccurs="0"/>
			<xs:element name="InternalConstraints" type="InternalConstraintsType" minOccurs="0"/>
			<!-- UNDONE: Remove SubtypeFactTypeType.DerivationRule when file format is officially updated -->
			<xs:element name="DerivationRule" type="FactTypeDerivationRuleType" minOccurs="0">
				<xs:annotation>
					<xs:documentation>(Deprecated) Subtype derivation rules are expressed directly on the subtype, not the subtype fact relationship.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Instances" type="FactTypeInstancesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="_Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>A name generated from the implied reading for subtype fact, name 'AIsASubtypeOfB'.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="IsExternal" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>This fact type is externally defined (not used).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="IsPrimary" type="xs:boolean" default="false">
			<xs:annotation>
				<!-- UNDONE: Remove IsPrimary when file format is officially updated -->
				<xs:documentation>Deprecated property, use PreferredIdentificationPath instead.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PreferredIdentificationPath" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>The subtype fact is a possible path through the subtype graph for retrieving the identifying supertype for the subtype. The identifying supertype can be a direct or indirect supertype.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="QueryType">
		<xs:annotation>
			<xs:documentation>A query specified by the modeler.</xs:documentation>
		</xs:annotation>
		<!-- This is a straight copy from Fact with a change to FactRoles and several items removed -->
		<xs:sequence minOccurs="0">
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="QueryRoles" type="FactRolesType" minOccurs="0"/>
			<xs:element name="DerivationRule" type="QueryDerivationRuleType" minOccurs="0"/>
			<xs:element name="QueryParameters" type="QueryParametersType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="_Signature" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>A description of the query signature show names and types for parameters and roles.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SubqueryRef">
		<xs:annotation>
			<xs:documentation>A reference to a subquery.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="QueryParametersType">
		<xs:annotation>
			<xs:documentation>Container for parameters defined by a query.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="QueryParameter" type="QueryParameterType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="QueryParameterType">
		<xs:annotation>
			<xs:documentation>A parameter defined as the input for a query element.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ParameterType" type="ObjectTypeRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The type associated with this parameter.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ParameterBindings" type="QueryParameterBindingsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string">
			<xs:annotation>
				<xs:documentation>The name of the parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="QueryParameterBindingsType">
		<xs:annotation>
			<xs:documentation>Container to bind parameters to join path elements.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="ParameterBinding" type="QueryParameterBindingType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="QueryParameterBindingType">
		<xs:annotation>
			<xs:documentation>Bind the referenced parameter to a pathed role or root object type in the context lead role path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="BoundTo">
				<xs:annotation>
					<xs:documentation>Indicate the bound path node for this parameter.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice>
						<xs:element name="PathedRole" type="PathedRoleRef">
							<xs:annotation>
								<xs:documentation>The PathedRole associated with this parameter for this role path.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="PathRoot" type="RootObjectTypeRef">
							<xs:annotation>
								<xs:documentation>The PathRoot associated with this parameter for this role path.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--Derived FactType-->
	<xs:complexType name="FactTypeDerivationRuleType">
		<xs:annotation>
			<xs:documentation>The formal derivation rule defining a fact type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DerivationExpression" type="FactTypeDerivationExpressionType" minOccurs="0"/>
			<xs:element name="FactTypeDerivationPath" type="FactTypeDerivationPathType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="QueryDerivationRuleType">
		<xs:annotation>
			<xs:documentation>The formal derivation rule for a query.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="QueryDerivationPath" type="QueryDerivationPathType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="DerivationExpressionType">
		<xs:annotation>
			<xs:documentation>A derivation expression.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Body" type="xs:string">
				<xs:annotation>
					<xs:documentation>A textual derivation expression. This will be replaced in the future with a formal definition involving role paths and other relationships.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeDerivationExpressionType">
		<xs:annotation>
			<xs:documentation>(Deprecated) A derivation expression. Use FactTypeDerivationPath/InformalRule/DerivationNote instead.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="DerivationExpressionType">
				<xs:attribute name="DerivationStorage" type="DerivationExpressionStorageValues" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="DerivationExpressionStorageValues">
		<xs:annotation>
			<xs:documentation>Specify how instances of derived fact type are stored.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Derived">
				<xs:annotation>
					<xs:documentation>The fact instance population is calculated on demand.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="DerivedAndStored">
				<xs:annotation>
					<xs:documentation>The fact instance population is calculated immediately and stored.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PartiallyDerived">
				<xs:annotation>
					<xs:documentation>The fact instance population can be asserted as well as derived.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PartiallyDerivedAndStored">
				<xs:annotation>
					<xs:documentation>The fact instance population can be asserted as well as calculated immediately and stored.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--End Derived FactType-->
	<!-- End Facts -->
	<!-- Role Paths -->
	<xs:complexType name="FunctionsType">
		<xs:annotation>
			<xs:documentation>A container for all Function definitions used in the model.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Function" type="FunctionType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FunctionType">
		<xs:annotation>
			<xs:documentation>Specifies a function definition used for calculating values.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Parameters" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A container for function parameters</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Parameter" type="FunctionParameterType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The name of the function.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="IsBoolean" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>True if this function or operator returns a boolean value, making it appropriate for use as a path condition.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="OperatorSymbol" type="xs:string">
			<xs:annotation>
				<xs:documentation>A symbol used to display this function as an operator. Treated as an infix operator for binary functions and a prefix operator for unary functions.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="FunctionRef">
		<xs:annotation>
			<xs:documentation>A reference to an function.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FunctionParameterType">
		<xs:annotation>
			<xs:documentation>A function parameter, defines the type of function input.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The name of the function parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="BagInput" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Set to true if this functions takes a bag input instead of a single value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="FunctionParameterRef">
		<xs:annotation>
			<xs:documentation>A reference to an function parameter.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RolePathType" abstract="true">
		<xs:choice maxOccurs="2">
			<!-- UNDONE: The choice here is a temporary hack to allow a RootObjectType to appear either before or after the PathedRoles and SubPaths,
			as with older file formats. The RootObjectType is always saved first with the current format. -->
			<xs:element name="RootObjectType" minOccurs="0" type="RootObjectTypeType"/>
			<xs:sequence minOccurs="0">
				<xs:element name="PathedRoles" minOccurs="0">
					<xs:annotation>
						<xs:documentation>A container for PathedRole elements.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="PathedRole" type="PathedRoleType" minOccurs="0" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="SubPaths" minOccurs="0">
					<xs:annotation>
						<xs:documentation>A container for SubPath elements.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="SubPath" type="RoleSubPathType" minOccurs="0" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:choice>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="SplitIsNegated" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Should a negation be applied to the split combination operator?</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="SplitCombinationOperator" type="LogicalCombinationOperatorType" default="And">
			<xs:annotation>
				<xs:documentation>Specify how sub paths split from this path should be combined.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RootObjectTypeType">
		<xs:annotation>
			<xs:documentation>A reference to the object type that establishes the start point object type for a role path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ValueRestriction" type="PathConditionRootValueRestrictionType" minOccurs="0"/>
		</xs:sequence>
		<!-- UNDONE: File format change, the id attribute should be required. -->
		<xs:attributeGroup ref="idAttributeOptional"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="IsNegated" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>The path root is negated.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="RootObjectTypeRef">
		<xs:annotation>
			<xs:documentation>A reference to the root object type of a role path.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RoleSubPathType">
		<xs:annotation>
			<xs:documentation>A role path that continues a parent path with a new root or a split condition.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RolePathType"/>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PathedRoleType">
		<xs:annotation>
			<xs:documentation>A role in connected path.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="ValueRestriction" type="PathConditionRoleValueRestrictionType" minOccurs="0"/>
			<!-- UNDONE: File format change, CorrelatedWith is deprecated. Use ObjectUnifiers. -->
			<xs:element name="CorrelatedWith" type="PathedRoleRef" minOccurs="0"/>
		</xs:all>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="Purpose" type="PathedRolePurposeType" use="required"/>
		<xs:attribute name="IsNegated" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>The path step is treated as a negation.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="PathedRoleRef">
		<xs:annotation>
			<xs:documentation>A reference to a pathed role.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:simpleType name="PathedRolePurposeType">
		<xs:annotation>
			<xs:documentation>Specify how a role in a path is used to step within and between fact types.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="StartRole">
				<xs:annotation>
					<xs:documentation>The role is the beginning of a path and directly attached to the root object type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SameFactType">
				<xs:annotation>
					<xs:documentation>The role is the same fact type as the previous join or start role.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PostInnerJoin">
				<xs:annotation>
					<xs:documentation>The role represents an inner over a role player shared with the previous role in the path.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PostOuterJoin">
				<xs:annotation>
					<xs:documentation>The role represents an outer join over a role player shared with the previous role in the path.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="LogicalCombinationOperatorType">
		<xs:annotation>
			<xs:documentation>Specifies the logical operator used to combine 2 or more elements.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="And">
				<xs:annotation>
					<xs:documentation>All values must be true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Or">
				<xs:annotation>
					<xs:documentation>At least one value must be true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Xor">
				<xs:annotation>
					<xs:documentation>Applied to two values, exactly one value must be true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="RolePathOwnerType" abstract="true">
		<xs:sequence>
			<xs:choice>
				<xs:element name="PathComponents" minOccurs="0">
					<xs:annotation>
						<xs:documentation>A container for the role paths defined for this owner.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="RolePath" type="LeadRolePathType" minOccurs="0" maxOccurs="unbounded"/>
							<xs:element name="SharedRolePath" type="LeadRolePathRef" minOccurs="0" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
				<xs:element name="PathComponent" minOccurs="0">
					<xs:annotation>
						<xs:documentation>(Deprecated, use PathComponents) A container for the role path defined by this owner.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence minOccurs="0">
							<xs:element name="RolePath" type="LeadRolePathType"/>
						</xs:sequence>
					</xs:complexType>
				</xs:element>
			</xs:choice>
			<xs:element name="CalculatedValues" minOccurs="0">
				<xs:annotation>
					<xs:documentation>(Deprecated, move to individual path components) A container for calculated values applied to elements in contained role paths.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CalculatedValue" type="CalculatedValueType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="Subqueries" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A container for subquery elements used by paths in this container.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Subquery" type="QueryType" minOccurs="0" maxOccurs="unbounded"/>
						<xs:element name="SharedSubquery" type="SubqueryRef" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="LeadRolePathType">
		<xs:annotation>
			<xs:documentation>A role path starting from a root object type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RolePathType">
				<xs:sequence>
					<xs:element name="ObjectUnifiers" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A container for object unifiers relating multiple pathed roles and pathed roots in difference branches of the path.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="ObjectUnifier" type="ObjectUnifierType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="SubqueryParameterInputs" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A container for subquery parameter inputs relating pathed roles and pathed roots with parameters used in subqueries used directly by this path.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="SubqueryParameterInputsFor" type="SubqueryParameterInputsForType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="CalculatedValues" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A container for calculated values applied to any elements in this role path.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="CalculatedValue" type="CalculatedValueType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="Conditions" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A list of calculated boolean results that are necessary conditions for this role path.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="CalculatedCondition" type="CalculatedValueRef" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="Notes" type="NotesType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="LeadRolePathRef">
		<xs:annotation>
			<xs:documentation>A reference to a top-level role path.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RoleSubPathRef">
		<xs:annotation>
			<xs:documentation>A reference to a sub path.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ObjectUnifierType">
		<xs:annotation>
			<xs:documentation>A unification of multiple pathed roles or path roots, indicating that the unified path nodes correspond to the same instance.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="2" maxOccurs="unbounded">
			<xs:element name="PathRoot" type="RootObjectTypeRef"/>
			<xs:element name="PathedRole" type="PathedRoleRef"/>
		</xs:choice>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ObjectUnifierRef">
		<xs:annotation>
			<xs:documentation>A reference to an object unifier.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="SubqueryParameterInputsForType">
		<xs:annotation>
			<xs:documentation>Associate the pathed role used to path over a subquery with the inputs passed from the containing role path to the subquery.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ParameterInput" type="SubqueryParameterInputType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="SubqueryParameterInputType">
		<xs:annotation>
			<xs:documentation>Associate the referenced parameter with a path node from the path that steps into this subquery.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="InputFrom" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Specify the path node used to provide the input data for the subquery.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice minOccurs="0">
						<xs:element name="PathRoot" type="RootObjectTypeRef"/>
						<xs:element name="PathedRole" type="PathedRoleRef"/>
						<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
						<xs:element name="Constant" type="PathConstantType"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="CalculatedValueType">
		<xs:annotation>
			<xs:documentation>Specifies the function, scope, and inputs used for an algorithmic calculation.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Function" type="FunctionRef" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The function used to perform the calculation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:choice>
				<xs:element name="AggregationContext" minOccurs="0">
					<xs:annotation>
						<xs:documentation>Path root and path role elements forming the aggregation context for the function evaluation. Populate if the function is an aggregate (meaning that a parameter is marked as a BagInput) and the UniversalAggregationContext attribute is not set.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:choice minOccurs="0" maxOccurs="unbounded">
							<xs:element name="PathRoot" type="RootObjectTypeRef"/>
							<xs:element name="PathedRole" type="PathedRoleRef"/>
						</xs:choice>
					</xs:complexType>
				</xs:element>
				<xs:element name="Scope" type="PathedRoleRef" minOccurs="0">
					<xs:annotation>
						<xs:documentation>(deprecated, use AggregationContext) The pathed role that provides the context for this calculation. Generally used to defined the extent of elements based to a bag parameter.</xs:documentation>
					</xs:annotation>
				</xs:element>
			</xs:choice>
			<xs:element name="Inputs" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Inputs passed to the function used for the calculation.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Input" type="CalculatedValueInputType" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="UniversalAggregationContext" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Set to true if the AggregationContext is not provided and the function is an aggregate, meaning that a parameter is marked as a BagInput.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="CalculatedValueInputType">
		<xs:annotation>
			<xs:documentation>An input to the function used to calculate a value.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Parameter" type="FunctionParameterRef" minOccurs="0"/>
			<xs:element name="Source" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The source of value or bag passed to this parameter.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice minOccurs="0">
						<xs:element name="PathRoot" type="RootObjectTypeRef"/>
						<xs:element name="PathedRole" type="PathedRoleRef"/>
						<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
						<xs:element name="Constant" type="PathConstantType"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="DistinctValues" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Should the bag input be analyzed to return only distinct values? Can only be applied an input associated with a bag parameter.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="PathConstantType">
		<xs:annotation>
			<xs:documentation>A constant value used in a role path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Value" type="xs:string">
				<xs:annotation>
					<xs:documentation>The lexical constant value. The value is interpreted based on context.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="CalculatedValueRef">
		<xs:annotation>
			<xs:documentation>A reference to a calculated value.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeDerivationPathType">
		<xs:annotation>
			<xs:documentation>A role path with projected nodes used to define the population of a derived fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RolePathOwnerType">
				<xs:sequence>
					<xs:element name="DerivationProjections" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A container for different sets of role projections.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="DerivationProjection" type="RoleBasedDerivationProjectionType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="InformalRule" type="InformalDerivationRuleType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="DerivationCompleteness" type="DerivationCompletenessValues" default="FullyDerived"/>
				<xs:attribute name="DerivationStorage" type="DerivationStorageValues" default="NotStored"/>
				<xs:attribute name="SetProjection" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>The derivation rule results in a set of distinct facts instead of a bag that might contain duplicates.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Name" type="xs:string" use="optional">
					<xs:annotation>
						<xs:documentation>The name of a fully derived fact type.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="ExternalDerivation" default="false" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>An empty derivation rule is externally defined.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FactTypeDerivationPathRef">
		<xs:annotation>
			<xs:documentation>A reference to a fact type derivation path.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="QueryDerivationPathType">
		<xs:annotation>
			<xs:documentation>A role path with projected nodes used to populate a query.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RolePathOwnerType">
				<xs:sequence>
					<xs:element name="DerivationProjections" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A container for different sets of role projections.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="DerivationProjection" type="RoleBasedDerivationProjectionType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QueryDerivationPathRef">
		<xs:annotation>
			<xs:documentation>A reference to a query derivation path.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RoleBasedDerivationProjectionType">
		<xs:annotation>
			<xs:documentation>Specify projections for each role used in a role projection corresponding to the referenced role path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleProjection" type="DerivedRoleProjectionType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FactTypeDerivationProjectionRef">
		<xs:annotation>
			<xs:documentation>A reference to a fact type derivation projection.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="DerivedRoleProjectionType">
		<xs:annotation>
			<xs:documentation>Specifying the derivation source for a referenced role in a derived FactType.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DerivationSource" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The node in the derivation path used to populate this role in a derived fact.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice minOccurs="0">
						<xs:element name="PathRoot" type="RootObjectTypeRef"/>
						<xs:element name="PathedRole" type="PathedRoleRef"/>
						<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
						<xs:element name="Constant" type="PathConstantType"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="IsAutomatic" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>The role is automatically projected onto the only matching path node.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="DerivedRoleProjectionRef">
		<xs:annotation>
			<xs:documentation>A reference to a projection onto a role in a derived fact type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:simpleType name="DerivationCompletenessValues">
		<xs:annotation>
			<xs:documentation>Specify if instances of a derived fact or object type can also be directly asserted.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="FullyDerived">
				<xs:annotation>
					<xs:documentation>The instance population is calculated on demand (default).</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PartiallyDerived">
				<xs:annotation>
					<xs:documentation>The instance population can be both calculated and asserted.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="DerivationStorageValues">
		<xs:annotation>
			<xs:documentation>Specify if derived fact or object instances should be recalculated on demand, or calculated on change and stored.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="NotStored">
				<xs:annotation>
					<xs:documentation>Instances are recalculated on demand (default).</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Stored">
				<xs:annotation>
					<xs:documentation>Instances are calculated on change and stored.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="SubtypeDerivationPathType">
		<xs:annotation>
			<xs:documentation>A role path used to define the population of a derived subtype.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RolePathOwnerType">
				<xs:sequence>
					<xs:element name="InformalRule" type="InformalDerivationRuleType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="ExternalDerivation" default="false" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>An empty derivation rule is externally defined.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="DerivationCompleteness" type="DerivationCompletenessValues" default="FullyDerived"/>
				<xs:attribute name="DerivationStorage" type="DerivationStorageValues" default="NotStored"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleSequenceJoinPathType">
		<xs:annotation>
			<xs:documentation>A role path used to define the path between roles in different fact types in the same join path.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="RolePathOwnerType">
				<xs:sequence>
					<xs:element name="JoinPathProjections" minOccurs="0">
						<xs:annotation>
							<xs:documentation>A container for different sets of path projections.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence>
								<xs:element name="JoinPathProjection" type="JoinPathProjectionType" minOccurs="0" maxOccurs="unbounded"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="IsAutomatic" default="false" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>The join path is automatically created from the constraint sequence.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleSequenceJoinPathRef">
		<xs:annotation>
			<xs:documentation>A reference to a constraint role sequence join path.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="JoinPathProjectionType">
		<xs:annotation>
			<xs:documentation>Specify projections for each constraint role used in a join path projection corresponding to the referenced role path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ConstraintRoleProjection" type="ConstraintRoleProjectionType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="JoinPathProjectionRef">
		<xs:annotation>
			<xs:documentation>A reference to a join path projection.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleProjectionType">
		<xs:annotation>
			<xs:documentation>Specifying the projection source for a referenced constraint role in a join path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ProjectedFrom" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The node in the join path used to populate this constraint role in a path projection.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:choice minOccurs="0">
						<xs:element name="PathRoot" type="RootObjectTypeRef"/>
						<xs:element name="PathedRole" type="PathedRoleRef"/>
						<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
						<xs:element name="Constant" type="PathConstantType"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attributeGroup ref="refAttribute"/>
		<xs:attribute name="IsAutomatic" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>The constraint role is automatically projected onto the only matching path node.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleProjectionRef">
		<xs:annotation>
			<xs:documentation>A reference to a projection from a join path onto a constrained role.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="InformalDerivationRuleType">
		<xs:annotation>
			<xs:documentation>An informal description of the intent of a derivation rule.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DerivationNote" type="DerivationExpressionType"/>
		</xs:sequence>
	</xs:complexType>
	<!-- End Role Paths -->
	<!--Constraints-->
	<xs:complexType name="EqualityConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to an equality constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ExclusionConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to an exclusion constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="MandatoryConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a mandatory constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a frequency constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="RingConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a ring constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ValueComparisonConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a value comparison constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ConstraintsType">
		<xs:annotation>
			<xs:documentation>Container for SetConstraints and SetComparisonConstraints.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="EqualityConstraint" type="EqualityConstraintType"/>
			<xs:element name="ExclusionConstraint" type="ExclusionConstraintType"/>
			<xs:element name="SubsetConstraint" type="SubsetConstraintType"/>
			<xs:element name="FrequencyConstraint" type="FrequencyConstraintType"/>
			<xs:element name="MandatoryConstraint" type="MandatoryConstraintType"/>
			<xs:element name="UniquenessConstraint" type="UniquenessConstraintType"/>
			<xs:element name="RingConstraint" type="RingConstraintType"/>
			<xs:element name="ValueComparisonConstraint" type="ValueComparisonConstraintType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ConstraintType" abstract="true">
		<xs:sequence>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The constraint name. Validation errors will be present for any constraint name that is not unique within the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Modality" type="ConstraintModalityValues" default="Alethic"/>
	</xs:complexType>
	<!-- SetComparison constraints-->
	<xs:complexType name="SetComparisonConstraintType" abstract="true">
		<xs:complexContent>
			<xs:extension base="ConstraintType">
				<xs:sequence>
					<xs:element name="RoleSequences" type="ConstraintRoleSequencesType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EqualityConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that two set populations must be equal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetComparisonConstraintType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ExclusionConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that two set populations must not be equal.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetComparisonConstraintType">
				<xs:sequence>
					<xs:element name="ExclusiveOrMandatoryConstraint" type="MandatoryConstraintRef" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SubsetConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that the population of one set must be included in the population of another set.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetComparisonConstraintType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConstraintRoleSequenceRef">
		<xs:annotation>
			<xs:documentation>A reference to a set constraint or a role sequence in a set comparison constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="SetComparisonConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a subset, equality, or exclusion constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="SubsetConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a subset constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="SetConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a mandatory, uniqueness, frequency, or ring constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ValueConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a role or value type value constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="CardinalityConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to an object type or unary role cardinality constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!-- end SetComparison constraints-->
	<!--Set constraints-->
	<xs:complexType name="SetConstraintType" abstract="true">
		<xs:complexContent>
			<xs:extension base="ConstraintType">
				<xs:sequence>
					<xs:element name="RoleSequence" type="ConstraintRoleSequenceType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SetConstraintWithJoinType" abstract="true">
		<xs:complexContent>
			<xs:extension base="ConstraintType">
				<xs:sequence>
					<xs:element name="RoleSequence" type="ConstraintRoleSequenceWithJoinType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying the number of times an instance must occur in a set population. Applies only if the instance appears at all.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintWithJoinType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="MinFrequency" type="xs:int">
					<xs:annotation>
						<xs:documentation>The minimum number of times an instance must be played by the constrained role(s).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="MaxFrequency" type="xs:int">
					<xs:annotation>
						<xs:documentation>The maximum number of times an instance must be played by the constrained role(s).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MandatoryConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that a set must be populated.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintType">
				<xs:sequence>
					<xs:element name="ImpliedByObjectType" type="ObjectTypeRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The object type with an explicit mandatory constraint pattern that implies this constraint.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="InherentForObjectType" type="ObjectTypeRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The object type that would implicitly recreate this constraint if it were not explicit in the model.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ExclusiveOrExclusionConstraint" type="ExclusionConstraintRef" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The associated exclusion constraint that is combined with this mandatory constraint to form an exclusive-or pattern.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="IsSimple" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>True if this is an internal constraint associated with a single role.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="IsImplied" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>True if this constraint is implied by a lack of a mandatory role on any non-existential role on the non-independent role player. An implied mandatory constraint may have a single role or multiple roles, but IsSimple is never true for an implied mandatory constraint.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="UniquenessConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that the population of a set must be unique.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintWithJoinType">
				<xs:sequence>
					<xs:element name="PreferredIdentifierFor" type="ObjectTypeRef" minOccurs="0"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="IsInternal" type="xs:boolean" default="false">
					<xs:annotation>
						<xs:documentation>If true, this uniqueness constraint is internal to a single fact type.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RingConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying relationships between elements of the same type in a set population.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintWithJoinType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="Type" type="RingConstraintTypeValues" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="RingConstraintTypeValues">
		<xs:annotation>
			<xs:documentation>Restrictions on the intersections of instances associated with roles in a ring constraint.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Undefined">
				<xs:annotation>
					<xs:documentation>The ring type is undefined. Corresponds to a model validation error.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Reflexive">
				<xs:annotation>
					<xs:documentation>If instance A plays some instance then intance B plays itself.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Irreflexive">
				<xs:annotation>
					<xs:documentation>No instance can play itself.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PurelyReflexive">
				<xs:annotation>
					<xs:documentation>Each instance plays itself and cannot play another instance.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Symmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then intance B plays instance A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Antisymmetric">
				<xs:annotation>
					<xs:documentation>If instance A is not equal to instance B and A plays B, then B cannot play A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Asymmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then instance B cannot play instance A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Transitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B that plays instance C then instance A plays instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Intransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B and instance B plays instance C, then instance A cannot play instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="StronglyIntransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B, then instance A cannot be indirectly related to instance B by repeatedly apply this fact type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Acyclic">
				<xs:annotation>
					<xs:documentation>Cycles are not allowed.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AcyclicTransitive">
				<xs:annotation>
					<xs:documentation>Cycles are not allowed. If instance A plays instance B that plays instance C then instance A plays instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AcyclicIntransitive">
				<xs:annotation>
					<xs:documentation>Cycles are not allowed; and if instance A plays instance B and instance B plays instance C, then instance A cannot play instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AcyclicStronglyIntransitive">
				<xs:annotation>
					<xs:documentation>Cycles are not allowed; and if instance A plays instance B, then instance A cannot be indirectly related to instance B by repeatedly apply this fact type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ReflexiveSymmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays some instance then intance B plays itself. If instance A plays instance B then intance B plays instance A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ReflexiveAntisymmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays some instance then intance B plays itself. If instance A is not equal to instance B and A plays B, then B cannot play A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ReflexiveTransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays some instance then intance B plays itself. If instance A plays instance B that plays instance C then instance A plays instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ReflexiveTransitiveAntisymmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays some instance then intance B plays itself. If instance A plays instance B that plays instance C then instance A plays instance C. If instance A is not equal to instance B and A plays B, then B cannot play A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SymmetricTransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then intance B plays instance A. If instance A plays instance B that plays instance C then instance A plays instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SymmetricIrreflexive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then intance B plays instance A. No instance can play itself.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SymmetricIntransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then intance B plays instance A. If instance A plays instance B and instance B plays instance C, then instance A cannot play instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SymmetricStronglyIntransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then intance B plays instance A. If instance A plays instance B, then instance A cannot be indirectly related to instance B by repeatedly apply this fact type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AsymmetricIntransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then instance B cannot play instance A. If instance A plays instance B and instance B plays instance C, then instance A cannot play instance C.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AsymmetricStronglyIntransitive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B then instance B cannot play instance A. If instance A plays instance B, then instance A cannot be indirectly related to instance B by repeatedly apply this fact type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="TransitiveIrreflexive">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B that plays instance C then instance A plays instance C. No instance can play itself.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="TransitiveAntisymmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B that plays instance C then instance A plays instance C. If instance A is not equal to instance B and A plays B, then B cannot play A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="TransitiveAsymmetric">
				<xs:annotation>
					<xs:documentation>If instance A plays instance B that plays instance C then instance A plays instance C. If instance A plays instance B then instance B cannot play instance A.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ValueComparisonConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint specifying that a comparison between two related values must be satisfied.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="SetConstraintWithJoinType">
				<xs:sequence>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="Operator" type="ValueComparisonOperatorValues" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="ValueComparisonOperatorValues">
		<xs:annotation>
			<xs:documentation>Restriction on the comparison operators allowed by a value comparison constraint.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Undefined">
				<xs:annotation>
					<xs:documentation>The comparison operator is undefined. Corresponds to a model validation error.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Equal">
				<xs:annotation>
					<xs:documentation>The two values must be equal.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NotEqual">
				<xs:annotation>
					<xs:documentation>The two values must not be equal.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="LessThan">
				<xs:annotation>
					<xs:documentation>The first value is less than the second.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="LessThanOrEqual">
				<xs:annotation>
					<xs:documentation>The first value is less than or equal to the second.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="GreaterThan">
				<xs:annotation>
					<xs:documentation>The first value is greater than the second.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="GreaterThanOrEqual">
				<xs:annotation>
					<xs:documentation>The first value is greater than or equal to the second.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--End Set constraints-->
	<!--InternalConstraint -->
	<xs:complexType name="InternalConstraintsType">
		<xs:annotation>
			<xs:documentation>Container for references to set constraints that are internal to a fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="UniquenessConstraint" type="UniquenessConstraintRef"/>
			<xs:element name="MandatoryConstraint" type="MandatoryConstraintRef"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="UniquenessConstraintRef">
		<xs:annotation>
			<xs:documentation>A reference to a uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--End InternalConstraint-->
	<!--End Constraints-->
	<!--Fact Readings and reading Orders-->
	<xs:complexType name="ReadingRef">
		<xs:annotation>
			<xs:documentation>A reference to a predicate reading.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ReadingOrdersType">
		<xs:annotation>
			<xs:documentation>Container for reading orders.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="ReadingOrder" type="ReadingOrderType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReadingOrderType">
		<xs:annotation>
			<xs:documentation>A sequence of roles from a single fact type representing representing a complete role traversal. Also called a predicate.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Readings" type="ReadingsType"/>
			<xs:element name="RoleSequence" type="ReadingRoleSequenceType"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ReadingsType">
		<xs:annotation>
			<xs:documentation>Container for readings corresponding to a reading order.</xs:documentation>
		</xs:annotation>
		<xs:sequence maxOccurs="unbounded">
			<xs:element name="Reading" type="ReadingType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReadingType">
		<xs:annotation>
			<xs:documentation>Predicate text corresponding to a specific role traversal.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Data" type="xs:string">
				<xs:annotation>
					<xs:documentation>Reading text with numbered replacemented fields in the format {n}, where n is a zero-based index into the corresponding role traversal order. n is also strictly increasing, so the first replacement field corresponds to the first role, etc. Reading text also includes hyphen-binding specifications, where 'WORD- ' (or ' -WORD') binds WORD and all intermediate words to the nearest right (left) placeholder. To enable hyphen binding with no space before the role player, 'WORD-- ROLEPLAYER' collapses the trailing space, resulting in 'WORD-ROLEPLAYER'. 'WORD- ROLEPLAYER' can be achived with two hyphens and two spaces.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ExpandedData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>An expanded form of the Data element with text decoration broken down on a per-role basis. Hyphen binding constructs are fully resolved with hyphens removed.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RoleText" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Text bound to or occurring after a given role. Roles with no text are not represented.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:attribute name="RoleIndex" type="xs:nonNegativeInteger" use="required">
									<xs:annotation>
										<xs:documentation>The zero-based index of the role.</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="PreBoundText" type="xs:string" use="optional">
									<xs:annotation>
										<xs:documentation>Text that is bound to the role as leading text through hyphen binding semantics in the full reading text.</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="PostBoundText" type="xs:string" use="optional">
									<xs:annotation>
										<xs:documentation>Text that is bound to the role as trailing text through hyphen binding semantics in the full reading text.</xs:documentation>
									</xs:annotation>
								</xs:attribute>
								<xs:attribute name="FollowingText" type="xs:string" use="optional">
									<xs:annotation>
										<xs:documentation>Text following a role replacement field and associated bound text.</xs:documentation>
									</xs:annotation>
								</xs:attribute>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
					<xs:attribute name="FrontText" type="xs:string" use="optional">
						<xs:annotation>
							<xs:documentation>Text that occurs before the lead role, including prebound text associated with that role.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<!--End Fact Readings and reading Orders-->
	<!-- Should Model errors be part of the core schema or in another namespace?-->
	<!--ModelErrors-->
	<xs:complexType name="ModelErrorsType">
		<xs:annotation>
			<xs:documentation>Container for all model validation errors.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element ref="ExtensionModelError"/>
			<xs:element name="ConstraintDuplicateNameError" type="ConstraintDuplicateNameErrorType"/>
			<xs:element name="ObjectTypeDuplicateNameError" type="ObjectTypeDuplicateNameErrorType"/>
			<xs:element name="RecognizedPhraseDuplicateNameError" type="RecognizedPhraseDuplicateNameErrorType"/>
			<xs:element name="GroupDuplicateNameError" type="GroupDuplicateNameErrorType"/>
			<xs:element name="FunctionDuplicateNameError" type="FunctionDuplicateNameErrorType"/>
			<xs:element name="DuplicateReadingSignatureError" type="DuplicateReadingSignatureErrorType"/>
			<xs:element name="GroupMembershipContradictionError" type="GroupMembershipContradictionErrorType"/>
			<xs:element name="ExternalConstraintRoleSequenceArityMismatchError" type="ExternalConstraintRoleSequenceArityMismatchErrorType"/>
			<xs:element name="FactTypeRequiresInternalUniquenessConstraintError" type="FactTypeRequiresInternalUniquenessConstraintErrorType"/>
			<xs:element name="FactTypeRequiresReadingError" type="FactTypeRequiresReadingErrorType"/>
			<xs:element name="TooFewEntityTypeRoleInstancesError" type="TooFewEntityTypeRoleInstancesErrorType"/>
			<xs:element name="TooFewFactTypeRoleInstancesError" type="TooFewFactTypeRoleInstancesErrorType"/>
			<xs:element name="TooFewReadingRolesError" type="TooFewReadingRolesErrorType"/>
			<xs:element name="ReadingRequiresUserModificationError" type="ReadingRequiresUserModificationErrorType"/>
			<xs:element name="TooFewRoleSequencesError" type="TooFewRoleSequencesErrorType"/>
			<xs:element name="TooManyReadingRolesError" type="TooManyReadingRolesErrorType"/>
			<xs:element name="TooManyRoleSequencesError" type="TooManyRoleSequencesErrorType"/>
			<xs:element name="DataTypeNotSpecifiedError" type="DataTypeNotSpecifiedErrorType"/>
			<xs:element name="NMinusOneError" type="NMinusOneErrorType"/>
			<xs:element name="CompatibleRolePlayerTypeError" type="CompatibleRolePlayerTypeErrorType"/>
			<xs:element name="SupersetRoleOfSubtypeSubsetConstraintNotSubtypeError" type="SupersetRoleOfSubtypeSubsetConstraintNotSubtypeErrorType"/>
			<xs:element name="JoinPathRequiredError" type="JoinPathRequiredErrorType"/>
			<xs:element name="RolePlayerRequiredError" type="RolePlayerRequiredErrorType"/>
			<!-- UNDONE: Remove EqualityImpliedByMandatoryError when file format is officially updated -->
			<xs:element name="EqualityImpliedByMandatoryError" type="EqualityImpliedByMandatoryErrorType"/>
			<xs:element name="EntityTypeRequiresReferenceSchemeError" type="EntityTypeRequiresReferenceSchemeErrorType"/>
			<xs:element name="FrequencyConstraintMinMaxError" type="FrequencyConstraintMinMaxErrorType"/>
			<xs:element name="FrequencyConstraintExactlyOneError" type="FrequencyConstraintExactlyOneErrorType"/>
			<xs:element name="FrequencyConstraintNonRestrictiveRangeError" type="FrequencyConstraintNonRestrictiveRangeErrorType"/>
			<!-- UNDONE: Remove FrequencyConstraintContradictsInternalUniquenessConstraintError when file format is officially updated -->
			<xs:element name="FrequencyConstraintContradictsInternalUniquenessConstraintError" type="FrequencyConstraintContradictsInternalUniquenessConstraintErrorType"/>
			<xs:element name="FrequencyConstraintViolatedByUniquenessConstraintError" type="FrequencyConstraintViolatedByUniquenessConstraintErrorType"/>
			<xs:element name="MinValueMismatchError" type="MinValueMismatchErrorType"/>
			<xs:element name="MaxValueMismatchError" type="MaxValueMismatchErrorType"/>
			<xs:element name="CardinalityRangeOverlapError" type="CardinalityRangeOverlapErrorType"/>
			<xs:element name="ValueRangeOverlapError" type="ValueRangeOverlapErrorType"/>
			<xs:element name="ValueTypeDetachedError" type="ValueTypeDetachedErrorType"/>
			<xs:element name="RingConstraintTypeNotSpecifiedError" type="RingConstraintTypeNotSpecifiedErrorType"/>
			<xs:element name="ValueComparisonConstraintOperatorNotSpecifiedError" type="ValueComparisonConstraintOperatorNotSpecifiedErrorType"/>
			<xs:element name="ValueComparisonRolesNotComparableError" type="ValueComparisonRolesNotComparableErrorType"/>
			<xs:element name="ImplicationError" type="ImplicationErrorType"/>
			<xs:element name="SubsetConstraintImpliedByMandatoryConstraintsError" type="SubsetConstraintImpliedByMandatoryConstraintsErrorType"/>
			<xs:element name="EqualityConstraintImpliedByMandatoryConstraintsError" type="EqualityConstraintImpliedByMandatoryConstraintsErrorType"/>
			<xs:element name="ExclusionContradictsMandatoryError" type="ExclusionContradictsMandatoryErrorType"/>
			<xs:element name="NotWellModeledSubsetAndMandatoryError" type="NotWellModeledSubsetAndMandatoryErrorType"/>
			<xs:element name="ImpliedInternalUniquenessConstraintError" type="ImpliedInternalUniquenessConstraintErrorType"/>
			<!-- UNDONE: Remove ObjectTypeRequiresPrimarySupertypeError when file format is officially updated -->
			<xs:element name="ObjectTypeRequiresPrimarySupertypeError" type="ObjectTypeRequiresPrimarySupertypeErrorType"/>
			<xs:element name="PreferredIdentifierRequiresMandatoryError" type="PreferredIdentifierRequiresMandatoryErrorType"/>
			<xs:element name="CompatibleSupertypesError" type="CompatibleSupertypesErrorType"/>
			<xs:element name="ObjectifyingInstanceRequiredError" type="ObjectifyingInstanceRequiredErrorType"/>
			<xs:element name="ObjectifiedInstanceRequiredError" type="ObjectifiedInstanceRequiredErrorType"/>
			<xs:element name="CompatibleValueTypeInstanceValueError" type="CompatibleValueTypeInstanceValueErrorType"/>
			<xs:element name="PopulationMandatoryError" type="PopulationMandatoryErrorType"/>
			<xs:element name="PopulationUniquenessError" type="PopulationUniquenessErrorType"/>
			<xs:element name="ExclusionContradictsEqualityError" type="ExclusionContradictsEqualityErrorType"/>
			<xs:element name="ExclusionContradictsSubsetError" type="ExclusionContradictsSubsetErrorType"/>
			<xs:element name="PathRequiresRootObjectTypeError" type="PathRequiresRootObjectTypeErrorType"/>
			<!-- UNDONE: Remove PathStartRoleFollowsRootObjectTypeError when file format is officially updated -->
			<xs:element name="PathStartRoleFollowsRootObjectTypeError" type="PathStartRoleFollowsRootObjectTypeErrorType"/>
			<xs:element name="JoinedPathRoleRequiresCompatibleRolePlayerError" type="JoinedPathRoleRequiresCompatibleRolePlayerErrorType"/>
			<!-- UNDONE: Remove CorrelatedPathRoleRequiresCompatibleRolePlayerError when file format is officially updated -->
			<xs:element name="CorrelatedPathRoleRequiresCompatibleRolePlayerError" type="CorrelatedPathRoleRequiresCompatibleRolePlayerErrorType"/>
			<xs:element name="ObjectUnifierRequiresCompatibleObjectTypesError" type="ObjectUnifierRequiresCompatibleObjectTypesErrorType"/>
			<xs:element name="PathSameFactTypeRoleFollowsJoinError" type="PathSameFactTypeRoleFollowsJoinErrorType"/>
			<xs:element name="PathOuterJoinRequiresOptionalRoleError" type="PathOuterJoinRequiresOptionalRoleErrorType"/>
			<xs:element name="CalculatedPathValueRequiresAggregationContextError" type="CalculatedPathValueRequiresAggregationContextErrorType"/>
			<xs:element name="CalculatedPathValueRequiresFunctionError" type="CalculatedPathValueRequiresFunctionErrorType"/>
			<xs:element name="CalculatedPathValueMustBeConsumedError" type="CalculatedPathValueMustBeConsumedErrorType"/>
			<xs:element name="CalculatedPathValueParameterBindingError" type="CalculatedPathValueParameterBindingErrorType"/>
			<xs:element name="FactTypeDerivationRequiresProjectionError" type="FactTypeDerivationRequiresProjectionErrorType"/>
			<xs:element name="QueryDerivationRequiresProjectionError" type="QueryDerivationRequiresProjectionErrorType"/>
			<xs:element name="PartialFactTypeDerivationProjectionError" type="PartialFactTypeDerivationProjectionErrorType"/>
			<xs:element name="PartialQueryDerivationProjectionError" type="PartialQueryDerivationProjectionErrorType"/>
			<xs:element name="JoinPathRequiresProjectionError" type="JoinPathRequiresProjectionErrorType"/>
			<xs:element name="PartialJoinPathProjectionError" type="PartialJoinPathProjectionErrorType"/>
			<xs:element name="DerivedFactTypeRoleProjectionCompatibilityError" type="DerivedFactTypeRoleProjectionCompatibilityErrorType"/>
			<xs:element name="QueryRoleProjectionCompatibilityError" type="QueryRoleProjectionCompatibilityErrorType"/>
			<xs:element name="JoinedConstraintRoleProjectionCompatibilityError" type="JoinedConstraintRoleProjectionCompatibilityErrorType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ModelError" abstract="true">
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Description of the model validation error.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="ExtensionModelError" type="ModelError" abstract="true">
		<xs:annotation>
			<xs:documentation>Extension point for model validation errors in extension models.</xs:documentation>
		</xs:annotation>
	</xs:element>
	<xs:complexType name="ConstraintDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple constraints share the same name.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraints">
						<xs:annotation>
							<xs:documentation>Like-named constraints.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice minOccurs="2" maxOccurs="unbounded">
								<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
								<xs:element name="SetConstraint" type="SetConstraintRef"/>
								<xs:element name="ValueConstraint" type="ValueConstraintRef"/>
								<xs:element name="CardinalityConstraint" type="CardinalityConstraintRef"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectTypeDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple object types share the same name.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Objects">
						<xs:annotation>
							<xs:documentation>Like-named object types.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="Object" type="ObjectTypeRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RecognizedPhraseDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple recognized phrases have the same text.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="RecognizedPhrases">
						<xs:annotation>
							<xs:documentation>Like-named phrases.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="RecognizedPhrase" type="RecognizedPhraseRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FunctionDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple functions have the same name.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Functions">
						<xs:annotation>
							<xs:documentation>Like-named functions.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="Function" type="FunctionRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DuplicateReadingSignatureErrorType">
		<xs:annotation>
			<xs:documentation>Multiple readings have the same normalized signature, which is a normalized expanded form of the reading text and role player names.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Readings">
						<xs:annotation>
							<xs:documentation>Readings with equivalent signatures.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="Reading" type="ReadingRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="EntityTypeRequiresReferenceSchemeErrorType">
		<xs:annotation>
			<xs:documentation>An entity type requires a reference scheme or a supertype that provides a preferred identification path.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="EntityType" type="ObjectTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ExternalConstraintRoleSequenceArityMismatchErrorType">
		<xs:annotation>
			<xs:documentation>A SetComparisonConstraint has an inconsistent number of columns.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraint" type="SetComparisonConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FactTypeRequiresInternalUniquenessConstraintErrorType">
		<xs:annotation>
			<xs:documentation>A ground fact type does not have at least on internal uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Fact" type="FactTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FactTypeRequiresReadingErrorType">
		<xs:annotation>
			<xs:documentation>A predicate reading has not been specified for a fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Fact" type="FactTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooFewReadingRolesErrorType">
		<xs:annotation>
			<xs:documentation>Reading text has more placeholders than the fact type has roles.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Reading" type="ReadingRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ReadingRequiresUserModificationErrorType">
		<xs:annotation>
			<xs:documentation>A reading has been automatically modified and must be edited by the user to restore its meaning.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:choice>
						<xs:element name="Reading" type="ReadingRef"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooFewRoleSequencesErrorType">
		<xs:annotation>
			<xs:documentation>An external constraint requires multiple roles (SetConstraint) or multiple role sequences (SetComparisonConstraint).</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:choice>
						<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
						<xs:element name="SetConstraint" type="SetConstraintRef"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooFewEntityTypeRoleInstancesErrorType">
		<xs:annotation>
			<xs:documentation>An entity instance is missing instance associations for some of the roles in its preferred identifier.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="EntityTypeInstance" type="EntityTypeInstanceRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooFewFactTypeRoleInstancesErrorType">
		<xs:annotation>
			<xs:documentation>A fact instance is missing instance associations for some roles in the fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="FactTypeInstance" type="FactTypeInstanceRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="TooManyReadingRolesErrorType">
		<xs:annotation>
			<xs:documentation>Reading text does not have enough placeholders for all roles.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Reading" type="ReadingRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DataTypeNotSpecifiedErrorType">
		<xs:annotation>
			<xs:documentation>A value type is using the unspecified data type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ConceptualDataType" type="DataTypeRefRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintMinMaxErrorType">
		<xs:annotation>
			<xs:documentation>A frequency constraints maximum values is less that its minimum value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintExactlyOneErrorType">
		<xs:annotation>
			<xs:documentation>A frequency constraint with a minimum and maximum range of 1 should be represented by a uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintNonRestrictiveRangeErrorType">
		<xs:annotation>
			<xs:documentation>A frequency constraint with a minimum of 1 and an unbounded maximum is always true and should not be specified.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- UNDONE: Remove FrequencyConstraintContradictsInternalUniquenessConstraintErrorType when file format is officially updated -->
	<xs:complexType name="FrequencyConstraintContradictsInternalUniquenessConstraintErrorType">
		<xs:annotation>
			<xs:documentation>(Deprecated by FrequencyConstraintViolatedByUniquenessConstraintErrorType) A frequency constraint requires more role players than are allowed by an internal uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:all>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
					<xs:element name="Fact" type="FactTypeRef"/>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FrequencyConstraintViolatedByUniquenessConstraintErrorType">
		<xs:annotation>
			<xs:documentation>A frequency constraint covers the same roles as a uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:all>
					<xs:element name="FrequencyConstraint" type="FrequencyConstraintRef"/>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MaxValueMismatchErrorType">
		<xs:annotation>
			<xs:documentation>The maximum value of a value range cannot be interpreted as the specified data type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueRange" type="ValueRangeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="MinValueMismatchErrorType">
		<xs:annotation>
			<xs:documentation>The minimum value of a value range cannot be interpreted as the specified data type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueRange" type="ValueRangeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ValueRangeOverlapErrorType">
		<xs:annotation>
			<xs:documentation>Two value ranges for the same value constraint have overlapping ranges.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueConstraint" type="ValueConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CardinalityRangeOverlapErrorType">
		<xs:annotation>
			<xs:documentation>Two or more cardinality constraint ranges are either overlapping or not increasing.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="CardinalityConstraint" type="CardinalityConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ValueTypeDetachedErrorType">
		<xs:annotation>
			<xs:documentation>A role value constraint is specified for a role that is no longer associated with a value type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueConstraint" type="ValueConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ImpliedInternalUniquenessConstraintErrorType">
		<xs:annotation>
			<xs:documentation>One or more internal uniqueness constraints in a fact type are implied by other internal uniqueness constraints on the same fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Fact" type="FactTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- UNDONE: Remove ObjectTypeRequiresPrimarySupertypeError when file format is officially updated -->
	<xs:complexType name="ObjectTypeRequiresPrimarySupertypeErrorType">
		<xs:annotation>
			<xs:documentation>Deprecated along with SubtypeFact.IsPrimary property</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ObjectType" type="ObjectTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PreferredIdentifierRequiresMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>The roles opposite a preferred identifier must have at least one mandatory constraint that covers a subset of the opposite roles.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ObjectType" type="ObjectTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompatibleSupertypesErrorType">
		<xs:annotation>
			<xs:documentation>Multiple supertypes are specified that do not share a common ancestor, or a supertype is specified that is implied by other supertypes.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ObjectType" type="ObjectTypeRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RingConstraintTypeNotSpecifiedErrorType">
		<xs:annotation>
			<xs:documentation>The type of a ring constraint is not specified.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="RingConstraint" type="RingConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ValueComparisonConstraintOperatorNotSpecifiedErrorType">
		<xs:annotation>
			<xs:documentation>The operator of a value comparison constraint is not specified.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueComparisonConstraint" type="ValueComparisonConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ValueComparisonRolesNotComparableErrorType">
		<xs:annotation>
			<xs:documentation>The roles in a value comparison constraint cannot be compared.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueComparisonConstraint" type="ValueComparisonConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ImplicationErrorType">
		<xs:annotation>
			<xs:documentation>A constraint is implied by another constraint in the model.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:choice>
						<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
						<xs:element name="SetConstraint" type="SetConstraintRef"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="ExclusionContradictsMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>Exclusion and mandatory constraints defined on intersecting roles contradict.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
					<xs:sequence>
						<xs:element name="Constraints">
							<xs:annotation>
								<xs:documentation>The contradictory constraints.</xs:documentation>
							</xs:annotation>
							<xs:complexType>
								<xs:choice minOccurs="2" maxOccurs="unbounded">
									<xs:element name="MandatoryConstraint" type="MandatoryConstraintRef"/>
									<xs:element name="ExclusionConstraint" type="SetComparisonConstraintRef"/>
								</xs:choice>
							</xs:complexType>
						</xs:element>
					</xs:sequence>				
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="NotWellModeledSubsetAndMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>Subset and mandatory constraints on intersecting roles are incorrectly modeled.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraints">
						<xs:annotation>
							<xs:documentation>Conflicting constraints.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:all>
								<xs:element name="MandatoryConstraint" type="MandatoryConstraintRef"/>
								<xs:element name="SubsetConstraint" type="SetComparisonConstraintRef"/>
							</xs:all>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="SubsetConstraintImpliedByMandatoryConstraintsErrorType">
		<xs:annotation>
			<xs:documentation>A subset constraint is implied by one or more mandatory constraints.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
				<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="SubsetConstraint" type="SetComparisonConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="EqualityConstraintImpliedByMandatoryConstraintsErrorType">
		<xs:annotation>
			<xs:documentation>An equality constraint is implied by one or more mandatory constraints.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="EqualityConstraint" type="SetComparisonConstraintRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="ExclusionContradictsSubsetErrorType">
		<xs:annotation>
			<xs:documentation>Exclusion and subset constraints defined on intersecting roles contradict.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraints">
						<xs:annotation>
							<xs:documentation>The contradictory constraints.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice maxOccurs="unbounded">
								<xs:element name="ExclusionConstraintThatContradictsWithSubset" type="SetComparisonConstraintRef" minOccurs="1"/>
								<xs:element name="SubsetConstraint" type="SetComparisonConstraintRef" minOccurs="1"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>

	<xs:complexType name="ExclusionContradictsEqualityErrorType">
		<xs:annotation>
			<xs:documentation>Exclusion and equality constraints defined on intersecting roles contradict.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Constraints">
						<xs:annotation>
							<xs:documentation>The contradictory constraints.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice maxOccurs="unbounded">
								<xs:element name="ExclusionConstraintThatContradictsWithEquality" type="SetComparisonConstraintRef" minOccurs="1"/>
								<xs:element name="EqualityConstraint" type="SetComparisonConstraintRef" minOccurs="1"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	
	<xs:complexType name="TooManyRoleSequencesErrorType">
		<xs:annotation>
			<xs:documentation>A SetConstraint has too many roles for the constraint type, or a SetComparisonConstraint has too many role sequences.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:choice>
						<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
						<xs:element name="SetConstraint" type="SetConstraintRef"/>
					</xs:choice>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompatibleRolePlayerTypeErrorType">
		<xs:annotation>
			<xs:documentation>The roles in a SetConstraint or a column of a SetComparisonConstraint have incompatible role players.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="SetComparisonConstraint" type="SetComparisonConstraintRef"/>
					<xs:element name="SetConstraint" type="SetConstraintRef"/>
				</xs:choice>
				<xs:attribute name="Column" type="xs:int" use="optional">
					<xs:annotation>
						<xs:documentation>The zero-based column with incompatible types (specified with a SetComparisonConstraint).</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SupersetRoleOfSubtypeSubsetConstraintNotSubtypeErrorType">
		<xs:annotation>
			<xs:documentation>The roles in a SetConstraint or a column of a SetComparisonConstraint have incompatible role players.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="SubsetConstraint" type="SubsetConstraintRef"/>
				</xs:sequence>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="JoinPathRequiredErrorType">
		<xs:annotation>
			<xs:documentation>The roles in a constraint role sequence span multiple fact types that are not implicitly joined.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="ConstraintRoleSequence" type="ConstraintRoleSequenceRef"/>
				</xs:choice>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RolePlayerRequiredErrorType">
		<xs:annotation>
			<xs:documentation>A role must have a specified role player.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="Role" type="RoleRef"/>
				</xs:choice>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<!-- UNDONE: Remove EqualityImpliedByMandatoryError when file format is officially updated -->
	<xs:complexType name="EqualityImpliedByMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>An equality constraint is implied by a mandatory constraint (Deprecated, replaced by EqualityConstraintImpliedByMandatoryConstraintsError).</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="EqualityConstraint" type="EqualityConstraintRef"/>
				</xs:choice>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="NMinusOneErrorType">
		<xs:annotation>
			<xs:documentation>An internal uniqueness constraint must span at least n minus one roles, where n is the number of roles in the fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="UniquenessConstraint" type="UniquenessConstraintRef"/>
				</xs:sequence>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompatibleValueTypeInstanceValueErrorType">
		<xs:annotation>
			<xs:documentation>The value of an instance is not compatible with the data type of the corresponding value type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ValueTypeInstance" type="ValueTypeInstanceRef"/>
				</xs:sequence>
			</xs:extension >
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PopulationMandatoryErrorType">
		<xs:annotation>
			<xs:documentation>The role player of the roles in a mandatory constraint has an instance that is not used by any of the roles.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:all>
					<xs:element name="ObjectTypeInstance" type="ObjectTypeInstanceRef"/>
					<xs:element name="MandatoryConstraint" type="MandatoryConstraintRef"/>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PopulationUniquenessErrorType">
		<xs:annotation>
			<xs:documentation>An instance is used twice by a role with a single-column uniqueness constraint.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="RoleInstances">
						<xs:annotation>
							<xs:documentation>Conflicting role instances.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:choice minOccurs="2" maxOccurs="unbounded">
								<xs:element name="FactTypeRoleInstance" type="ObjectTypeRoleInstanceRef"/>
								<xs:element name="EntityTypeRoleInstance" type="ObjectTypeRoleInstanceRef"/>
							</xs:choice>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectifyingInstanceRequiredErrorType">
		<xs:annotation>
			<xs:documentation>An instance of an objectified fact type does not have an associated instance for the objectifying entity type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="FactTypeInstance" type="FactTypeInstanceRef"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectifiedInstanceRequiredErrorType">
		<xs:annotation>
			<xs:documentation>An instance an objectifying entity does not have an associated instance for the objectifed fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="EntityTypeInstance" type="EntityTypeInstanceRef"/>
					<xs:element name="EntityTypeSubtypeInstance" type="EntityTypeSubtypeInstanceRef"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PathRequiresRootObjectTypeErrorType">
		<xs:annotation>
			<xs:documentation>A role path does not have a specified root object type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:choice>
					<xs:element name="RolePath" type="LeadRolePathRef"/>
					<xs:element name="SubPath" type="RoleSubPathRef"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- UNDONE: Remove PathStartRoleFollowsRootObjectTypeErrorType when file format is officially updated -->
	<xs:complexType name="PathStartRoleFollowsRootObjectTypeErrorType">
		<xs:annotation>
			<xs:documentation>(Deprecated, StartRole is no longer used) A PathedRole with a purpose of StartRole must be the first PathedRole after the path root.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="PathedRole" type="PathedRoleRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="JoinedPathRoleRequiresCompatibleRolePlayerErrorType">
		<xs:annotation>
			<xs:documentation>A PathedRole is joined to a preceding PathedRole with an incompatible role player or is a start role attached to an incompatible RootObjectType.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="PathedRole" type="PathedRoleRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!-- UNDONE: Remove CorrelatedPathRoleRequiresCompatibleRolePlayerErrorType when file format is officially updated -->
	<xs:complexType name="CorrelatedPathRoleRequiresCompatibleRolePlayerErrorType">
		<xs:annotation>
			<xs:documentation>(Deprecated, use ObjectUnifierRequiresCompatibleRolePlayersError) A PathedRole has an explicit correlation with a PathedRole that has an incompatible role player.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="PathedRole" type="PathedRoleRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ObjectUnifierRequiresCompatibleObjectTypesErrorType">
		<xs:annotation>
			<xs:documentation>An ObjectUnifier unifies path nodes with incompatible object types.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ObjectUnifier" type="ObjectUnifierRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PathSameFactTypeRoleFollowsJoinErrorType">
		<xs:annotation>
			<xs:documentation>A PathedRole with a purpose of SameFactType must follow an entry into the fact type with a join or start role. A role within a single fact type cannot be reused in a path without first joining to another instance of the same fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="PathedRole" type="PathedRoleRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PathOuterJoinRequiresOptionalRoleErrorType">
		<xs:annotation>
			<xs:documentation>An PathedRole with outer join semantics is joined to a mandatory role and can never be null.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="PathedRole" type="PathedRoleRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CalculatedPathValueRequiresFunctionErrorType">
		<xs:annotation>
			<xs:documentation>A calculated value in a role path must have a function specified to perform the calculation.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CalculatedPathValueRequiresAggregationContextErrorType">
		<xs:annotation>
			<xs:documentation>A calculated value in a role path with an aggregate function must specify an aggregation context.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CalculatedPathValueMustBeConsumedErrorType">
		<xs:annotation>
			<xs:documentation>A calculated value in a role path must be consumed as a path condition, an input to another calculation, or a projection onto a path.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="CalculatedValue" type="CalculatedValueRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CalculatedPathValueParameterBindingErrorType">
		<xs:annotation>
			<xs:documentation>A parameter binding is missing for the parameters associated with the function that calculates a calculated value.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="CalculatedValue">
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="CalculatedValueRef">
									<xs:sequence>
										<xs:element name="Parameter" type="FunctionParameterRef"/>
									</xs:sequence>
									<xs:attributeGroup ref="idAttribute"/>
								</xs:extension>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="FactTypeDerivationRequiresProjectionErrorType">
		<xs:annotation>
			<xs:documentation>A fact type derivation path must be projected on at least one role path.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="FactTypeDerivationPath" type="FactTypeDerivationPathRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QueryDerivationRequiresProjectionErrorType">
		<xs:annotation>
			<xs:documentation>A query derivation path must be projected on at least one role path.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="QueryDerivationPath" type="QueryDerivationPathRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PartialFactTypeDerivationProjectionErrorType">
		<xs:annotation>
			<xs:documentation>A fact type derivation projection must project on all roles in the derived fact type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="DerivationProjection" type="FactTypeDerivationProjectionRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PartialQueryDerivationProjectionErrorType">
		<xs:annotation>
			<xs:documentation>A query derivation projection must project on all roles in the derived query.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="DerivationProjection" type="FactTypeDerivationProjectionRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="JoinPathRequiresProjectionErrorType">
		<xs:annotation>
			<xs:documentation>A constraint join path must be projected on at least one role path.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="JoinPath" type="ConstraintRoleSequenceJoinPathRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PartialJoinPathProjectionErrorType">
		<xs:annotation>
			<xs:documentation>A join path projection must project on all roles in the constraint role sequence.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="JoinPathProjection" type="JoinPathProjectionRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="DerivedFactTypeRoleProjectionCompatibilityErrorType">
		<xs:annotation>
			<xs:documentation>A projection onto a derived fact type role is not compatible with the role player of that role.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="DerivedRoleProjection" type="DerivedRoleProjectionRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="QueryRoleProjectionCompatibilityErrorType">
		<xs:annotation>
			<xs:documentation>A projection onto a query role is not compatible with the role player of that role.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="DerivedRoleProjection" type="DerivedRoleProjectionRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="JoinedConstraintRoleProjectionCompatibilityErrorType">
		<xs:annotation>
			<xs:documentation>A projection from a join path onto a constrained role is not compatible with the role player of that role.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="ConstraintRoleProjection" type="ConstraintRoleProjectionRef"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--End ModelErrors-->
	<!--Custom Reference Modes-->
	<!--Reference Modes and Kinds-->
	<xs:complexType name="ReferenceModeKindsType">
		<xs:annotation>
			<xs:documentation>Container for the reference mode kinds.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element maxOccurs="unbounded" name="ReferenceModeKind" type="ReferenceModeKindType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReferenceModeKindRef">
		<xs:annotation>
			<xs:documentation>A reference to a reference mode kind.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="ReferenceModeKindType">
		<xs:annotation>
			<xs:documentation>Setting for a specific kind of reference mode pattern.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="FormatString" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>A string with replacement fields representing a custom format for a value type name based on the entity type name (replacement field {0}) and reference mode name (replacement field {1}). Given an entity type name and a value type name, reference mode FormatStrings are used to determine the associated reference mode and reference mode kind.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ReferenceModeType" type="ReferenceModeKindValues" use="required"/>
	</xs:complexType>
	<xs:simpleType name="ReferenceModeKindValues">
		<xs:annotation>
			<xs:documentation>Classification of reference mode patterns.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="General">
				<xs:annotation>
					<xs:documentation>The reference mode patterns resolves to a value type with no special semantics.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Popular">
				<xs:annotation>
					<xs:documentation>The reference mode patterns resolves to a value type with a name based on the identified entity type. The value type identifies exactly one entity type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="UnitBased">
				<xs:annotation>
					<xs:documentation>The reference mode patterns resolves to a value type that is associated with a measurable unit.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ValueRangeRef">
		<xs:annotation>
			<xs:documentation>A reference to a value range.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<!--Reference Mdoes and Kinds-->
	<xs:complexType name="CustomReferenceModesType">
		<xs:annotation>
			<xs:documentation>Container for custom reference mode pattern definitions.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="unbounded">
			<xs:element name="CustomReferenceMode" type="CustomReferenceModeType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CustomReferenceModeType">
		<xs:annotation>
			<xs:documentation>Definition of a custom reference mode pattern.</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0">
			<xs:element name="CustomFormatString" type="xs:string">
				<xs:annotation>
					<xs:documentation>A string with replacement fields representing a custom format for a value type name based on the entity type name (replacement field {0}) and reference mode name (replacement field {1}). If not specified, defaults to the ReferenceModeKind FormatString attribute.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Kind" type="ReferenceModeKindRef"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The reference mode name.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--End Custom Reference Modes-->
	<xs:complexType name="ValueTypeValueRestrictionType">
		<xs:annotation>
			<xs:documentation>Restrict the values allowed for any instance of the containing value type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ValueConstraint" type="ValueConstraintWithNameType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ValueConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint limiting the set of allowed values.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="ValueRanges" type="ValueRangesType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="ValueConstraintWithNameType">
		<xs:annotation>
			<xs:documentation>A named constraint limiting the set of allowed values.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ValueConstraintType">
				<xs:attribute name="Name" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>The constraint name. Validation errors will be present for any constraint name that is not unique within the model.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="RoleValueRestrictionType">
		<xs:annotation>
			<xs:documentation>Restrict the values allowed for role players associated with this role.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RoleValueConstraint" type="ValueConstraintWithNameType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PathConditionRoleValueRestrictionType">
		<xs:annotation>
			<xs:documentation>Restrict the values required by a pathed role to satisfy the role path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="PathedRoleConditionValueConstraint" type="ValueConstraintType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="PathConditionRootValueRestrictionType">
		<xs:annotation>
			<xs:documentation>Restrict the values required by a path root to satisfy the role path.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="PathRootConditionValueConstraint" type="ValueConstraintType" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ValueRangesType">
		<xs:annotation>
			<xs:documentation>Container for value ranges. A value instance must be contained in the union of these ranges.</xs:documentation>
		</xs:annotation>
		<xs:sequence maxOccurs="unbounded">
			<xs:element name="ValueRange" type="ValueRangeType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="RangeInclusionValues">
		<xs:annotation>
			<xs:documentation>Specify whether the endpoint of a range is included in the range.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="NotSet">
				<xs:annotation>
					<xs:documentation>Inclusion not explicitly set.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Open">
				<xs:annotation>
					<xs:documentation>The endpoint is not included in the range of values.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Closed">
				<xs:annotation>
					<xs:documentation>The endpoint is included in the range of values.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ValueRangeType">
		<xs:annotation>
			<xs:documentation>A simple value range.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="MinValue" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The lower bound for the range.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxValue" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>The upper bound of the range. Duplicate of the MinValue for a single value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MinInclusion" type="RangeInclusionValues" default="NotSet">
			<xs:annotation>
				<xs:documentation>Does the range include the lower bound?</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxInclusion" type="RangeInclusionValues" default="NotSet">
			<xs:annotation>
				<xs:documentation>Does the range include the upper bound?</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="InvariantMinValue" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>A culture-invariant form of the minValue attribute. This value will not be set for a data type where any value is allowed (such as a string) or if the minValue could not be interpreted by the current data type.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="InvariantMaxValue" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>A culture-invariant form of the maxValue attribute. This value will not be set for a data type where any value is allowed (such as a string) or if the minValue could not be interpreted by the current data type.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ObjectTypeCardinalityRestrictionType">
		<xs:annotation>
			<xs:documentation>Restrict the size of a population of this object type.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="CardinalityConstraint" type="CardinalityConstraintType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="UnaryRoleCardinalityRestrictionType">
		<xs:annotation>
			<xs:documentation>Restrict the number of different instances allowed to play this role in a population.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="UnaryRoleCardinalityConstraint" type="CardinalityConstraintType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CardinalityConstraintType">
		<xs:annotation>
			<xs:documentation>A constraint limiting the number of instances in a population.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ConstraintType">
				<xs:sequence>
					<xs:element name="Ranges" type="CardinalityRangesType"/>
					<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CardinalityRangesType">
		<xs:annotation>
			<xs:documentation>Container for cardinality ranges.</xs:documentation>
		</xs:annotation>
		<xs:sequence maxOccurs="unbounded">
			<xs:element name="CardinalityRange" type="CardinalityRangeType"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CardinalityRangeType">
		<xs:annotation>
			<xs:documentation>A single cardinality range.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="From" type="xs:nonNegativeInteger" use="required">
			<xs:annotation>
				<xs:documentation>The lower bound of the cardinality range. A value of zero indicates than an empty population is allowed.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="To" type="xs:nonNegativeInteger" use="optional">
			<xs:annotation>
				<xs:documentation>The upper bound of the cardinality range. Set to the same value as the 'From' attribute for a single-valued range. If this is omitted, then an unbounded range is assumed.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="ConstraintModalityValues">
		<xs:annotation>
			<xs:documentation>The strength of a constraint.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Alethic">
				<xs:annotation>
					<xs:documentation>A strong constraint that is enforced by the structure of a generated system.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Deontic">
				<xs:annotation>
					<xs:documentation>A weak constraint that should not be violated. Instances violating a deontic constraint can be structurally stored in a generated system.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:element name="NameGenerator" type="NameGeneratorType"/>
	<xs:complexType name="NameGeneratorType">
		<xs:annotation>
			<xs:documentation>Name generation settings</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
			<xs:element name="Refinements" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Container specifying additional name generator instances that provide settings for a more specific use of the generated names.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:element ref="NameGenerator" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element minOccurs="0" ref="RefinesGeneratedInstance"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="CasingOption" use="optional">
			<xs:annotation>
				<xs:documentation>Specify casing modifications for name parts and combinations. If not specified, the default CasingOption is the value from the nearest refining parent with this attribute. The root default is None.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="None">
						<xs:annotation>
							<xs:documentation>No casing options specified.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Camel">
						<xs:annotation>
							<xs:documentation>Generate names using camel casing (first letter of first word lower case, first letter of subsequent words upper case).</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Pascal">
						<xs:annotation>
							<xs:documentation>Generate names using Pascal casing (first letter of all words upper case).</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Upper">
						<xs:annotation>
							<xs:documentation>Generate names using all upper case letters.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Lower">
						<xs:annotation>
							<xs:documentation>Generate names using all lower case letters.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="SpacingFormat" use="optional">
			<xs:annotation>
				<xs:documentation>Specify how name spaces are treated during name generation. If not specified, the default SpacingFormat is the value from the nearest refining parent with this attribute. The root default is Retain.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="Retain">
						<xs:annotation>
							<xs:documentation>Keep any spaces specified in names used in the ORM model.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Remove">
						<xs:annotation>
							<xs:documentation>Generate names using all upper case letters.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ReplaceWith">
						<xs:annotation>
							<xs:documentation>Replace one or more spaces in model names with the character specified in the SpacingReplacement attribute.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="SpacingReplacement" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>The string used in place of spaces when the SpacingFormat attribute is ReplaceWith. If not specified, the default SpacingReplacement is the value from the nearest refining parent with this attribute. The root default is an empty string.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="NameUsage" type="xs:string" use="optional">
			<xs:annotation>
				<xs:documentation>The usage associated with this Name Generator</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="AutomaticallyShortenNames" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation>Whether the name generation system should automatically shorten names if they exceed the max length. If not specified, the default AutomaticallyShortenNames is the value from the nearest refining parent with this attribute. The root default is true.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="UserDefinedMaximum" type="xs:integer" use="optional">
			<xs:annotation>
				<xs:documentation>The maximum name length set by user if UseTargetDefaultMaximum is false. If not specified, the default UserDefinedMaximum is the value from the nearest refining parent with this attribute. The root default is 128.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="UseTargetDefaultMaximum" type="xs:boolean" use="optional">
			<xs:annotation>
				<xs:documentation>The maximum name length set by user if AutomaticallyShortenNames is set. If not specified, the default UseTargetDefaultMaximum is the value from the nearest refining parent with this attribute. The root default is true.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ReferenceModeNamingType" abstract="true">
		<xs:annotation>
			<xs:documentation>Reference mode naming options for a specific object type. Used by extension models, which must add their own reference to the modified object type.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="NamingChoice" type="NamingChoiceType" default="ModelDefault">
			<xs:annotation>
				<xs:documentation>Specify how a reference to a reference-mode identified instance is to be represented.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PrimaryIdentifierNamingChoice" type="NamingChoiceType" default="ModelDefault">
			<xs:annotation>
				<xs:documentation>Specify how the primary identifier of a reference-mode identified instance is to be represented.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="CustomFormat" type="xs:string">
			<xs:annotation>
				<xs:documentation>May be set if NamingChoice is CustomFormat. The replacement field {0} is the ValueTypeName, {1} is the EntityTypeName, and {2} is the ReferenceModeName.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PrimaryIdentifierCustomFormat" type="xs:string">
			<xs:annotation>
				<xs:documentation>May be set if PrimaryIdentifierNamingChoice is CustomFormat. The replacement field {0} is the ValueTypeName, {1} is the EntityTypeName, and {2} is the ReferenceModeName.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="NamingChoiceType">
		<xs:annotation>
			<xs:documentation>Specify how a reference mode is to be represented in a generated name. Includes and option to use context default settings.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="ModelDefault">
				<xs:annotation>
					<xs:documentation>Use the default setting for the model</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ValueTypeName">
				<xs:annotation>
					<xs:documentation>The name of the ValueType is used for naming.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="EntityTypeName">
				<xs:annotation>
					<xs:documentation>The name of the EntityType is used for naming.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ReferenceModeName">
				<xs:annotation>
					<xs:documentation>The name of the ReferenceMode is used for naming.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CustomFormat">
				<xs:annotation>
					<xs:documentation>A custom format string with any combination of the ValueTypeName/EntityTypeName/ReferenceModeName values is allowed. Use CustomFormat if specified or the default CustomFormat for the corresponding reference mode kind.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="DefaultReferenceModeNamingType" abstract="true">
		<xs:annotation>
			<xs:documentation>Represent a set of defaults for how reference modes should be used in generated code. This type must be extended in extension models to associate another element as the owning context for this default.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="TargetKind" use="required">
			<xs:annotation>
				<xs:documentation>Specify if these are the defaults for popular, unit based, or general reference modes.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="General">
						<xs:annotation>
							<xs:documentation>The naming conventions correspond to general reference modes.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Popular">
						<xs:annotation>
							<xs:documentation>The naming conventions correspond to popular reference modes.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="UnitBased">
						<xs:annotation>
							<xs:documentation>The naming conventions correspond to unit based reference modes.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="NamingChoice" type="EffectiveNamingChoiceType" default="ValueTypeName">
			<xs:annotation>
				<xs:documentation>Specify how a reference to a reference-mode identified instance is to be represented.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PrimaryIdentifierNamingChoice" type="EffectiveNamingChoiceType" default="ValueTypeName">
			<xs:annotation>
				<xs:documentation>Specify how the primary identifier of a reference-mode identified instance is to be represented.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="CustomFormat" type="xs:string">
			<xs:annotation>
				<xs:documentation>May be set if NamingChoice is CustomFormat. The replacement field {0} is the ValueTypeName, {1} is the EntityTypeName, and {2} is the ReferenceModeName.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="PrimaryIdentifierCustomFormat" type="xs:string">
			<xs:annotation>
				<xs:documentation>May be set if PrimaryIdentifierNamingChoice is CustomFormat. The replacement field {0} is the ValueTypeName, {1} is the EntityTypeName, and {2} is the ReferenceModeName.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="EffectiveNamingChoiceType">
		<xs:annotation>
			<xs:documentation>Specify default settings for how a reference mode is to be represented in a generated name.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="ValueTypeName">
				<xs:annotation>
					<xs:documentation>The name of the ValueType is used for naming.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="EntityTypeName">
				<xs:annotation>
					<xs:documentation>The name of the EntityType is used for naming.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ReferenceModeName">
				<xs:annotation>
					<xs:documentation>The name of the ReferenceMode is used for naming.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CustomFormat">
				<xs:annotation>
					<xs:documentation>A custom format string with any combination of the ValueTypeName/EntityTypeName/ReferenceModeName values is allowed. Use CustomFormat if specified or the default CustomFormat for the corresponding reference mode kind.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="RecognizedPhrasesType">
		<xs:annotation>
			<xs:documentation>Container for recognized phrases.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RecognizedPhrase" type="RecognizedPhraseType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="RecognizedPhraseType">
		<xs:annotation>
			<xs:documentation>A phrase with one or more words that can be abbreviated during name generation.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Abbreviations" type="AliasesType" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>A recognized word or phrase to map to a different text value during name generation. Generally a common word such as 'has' or 'the'. Allows mapping to an empty alias value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="RecognizedPhraseRef">
		<xs:annotation>
			<xs:documentation>A reference to a recognized phrase.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:element name="GenerationState" type="GenerationStateType"/>
	<xs:complexType name="GenerationStateType">
		<xs:annotation>
			<xs:documentation>State information relating to automatic mapping algorithms.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="GenerationSettings" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Container for extension-defined data relating to how elements were generated from the ORM model.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence minOccurs="0" maxOccurs="unbounded">
						<xs:element ref="GenerationSetting"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:element name="GenerationSetting" type="GenerationSettingType" abstract="true"/>
	<xs:complexType name="GenerationSettingType">
		<xs:annotation>
			<xs:documentation>A generation setting representing the extension-defined algorithm used to generate elements from the ORM elements.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:element name="Grouping" type="GroupingType"/>
	<xs:complexType name="GroupingType">
		<xs:annotation>
			<xs:documentation>User-defined and rule-based element groupings.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="ORMModel" type="ORMModelRef">
				<xs:annotation>
					<xs:documentation>The ORMModel element associated with these groups.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Groups" type="GroupsType" minOccurs="0"/>
		</xs:sequence>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:complexType name="GroupsType">
		<xs:annotation>
			<xs:documentation>Container for Group elements.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Group" type="GroupType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="GroupRef">
		<xs:annotation>
			<xs:documentation>A reference to a group</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="GroupType">
		<xs:annotation>
			<xs:documentation>References to set of related elements.</xs:documentation>
		</xs:annotation>
		<xs:all>
			<xs:element name="Definitions" type="DefinitionsType" minOccurs="0"/>
			<xs:element name="Notes" type="NotesType" minOccurs="0"/>
			<xs:element name="GroupTypes" type="GroupTypesType" minOccurs="0"/>
			<xs:element name="Elements" type="GroupElementsType" minOccurs="0"/>
			<xs:element name="NestedGroups" type="NestedGroupsType" minOccurs="0"/>
			<xs:element name="Extensions" type="ExtensionsType" minOccurs="0"/>
		</xs:all>
		<xs:attributeGroup ref="idAttribute"/>
		<xs:attribute name="Name" use="required" type="xs:string">
			<xs:annotation>
				<xs:documentation>The group name. Validation errors will be present for any object type name that is not unique within the model.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Priority" default="0" type="xs:int">
			<xs:annotation>
				<xs:documentation>The priority of this group, used to determine precedence if the same element is included in more than one group with the same group type. Higher numbers have higher priority.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="TypeCompliance" default="NotExcluded">
			<xs:annotation>
				<xs:documentation>Determine how strictly group types control the group contents.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="NotExcluded">
						<xs:annotation>
							<xs:documentation>Allow any element that is not explicitly blocked by a group type.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="PartiallyApproved">
						<xs:annotation>
							<xs:documentation>At least one associated group type recognizes the element.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="FullyApproved">
						<xs:annotation>
							<xs:documentation>All associated group types recognize the element.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="GroupTypesType">
		<xs:annotation>
			<xs:documentation>Container for group types.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element ref="GroupType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="GroupTypeType">
		<xs:annotation>
			<xs:documentation>Extension point for an instance of a group type, which associates meaning with elements contained in a group.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="idAttribute"/>
	</xs:complexType>
	<xs:element name="GroupType" type="GroupTypeType" abstract="true"/>
	<xs:complexType name="GroupElementsType">
		<xs:annotation>
			<xs:documentation>Container for elements associated with a group.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="IncludedElement" type="ElementRef">
				<xs:annotation>
					<xs:documentation>A reference to an element included in this group.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ExcludedElement" type="ElementRef">
				<xs:annotation>
					<xs:documentation>A reference to an element automatically included in this group by a group type but explicitly excluded from the group by the user.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ElementRef">
		<xs:annotation>
			<xs:documentation>A reference to any directly identified element.</xs:documentation>
		</xs:annotation>
		<xs:attributeGroup ref="refAttribute"/>
	</xs:complexType>
	<xs:complexType name="NestedGroupsType">
		<xs:annotation>
			<xs:documentation>Container for groups whose elements are included or excluded from the containing group.</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="IncludedGroup" type="GroupRef">
				<xs:annotation>
					<xs:documentation>All included elements from the referenced group are included in the containing group.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ExcludedGroup" type="GroupRef">
				<xs:annotation>
					<xs:documentation>All included elements from the referenced group are excluded from the containing group.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="GroupDuplicateNameErrorType">
		<xs:annotation>
			<xs:documentation>Multiple groups share the same name.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:sequence>
					<xs:element name="Groups">
						<xs:annotation>
							<xs:documentation>Link-named groups.</xs:documentation>
						</xs:annotation>
						<xs:complexType>
							<xs:sequence minOccurs="2" maxOccurs="unbounded">
								<xs:element name="Group" type="GroupRef"/>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="GroupMembershipContradictionErrorType">
		<xs:annotation>
			<xs:documentation>A group member is required by one group type and blocked by another group type.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="ModelError">
				<xs:all>
					<xs:element name="Group">
						<xs:complexType>
							<xs:complexContent>
								<xs:extension base="GroupRef">
									<xs:sequence>
										<xs:element name="Element" type="ElementRef">
											<xs:annotation>
												<xs:documentation>A reference to the conflicting element.</xs:documentation>
											</xs:annotation>
										</xs:element>
									</xs:sequence>
									<xs:attributeGroup ref="idAttribute"/>
								</xs:extension>
							</xs:complexContent>
						</xs:complexType>
					</xs:element>
				</xs:all>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:element name="DynamicColor" type="DynamicColorType" abstract="true"/>
	<xs:complexType name="DynamicColorType">
		<xs:annotation>
			<xs:documentation>Dynamic color information used by extension models with shape representations.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="ColorRole" type="xs:token">
			<xs:annotation>
				<xs:documentation>The name of a role indicating use of the color. Correspond to an item in a color set enum.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ColorValue" type="xs:string">
			<xs:annotation>
				<xs:documentation>The name of the color played by this role.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:element name="ORMModelBrowserDynamicColor" substitutionGroup="DynamicColor">
		<xs:annotation>
			<xs:documentation>Dynamic color information displayed in the ORM Model Browser tool window.</xs:documentation>
		</xs:annotation>
	</xs:element>
</xs:schema>
