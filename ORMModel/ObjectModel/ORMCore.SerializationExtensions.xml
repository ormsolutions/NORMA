<?xml version="1.0" encoding="utf-8"?>
<se:CustomSerializedElements
	xmlns:se="http://schemas.neumont.edu/ORM/SDK/SerializationExtensions"
	xmlns:plx="http://schemas.neumont.edu/CodeGeneration/PLiX">
	<se:Copyright name="Common Public License Copyright Notice">
		<se:CopyrightLine>/**************************************************************************\</se:CopyrightLine>
		<se:CopyrightLine>* Natural Object-Role Modeling Architect for Visual Studio                 *</se:CopyrightLine>
		<se:CopyrightLine>*                                                                          *</se:CopyrightLine>
		<se:CopyrightLine>* Copyright © Neumont University. All rights reserved.                     *</se:CopyrightLine>
		<se:CopyrightLine>* Copyright © ORM Solutions, LLC. All rights reserved.                     *</se:CopyrightLine>
		<se:CopyrightLine>*                                                                          *</se:CopyrightLine>
		<se:CopyrightLine>* The use and distribution terms for this software are covered by the      *</se:CopyrightLine>
		<se:CopyrightLine>* Common Public License 1.0 (http://opensource.org/licenses/cpl) which     *</se:CopyrightLine>
		<se:CopyrightLine>* can be found in the file CPL.txt at the root of this distribution.       *</se:CopyrightLine>
		<se:CopyrightLine>* By using this software in any fashion, you are agreeing to be bound by   *</se:CopyrightLine>
		<se:CopyrightLine>* the terms of this license.                                               *</se:CopyrightLine>
		<se:CopyrightLine>*                                                                          *</se:CopyrightLine>
		<se:CopyrightLine>* You must not remove this notice, or any other, from this software.       *</se:CopyrightLine>
		<se:CopyrightLine>\**************************************************************************/</se:CopyrightLine>
	</se:Copyright>
	<se:DomainModel Class="ORMCoreDomainModel">
		<se:Namespaces>
			<se:Namespace Prefix="orm" URI="http://schemas.neumont.edu/ORM/2006-04/ORMCore" SchemaFile="ORM2Core.xsd" DefaultPrefix="true"/>
		</se:Namespaces>
		<se:RootElements>
			<se:RootElement Class="ORMModel"/>
			<se:RootElement Class="ModelErrorDisplayFilter"/>
			<se:RootElement Class="NameGenerator">
				<se:ConditionalSerialization>
					<plx:comment>Only serialize if this is not contained in a refinement relationship</plx:comment>
					<plx:return>
						<plx:binaryOperator type="identityEquality">
							<plx:left>
								<plx:callInstance name="RefinesGenerator" type="property">
									<plx:callObject>
										<plx:cast dataTypeName="NameGenerator">
											<plx:nameRef name="element" type="parameter"/>
										</plx:cast>
									</plx:callObject>
								</plx:callInstance>
							</plx:left>
							<plx:right>
								<plx:nullKeyword/>
							</plx:right>
						</plx:binaryOperator>
					</plx:return>
				</se:ConditionalSerialization>
			</se:RootElement>
			<se:RootElement Class="GenerationState">
				<se:ConditionalSerialization>
					<plx:comment>Only serialize if there are generated elements in this model.</plx:comment>
					<plx:return>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:callInstance name="Count" type="property">
									<plx:callObject>
										<plx:callInstance name="GenerationSettingCollection" type="property">
											<plx:callObject>
												<plx:cast dataTypeName="GenerationState">
													<plx:nameRef name="element" type="parameter"/>
												</plx:cast>
											</plx:callObject>
										</plx:callInstance>
									</plx:callObject>
								</plx:callInstance>
							</plx:left>
							<plx:right>
								<plx:value data="0" type="i4"/>
							</plx:right>
						</plx:binaryOperator>
					</plx:return>
				</se:ConditionalSerialization>
			</se:RootElement>
			<se:RootElement Class="ElementGroupingSet" Name="Grouping"/>
		</se:RootElements>
		<se:OmittedDomainElements>
			<se:OmitRelationship Class="FactConstraint"/>
			<se:OmitRelationship Class="FactSetComparisonConstraint"/>
			<se:OmitRelationship Class="ExternalRoleConstraint"/>
			<se:OmitRelationship Class="RoleInstance"/>
			<se:OmitRelationship Class="ModelNoteReferencesModelElement"/>
			<se:OmitRelationship Class="ModelHasModelErrorDisplayFilter"/>
			<se:OmitRelationship Class="ElementAssociatedWithModelError"/>
			<se:OmitRelationship Class="ElementHasAlias"/>
			<se:OmitRelationship Class="NameGeneratorRefinesInstance"/>
			<se:OmitRelationship Class="ObjectTypeHasObjectTypeInstance"/>
			<se:OmitRelationship Class="RolePathOwnerHasSingleLeadRolePath"/>
			<se:OmitRelationship Class="RolePathOwnerHasSingleOwnedLeadRolePath"/>
			<se:OmitRelationship Class="RolePathOwnerHasLeadRolePath"/>
			<se:OmitRelationship Class="RolePathOwnerHasSubquery"/>
			<se:OmitClass Class="IntrinsicReferenceMode"/>
			<se:OmitRelationship Class="GroupingElementRelationship"/>
			<se:OmitRelationship Class="ElementGroupingContainsElementGrouping"/>
			<!-- Omitting links to the presentation layers is not strictly required because all
				 links to external models do not serialize by default, but this one is very common,
				 and including it here allows us to block it earlier in the serialization process. -->
			<se:OmitRelationship Class="PresentationViewsSubject" Namespace="Microsoft.VisualStudio.Modeling.Diagrams"/>
		</se:OmittedDomainElements>
	</se:DomainModel>
	<!--Model-->
	<se:Element Class="ORMModelElement">
		<se:Container Name="Extensions" Prefix="orm">
			<se:Embed RelationshipName="ORMModelElementHasExtensionElement" RoleName="Extension"/>
		</se:Container>
		<se:Link RelationshipName="GroupingMembershipContradictionErrorIsForElement" RoleName="GroupingMembershipContradictionErrorRelationship" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="GroupingElementInclusion" RoleName="Grouping" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="GroupingElementExclusion" RoleName="Grouping" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ORMNamedElement" Override="true"/>
	<se:Element Class="ModelError" Override="true">
		<se:ConditionalSerialization>
			<plx:return>
				<plx:binaryOperator type="inequality">
					<plx:left>
						<plx:callThis name="ErrorState" type="property"/>
					</plx:left>
					<plx:right>
						<plx:callStatic name="Ignored" type="field" dataTypeName="ModelErrorState"/>
					</plx:right>
				</plx:binaryOperator>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Attribute ID="ErrorText" Name="Name"/>
		<se:Attribute ID="ErrorState" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ORMModel" Name="ORMModel" SortChildElements="true" Override="true">
		<se:Container Name="Definitions">
			<se:Embed RelationshipName="ModelHasDefinition" RoleName="Definition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="ModelHasPrimaryNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="Objects">
			<se:Embed RelationshipName="ModelHasObjectType" RoleName="ObjectType"/>
		</se:Container>
		<se:Container Name="Facts">
			<se:Embed RelationshipName="ModelHasFactType" RoleName="FactType"/>
		</se:Container>
		<se:Container Name="Constraints" SortChildElements="true">
			<se:Embed RelationshipName="ModelHasSetConstraint" RoleName="SetConstraint"/>
			<se:Embed RelationshipName="ModelHasSetComparisonConstraint" RoleName="SetComparisonConstraint"/>
		</se:Container>
		<se:Container Name="DataTypes">
			<se:Embed RelationshipName="ModelHasDataType" RoleName="DataType"/>
		</se:Container>
		<se:Container Name="Functions">
			<se:Embed RelationshipName="ModelDefinesFunction" RoleName="Function"/>
		</se:Container>
		<se:Container Name="CustomReferenceModes">
			<se:Embed RelationshipName="ModelHasReferenceMode" RoleName="ReferenceMode"/>
		</se:Container>
		<se:Container Name="ModelNotes">
			<se:Embed RelationshipName="ModelHasModelNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="ModelErrors">
			<se:Embed RelationshipName="ModelHasError" RoleName="Error"/>
		</se:Container>
		<se:Container Name="ReferenceModeKinds">
			<se:Embed RelationshipName="ModelHasReferenceModeKind" RoleName="ReferenceModeKind" />
		</se:Container>
		<se:Container Name="RecognizedPhrases">
			<se:Embed RelationshipName="ModelContainsRecognizedPhrase" RoleName="RecognizedPhrase"/>
		</se:Container>
		<se:Link RelationshipName="ElementGroupingSetRelatesToORMModel" RoleName="GroupingSet" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="Definition" Override="true">
		<se:Attribute ID="Text" WriteStyle="Element"/>
	</se:Element>
	<se:Element Class="Note" Override="true">
		<se:Attribute ID="Text" WriteStyle="Element"/>
	</se:Element>
	<se:Element Class="ModelNote" Override="true">
		<se:Container Name="ReferencedBy">
			<se:Link RelationshipName="ModelNoteReferencesFactType" RoleName="Element"/>
			<se:Link RelationshipName="ModelNoteReferencesObjectType" RoleName="Element"/>
			<se:Link RelationshipName="ModelNoteReferencesSetConstraint" RoleName="Element"/>
			<se:Link RelationshipName="ModelNoteReferencesSetComparisonConstraint" RoleName="Element"/>
		</se:Container>
		<se:Link Name="FactType" RelationshipName="ModelNoteReferencesFactType" RoleName="Element"/>
		<se:Link Name="ObjectType" RelationshipName="ModelNoteReferencesObjectType" RoleName="Element"/>
		<se:Link Name="SetConstraint" RelationshipName="ModelNoteReferencesSetConstraint" RoleName="Element"/>
		<se:Link Name="SetComparisonConstraint" RelationshipName="ModelNoteReferencesSetComparisonConstraint" RoleName="Element"/>
	</se:Element>
	<!--Generation Settings-->
	<se:Element Class="GenerationState">
		<se:Container Name="GenerationSettings">
			<se:Embed RelationshipName="GenerationStateHasGenerationSetting" RoleName="GenerationSetting"/>
		</se:Container>
	</se:Element>
	<se:Element Class="NameAlias" Name="Alias" Override="true">
		<se:Attribute ID="NameConsumer" WriteCustomStorage="true"/>
		<se:Attribute ID="NameUsage" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="identityEquality">
					<plx:left>
						<plx:callThis name="NameUsageType" type="property"/>
					</plx:left>
					<plx:right>
						<plx:nullKeyword/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link Name="RefinedInstance" RelationshipName="NameAliasRefinesInstance" RoleName="RefinedInstance"/>
	</se:Element>
	<se:Element Class="NameGenerator" SortChildElements="true" UnsortedElementsFirst="true" Override="true">
		<se:ConditionalSerialization>
			<plx:return>
				<plx:callThis name="RequiresSerialization"/>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Attribute ID="NameUsage" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="identityEquality">
					<plx:left>
						<plx:callThis name="NameUsageType" type="property"/>
					</plx:left>
					<plx:right>
						<plx:nullKeyword/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:SharedAttributeCode>
			<plx:local name="ignoredProperties" dataTypeName="StandardNameGeneratorProperty">
				<plx:initialize>
					<plx:callThis name="CurrentIgnoredStandardProperties" type="property"/>
				</plx:initialize>
			</plx:local>
			<plx:local name="refinedGenerator" dataTypeName="NameGenerator">
				<plx:initialize>
					<plx:callThis name="RefinesGenerator" type="property"/>
				</plx:initialize>
			</plx:local>
		</se:SharedAttributeCode>
		<se:Attribute ID="SpacingFormat" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:value data="0" type="i4"/>
							</plx:left>
							<plx:right>
								<plx:binaryOperator type="bitwiseAnd">
									<plx:left>
										<plx:nameRef name="ignoredProperties"/>
									</plx:left>
									<plx:right>
										<plx:callStatic name="SpacingFormat" type="field" dataTypeName="StandardNameGeneratorProperty"/>
									</plx:right>
								</plx:binaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="equality">
							<plx:left>
								<plx:callThis name="SpacingFormat" type="property"/>
							</plx:left>
							<plx:right>
								<plx:inlineStatement dataTypeName="NameGeneratorSpacingFormat">
									<plx:conditionalOperator>
										<plx:condition>
											<plx:binaryOperator type="identityInequality">
												<plx:left>
													<plx:nameRef name="refinedGenerator"/>
												</plx:left>
												<plx:right>
													<plx:nullKeyword/>
												</plx:right>
											</plx:binaryOperator>
										</plx:condition>
										<plx:left>
											<plx:callInstance name="SpacingFormat" type="property">
												<plx:callObject>
													<plx:nameRef name="refinedGenerator"/>
												</plx:callObject>
											</plx:callInstance>
										</plx:left>
										<plx:right>
											<plx:callStatic name="Retain" dataTypeName="NameGeneratorSpacingFormat" type="field"/>
										</plx:right>
									</plx:conditionalOperator>
								</plx:inlineStatement>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="CasingOption" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:value data="0" type="i4"/>
							</plx:left>
							<plx:right>
								<plx:binaryOperator type="bitwiseAnd">
									<plx:left>
										<plx:nameRef name="ignoredProperties"/>
									</plx:left>
									<plx:right>
										<plx:callStatic name="CasingOption" type="field" dataTypeName="StandardNameGeneratorProperty"/>
									</plx:right>
								</plx:binaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="equality">
							<plx:left>
								<plx:callThis name="CasingOption" type="property"/>
							</plx:left>
							<plx:right>
								<plx:inlineStatement dataTypeName="NameGeneratorCasingOption">
									<plx:conditionalOperator>
										<plx:condition>
											<plx:binaryOperator type="identityInequality">
												<plx:left>
													<plx:nameRef name="refinedGenerator"/>
												</plx:left>
												<plx:right>
													<plx:nullKeyword/>
												</plx:right>
											</plx:binaryOperator>
										</plx:condition>
										<plx:left>
											<plx:callInstance name="CasingOption" type="property">
												<plx:callObject>
													<plx:nameRef name="refinedGenerator"/>
												</plx:callObject>
											</plx:callInstance>
										</plx:left>
										<plx:right>
											<plx:callStatic name="None" dataTypeName="NameGeneratorCasingOption" type="field"/>
										</plx:right>
									</plx:conditionalOperator>
								</plx:inlineStatement>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="SpacingReplacement" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:value data="0" type="i4"/>
							</plx:left>
							<plx:right>
								<plx:binaryOperator type="bitwiseAnd">
									<plx:left>
										<plx:nameRef name="ignoredProperties"/>
									</plx:left>
									<plx:right>
										<plx:callStatic name="SpacingReplacement" type="field" dataTypeName="StandardNameGeneratorProperty"/>
									</plx:right>
								</plx:binaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="equality">
							<plx:left>
								<plx:callThis name="SpacingReplacement" type="property"/>
							</plx:left>
							<plx:right>
								<plx:inlineStatement dataTypeName=".string">
									<plx:conditionalOperator>
										<plx:condition>
											<plx:binaryOperator type="identityInequality">
												<plx:left>
													<plx:nameRef name="refinedGenerator"/>
												</plx:left>
												<plx:right>
													<plx:nullKeyword/>
												</plx:right>
											</plx:binaryOperator>
										</plx:condition>
										<plx:left>
											<plx:callInstance name="SpacingReplacement" type="property">
												<plx:callObject>
													<plx:nameRef name="refinedGenerator"/>
												</plx:callObject>
											</plx:callInstance>
										</plx:left>
										<plx:right>
											<plx:callStatic name="Empty" dataTypeName=".string" type="field"/>
										</plx:right>
									</plx:conditionalOperator>
								</plx:inlineStatement>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="AutomaticallyShortenNamesInitializer" Name="AutomaticallyShortenNames" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:value data="0" type="i4"/>
							</plx:left>
							<plx:right>
								<plx:binaryOperator type="bitwiseAnd">
									<plx:left>
										<plx:nameRef name="ignoredProperties"/>
									</plx:left>
									<plx:right>
										<plx:callStatic name="AutomaticallyShortenNames" type="field" dataTypeName="StandardNameGeneratorProperty"/>
									</plx:right>
								</plx:binaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="equality">
							<plx:left>
								<plx:callThis name="AutomaticallyShortenNames" type="property"/>
							</plx:left>
							<plx:right>
								<plx:inlineStatement dataTypeName=".boolean">
									<plx:conditionalOperator>
										<plx:condition>
											<plx:binaryOperator type="identityInequality">
												<plx:left>
													<plx:nameRef name="refinedGenerator"/>
												</plx:left>
												<plx:right>
													<plx:nullKeyword/>
												</plx:right>
											</plx:binaryOperator>
										</plx:condition>
										<plx:left>
											<plx:callInstance name="AutomaticallyShortenNames" type="property">
												<plx:callObject>
													<plx:nameRef name="refinedGenerator"/>
												</plx:callObject>
											</plx:callInstance>
										</plx:left>
										<plx:right>
											<plx:trueKeyword/>
										</plx:right>
									</plx:conditionalOperator>
								</plx:inlineStatement>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="UserDefinedMaximum" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:value data="0" type="i4"/>
							</plx:left>
							<plx:right>
								<plx:binaryOperator type="bitwiseAnd">
									<plx:left>
										<plx:nameRef name="ignoredProperties"/>
									</plx:left>
									<plx:right>
										<plx:callStatic name="UserDefinedMaximum" type="field" dataTypeName="StandardNameGeneratorProperty"/>
									</plx:right>
								</plx:binaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="equality">
							<plx:left>
								<plx:callThis name="UserDefinedMaximum" type="property"/>
							</plx:left>
							<plx:right>
								<plx:inlineStatement dataTypeName=".i4">
									<plx:conditionalOperator>
										<plx:condition>
											<plx:binaryOperator type="identityInequality">
												<plx:left>
													<plx:nameRef name="refinedGenerator"/>
												</plx:left>
												<plx:right>
													<plx:nullKeyword/>
												</plx:right>
											</plx:binaryOperator>
										</plx:condition>
										<plx:left>
											<plx:callInstance name="UserDefinedMaximum" type="property">
												<plx:callObject>
													<plx:nameRef name="refinedGenerator"/>
												</plx:callObject>
											</plx:callInstance>
										</plx:left>
										<plx:right>
											<plx:value data="128" type="i4"/>
										</plx:right>
									</plx:conditionalOperator>
								</plx:inlineStatement>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="UseTargetDefaultMaximumInitializer" Name="UseTargetDefaultMaximum" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:value data="0" type="i4"/>
							</plx:left>
							<plx:right>
								<plx:binaryOperator type="bitwiseAnd">
									<plx:left>
										<plx:nameRef name="ignoredProperties"/>
									</plx:left>
									<plx:right>
										<plx:callStatic name="UseTargetDefaultMaximum" type="field" dataTypeName="StandardNameGeneratorProperty"/>
									</plx:right>
								</plx:binaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="equality">
							<plx:left>
								<plx:callThis name="UseTargetDefaultMaximum" type="property"/>
							</plx:left>
							<plx:right>
								<plx:inlineStatement dataTypeName=".boolean">
									<plx:conditionalOperator>
										<plx:condition>
											<plx:binaryOperator type="identityInequality">
												<plx:left>
													<plx:nameRef name="refinedGenerator"/>
												</plx:left>
												<plx:right>
													<plx:nullKeyword/>
												</plx:right>
											</plx:binaryOperator>
										</plx:condition>
										<plx:left>
											<plx:callInstance name="UseTargetDefaultMaximum" type="property">
												<plx:callObject>
													<plx:nameRef name="refinedGenerator"/>
												</plx:callObject>
											</plx:callInstance>
										</plx:left>
										<plx:right>
											<plx:trueKeyword/>
										</plx:right>
									</plx:conditionalOperator>
								</plx:inlineStatement>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="Refinements" Prefix="orm">
			<se:Embed RelationshipName="NameGeneratorRefinesNameGenerator" RoleName="Refinement"/>
		</se:Container>
	</se:Element>
	<!--Object Types-->
	<se:Element Class="ObjectType" Name="EntityType" SortChildElements="true" Override="true">
		<se:ConditionalName Name="ValueType">
			<plx:callThis name="IsValueType" type="property"/>
		</se:ConditionalName>
		<se:ConditionalName Name="ObjectifiedType">
			<plx:binaryOperator type="identityInequality">
				<plx:left>
					<plx:callThis name="NestedFactType" type="property"/>
				</plx:left>
				<plx:right>
					<plx:nullKeyword/>
				</plx:right>
			</plx:binaryOperator>
		</se:ConditionalName>
		<se:Attribute ID="ReferenceModeString" Name="_ReferenceMode" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:callThis name="IsValueType" type="property"/>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="IsIndependent" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsIndependent" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="IsExternal" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsExternal" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="IsPersonal" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsPersonal" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="IsImplicitBooleanValue" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsImplicitBooleanValue" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="Definitions">
			<se:Embed RelationshipName="ObjectTypeHasDefinition" RoleName="Definition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="ObjectTypeHasNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="Abbreviations">
			<se:Embed RelationshipName="ObjectTypeHasAbbreviation" RoleName="Abbreviation"/>
		</se:Container>
		<se:Container Name="CardinalityRestriction">
			<se:Embed RelationshipName="ObjectTypeHasCardinalityConstraint" RoleName="CardinalityConstraint"/>
		</se:Container>
		<se:Container Name="PlayedRoles">
			<se:Link RelationshipName="ObjectTypePlaysRole" RoleName="PlayedRole"/>
		</se:Container>
		<se:Container Name="SubtypeDerivationRule" SortChildElements="true">
			<!-- UNDONE: File format change, remove derivation expression before deserialization. -->
			<se:Embed RelationshipName="SubtypeHasDerivationExpression" RoleName="DerivationRule"/>
			<se:Embed RelationshipName="SubtypeHasDerivationRule" RoleName="DerivationRule"/>
		</se:Container>
		<se:Link Name="ConceptualDataType" RelationshipName="ValueTypeHasDataType" RoleName="DataType" WriteStyle="PrimaryLinkElement"/>
		<se:Container Name="ValueRestriction">
			<se:Embed RelationshipName="ValueTypeHasValueConstraint" RoleName="ValueConstraint"/>
		</se:Container>
		<se:Link Name="Role" RelationshipName="ObjectTypePlaysRole" RoleName="PlayedRole">
			<se:ConditionalName Name="" WriteStyle="NotWritten">
				<plx:binaryOperator type="identityInequality">
					<plx:left>
						<plx:callInstance name="AlternateId" type="property">
							<plx:callObject>
								<plx:callInstance name="Partition" type="property">
									<plx:callObject>
										<plx:nameRef name="elementLink" type="parameter"/>
									</plx:callObject>
								</plx:callInstance>
							</plx:callObject>
						</plx:callInstance>
					</plx:left>
					<plx:right>
						<plx:nullKeyword/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
			<se:ConditionalName Name="SubtypeMetaRole">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:callStatic name="GetRolePlayer" dataTypeName="DomainRoleInfo">
							<plx:passParam>
								<plx:nameRef name="elementLink" type="parameter"/>
							</plx:passParam>
							<plx:passParam>
								<plx:callStatic dataTypeName="ObjectTypePlaysRole" name="PlayedRoleDomainRoleId" type="property"/>
							</plx:passParam>
						</plx:callStatic>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="SubtypeMetaRole"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
			<se:ConditionalName Name="SupertypeMetaRole">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:callStatic name="GetRolePlayer" dataTypeName="DomainRoleInfo">
							<plx:passParam>
								<plx:nameRef name="elementLink" type="parameter"/>
							</plx:passParam>
							<plx:passParam>
								<plx:callStatic dataTypeName="ObjectTypePlaysRole" name="PlayedRoleDomainRoleId" type="property"/>
							</plx:passParam>
						</plx:callStatic>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="SupertypeMetaRole"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>
		<se:Link Name="PreferredIdentifier" RelationshipName="EntityTypeHasPreferredIdentifier" RoleName="PreferredIdentifier"/>
		<se:Link Name="NestedPredicate" RelationshipName="Objectification" RoleName="NestedFactType" WriteStyle="PrimaryLinkElement" />
		<se:Container Name="Instances">
			<se:Embed RelationshipName="ValueTypeHasValueTypeInstance" RoleName="ValueTypeInstance"/>
			<se:Embed RelationshipName="EntityTypeHasEntityTypeInstance" RoleName="EntityTypeInstance"/>
			<se:Embed RelationshipName="EntityTypeSubtypeHasEntityTypeSubtypeInstance" RoleName="EntityTypeSubtypeInstance"/>
		</se:Container>
		<se:Link RelationshipName="ObjectTypeImpliesMandatoryConstraint" RoleName="MandatoryConstraint" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="MandatoryConstraintIsInherentForObjectType" RoleName="MandatoryConstraint" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectTypeHasEntityTypeRequiresReferenceSchemeError" RoleName="ReferenceSchemeError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectTypeHasDuplicateNameError" RoleName="DuplicateNameError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectTypeHasPreferredIdentifierRequiresMandatoryError" RoleName="PreferredIdentifierRequiresMandatoryError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectTypeHasCompatibleSupertypesError" RoleName="CompatibleSupertypesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ModelNoteReferencesObjectType" RoleName="Note" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="RolePathObjectTypeRoot" RoleName="RolePath" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="QueryParameterHasParameterType" RoleName="Parameter" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="RecognizedPhrase" Override="true">
		<se:Container Name="Abbreviations">
			<se:Embed RelationshipName="RecognizedPhraseHasAbbreviation" RoleName="Abbreviation"/>
		</se:Container>
		<se:Link RelationshipName="RecognizedPhraseHasDuplicateNameError" RoleName="DuplicateNameError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ValueTypeInstance" Name="ValueTypeInstance" Override="true">
		<se:ConditionalSerialization>
			<plx:return>
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:unaryOperator type="booleanNot">
							<plx:callInstance name="IsImplicitBooleanValue" type="property">
								<plx:callObject>
									<plx:callThis name="ValueType" type="property"/>
								</plx:callObject>
							</plx:callInstance>
						</plx:unaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:callInstance name="Count" type="property">
									<plx:callObject>
										<plx:callStatic dataTypeName="EntityTypeRoleInstance" name="GetLinksToRoleCollection">
											<plx:passParam>
												<plx:thisKeyword/>
											</plx:passParam>
										</plx:callStatic>
									</plx:callObject>
								</plx:callInstance>
							</plx:left>
							<plx:right>
								<plx:value data="0" type="i4"/>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Attribute ID="Value" WriteStyle="Element"/>
		<se:Attribute ID="InvariantValue" WriteStyle="Element">
			<se:Condition WriteStyle="NotWritten">
				<plx:callStatic name="IsNullOrEmpty" dataTypeName=".string">
					<plx:passParam>
						<plx:callThis name="InvariantValue" type="property"/>
					</plx:passParam>
				</plx:callStatic>
			</se:Condition>
		</se:Attribute>
		<se:Link RelationshipName="EntityTypeRoleInstance" RoleName="Role" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeRoleInstance" RoleName="Role" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ValueTypeInstanceHasCompatibleValueTypeInstanceValueError" RoleName="CompatibleValueTypeInstanceValueError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectTypeInstanceHasPopulationMandatoryError" RoleName="PopulationMandatoryError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="EntityTypeInstance" Name="EntityTypeInstance" SortChildElements="true" Override="true">
		<se:Container Name="RoleInstances">
			<se:Link RelationshipName="EntityTypeInstanceHasRoleInstance" RoleName="RoleInstance"/>
		</se:Container>
		<se:Link Name="EntityTypeRoleInstance" RelationshipName="EntityTypeInstanceHasRoleInstance" RoleName="RoleInstance"/>
		<se:Link Name="ObjectifiedInstance" RelationshipName="ObjectificationInstance" RoleName="ObjectifiedInstance"/>
		<se:Link RelationshipName="EntityTypeRoleInstance" RoleName="Role" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeRoleInstance" RoleName="Role" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="EntityTypeInstanceHasTooFewEntityTypeRoleInstancesError" RoleName="TooFewEntityTypeRoleInstancesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectTypeInstanceHasPopulationMandatoryError" RoleName="PopulationMandatoryError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="EntityTypeSubtypeInstanceHasSupertypeInstance" RoleName="EntityTypeSubtypeInstance" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectifyingInstanceHasObjectifiedInstanceRequiredError" RoleName="ObjectifiedInstanceRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="EntityTypeSubtypeInstance" Name="EntityTypeSubtypeInstance" SortChildElements="true" Override="true">
		<se:Link RelationshipName="EntityTypeSubtypeInstanceHasSupertypeInstance" RoleName="SupertypeInstance" Name="SupertypeInstance"/>
		<se:Link Name="ObjectifiedInstance" RelationshipName="ObjectificationInstance" RoleName="ObjectifiedInstance"/>
		<se:Link RelationshipName="EntityTypeRoleInstance" RoleName="Role" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeRoleInstance" RoleName="Role" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectTypeInstanceHasPopulationMandatoryError" RoleName="PopulationMandatoryError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectifyingInstanceHasObjectifiedInstanceRequiredError" RoleName="ObjectifiedInstanceRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="EntityTypeRoleInstance">
		<se:Link RelationshipName="EntityTypeInstanceHasRoleInstance" RoleName="EntityTypeInstance" WriteStyle="NotWritten" />
		<se:Link RelationshipName="RoleInstanceHasPopulationUniquenessError" RoleName="PopulationUniquenessError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="EntityTypeRoleInstanceHasPopulationUniquenessError" RoleName="PopulationUniquenessError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="CustomReferenceMode" SortChildElements="true" Override="true">
		<se:Attribute ID="CustomFormatString" WriteStyle="Element"/>
		<se:Link Name="Kind" RelationshipName="ReferenceModeHasReferenceModeKind" RoleName="Kind"/>
	</se:Element>
	<se:Element Class="ValueTypeHasDataType" LinkOnly="true">
		<se:Attribute ID="Scale" WriteStyle="NotWritten"/>
		<se:Attribute ID="Length" WriteStyle="NotWritten"/>
		<se:Attribute ID="CurrentScale" Name="Scale" WriteCustomStorage="true"/>
		<se:Attribute ID="CurrentLength" Name="Length" WriteCustomStorage="true"/>
		<se:Link RelationshipName="ValueTypeHasUnspecifiedDataTypeError" RoleName="DataTypeNotSpecifiedError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="DataType" Override="true">
		<se:ConditionalSerialization>
			<!-- If the only reference to this type is the aggregating
				 object type, then don't bother to write it out. These
				 are intrinsic types and will reappear when the model file
				 is reloaded. -->
			<plx:return>
				<plx:binaryOperator type="greaterThan">
					<plx:left>
						<plx:callInstance name="Count" type="property">
							<plx:callObject>
								<plx:callStatic name="GetAllElementLinks" dataTypeName="DomainRoleInfo">
									<plx:passParam>
										<plx:thisKeyword/>
									</plx:passParam>
								</plx:callStatic>
							</plx:callObject>
						</plx:callInstance>
					</plx:left>
					<plx:right>
						<plx:value type="i4" data="1"/>
					</plx:right>
				</plx:binaryOperator>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Link RelationshipName="ValueTypeHasDataType" RoleName="ValueType" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ReferenceModeKind" Name="ReferenceModeKind" Override="true">
		<se:Link RelationshipName="ReferenceModeHasReferenceModeKind" RoleName="ReferenceMode" WriteStyle="NotWritten" />
	</se:Element>
	<se:Element Name="BaseValueConstraint" Class="ValueConstraint" SortChildElements="true" Override="true">
		<se:Container Name="Definitions">
			<se:Embed RelationshipName="ValueConstraintHasDefinition" RoleName="Definition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="ValueConstraintHasNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="ValueRanges">
			<se:Embed RelationshipName="ValueConstraintHasValueRange" RoleName="ValueRange"/>
		</se:Container>
		<se:Link RelationshipName="ValueConstraintHasDuplicateNameError" RoleName="DuplicateNameError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ValueConstraintHasValueRangeOverlapError" RoleName="ValueRangeOverlapError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ValueConstraintHasValueTypeDetachedError" RoleName="ValueTypeDetachedError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ValueTypeValueConstraint" Name="ValueConstraint" Override="true"/>
	<se:Element Class="RoleValueConstraint" Name="RoleValueConstraint" Override="true"/>
	<se:Element Class="PathConditionRoleValueConstraint" Name="PathedRoleConditionValueConstraint" Override="true">
		<se:Attribute ID="Name" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="PathConditionRootValueConstraint" Name="PathRootConditionValueConstraint" Override="true">
		<se:Attribute ID="Name" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ValueRange" Override="true">
		<se:Attribute ID="InvariantMaxValue">
			<se:Condition WriteStyle="NotWritten">
				<plx:callStatic name="IsNullOrEmpty" dataTypeName=".string">
					<plx:passParam>
						<plx:callThis name="InvariantMaxValue" type="property"/>
					</plx:passParam>
				</plx:callStatic>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="InvariantMinValue">
			<se:Condition WriteStyle="NotWritten">
				<plx:callStatic name="IsNullOrEmpty" dataTypeName=".string">
					<plx:passParam>
						<plx:callThis name="InvariantMinValue" type="property"/>
					</plx:passParam>
				</plx:callStatic>
			</se:Condition>
		</se:Attribute>
		<se:Link RelationshipName="ValueRangeHasMinValueMismatchError" RoleName="MinValueMismatchError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ValueRangeHasMaxValueMismatchError" RoleName="MaxValueMismatchError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Name="BaseCardinalityConstraint" Class="CardinalityConstraint" SortChildElements="true" Override="true">
		<se:Attribute ID="Modality">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic name="Alethic" type="field" dataTypeName="ConstraintModality"/>
					</plx:left>
					<plx:right>
						<plx:callThis name="Modality" type="property"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="Definitions">
			<se:Embed RelationshipName="CardinalityConstraintHasDefinition" RoleName="Definition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="CardinalityConstraintHasNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="Ranges">
			<se:Embed RelationshipName="CardinalityConstraintHasRange" RoleName="Range"/>
		</se:Container>
		<se:Link RelationshipName="CardinalityConstraintHasDuplicateNameError" RoleName="DuplicateNameError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CardinalityConstraintHasRangeOverlapError" RoleName="CardinalityRangeOverlapError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ObjectTypeCardinalityConstraint" Name="CardinalityConstraint" Override="true"/>
	<se:Element Class="UnaryRoleCardinalityConstraint" Name="UnaryRoleCardinalityConstraint" Override="true"/>
	<se:Element Class="CardinalityRange" Override="true">
		<se:Attribute ID="LowerBound" Name="From"/>
		<se:Attribute ID="UpperBound" Name="To">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callThis name="UpperBound" type="property"/>
					</plx:left>
					<plx:right>
						<plx:value data="-1" type="i4"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
	</se:Element>
	<!--Facts-->
	<se:Element Class="FactType" Name="Fact" SortChildElements="true" Override="true">
		<se:ConditionalName Name="ImpliedFact">
			<plx:binaryOperator type="identityInequality">
				<plx:left>
					<plx:callThis name="ImpliedByObjectification" type="property"/>
				</plx:left>
				<plx:right>
					<plx:nullKeyword/>
				</plx:right>
			</plx:binaryOperator>
		</se:ConditionalName>
		<se:Attribute ID="Name" Name="_Name" WriteCustomStorage="true"/>
		<se:Attribute ID="IsExternal">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsExternal" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="Definitions">
			<se:Embed RelationshipName="FactTypeHasDefinition" RoleName="Definition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="FactTypeHasNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="FactRoles">
			<se:ConditionalName Name="QueryRoles">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:thisKeyword/>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="Subquery"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
			<se:Embed RelationshipName="FactTypeHasRole" RoleName="Role"/>
		</se:Container>
		<se:Container Name="ReadingOrders">
			<se:Embed RelationshipName="FactTypeHasReadingOrder" RoleName="ReadingOrder"/>
		</se:Container>
		<se:Container Name="InternalConstraints">
			<se:Link RelationshipName="FactSetConstraint" RoleName="SetConstraint"/>
		</se:Container>
		<se:Container Name="DerivationRule" SortChildElements="true">
			<!-- UNDONE: File format change, remove derivation expression. -->
			<se:Embed RelationshipName="FactTypeHasDerivationExpression" RoleName="DerivationRule"/>
			<se:Embed RelationshipName="FactTypeHasDerivationRule" RoleName="DerivationRule"/>
		</se:Container>
		<se:Container Name="Instances">
			<se:Embed RelationshipName="FactTypeHasFactTypeInstance" RoleName="FactTypeInstance"/>
		</se:Container>
		<se:Link RelationshipName="FactSetConstraint" RoleName="SetConstraint" WriteStyle="NotWritten">
			<se:ConditionalName Name="UniquenessConstraint" WriteStyle="Element">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic dataTypeName="ConstraintType" name="InternalUniqueness" type="field"/>
					</plx:left>
					<plx:right>
						<plx:callInstance name="ConstraintType" type="property">
							<plx:callObject>
								<plx:cast dataTypeName="IConstraint">
									<plx:callStatic name="GetRolePlayer" dataTypeName="DomainRoleInfo">
										<plx:passParam>
											<plx:nameRef name="elementLink" type="parameter"/>
										</plx:passParam>
										<plx:passParam>
											<plx:callStatic dataTypeName="FactSetConstraint" name="SetConstraintDomainRoleId" type="property"/>
										</plx:passParam>
									</plx:callStatic>
								</plx:cast>
							</plx:callObject>
						</plx:callInstance>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
			<se:ConditionalName Name="MandatoryConstraint" WriteStyle="Element">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic dataTypeName="ConstraintType" name="SimpleMandatory" type="field"/>
					</plx:left>
					<plx:right>
						<plx:callInstance name="ConstraintType" type="property">
							<plx:callObject>
								<plx:cast dataTypeName="IConstraint">
									<plx:callStatic name="GetRolePlayer" dataTypeName="DomainRoleInfo">
										<plx:passParam>
											<plx:nameRef name="elementLink" type="parameter"/>
										</plx:passParam>
										<plx:passParam>
											<plx:callStatic dataTypeName="FactSetConstraint" name="SetConstraintDomainRoleId" type="property"/>
										</plx:passParam>
									</plx:callStatic>
								</plx:cast>
							</plx:callObject>
						</plx:callInstance>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>
		<se:Link Name="ImpliedByObjectification" RelationshipName="ObjectificationImpliesFactType" RoleName="ImpliedByObjectification"/>
		<se:Link RelationshipName="Objectification" RoleName="NestingType" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeHasFactTypeRequiresInternalUniquenessConstraintError" RoleName="InternalUniquenessConstraintRequiredError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeHasFactTypeRequiresReadingError" RoleName="ReadingRequiredError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeHasImpliedInternalUniquenessConstraintError" RoleName="ImpliedInternalUniquenessConstraintError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ModelNoteReferencesFactType" RoleName="Note" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="FactTypeInstance" Name="FactTypeInstance" Override="true">
		<se:Container Name="RoleInstances">
			<se:Link RelationshipName="FactTypeInstanceHasRoleInstance" RoleName="RoleInstance"/>
		</se:Container>
		<se:Link Name="FactTypeRoleInstance" RelationshipName="FactTypeInstanceHasRoleInstance" RoleName="RoleInstance"/>
		<se:Link RelationshipName="EntityTypeRoleInstance" RoleName="Role" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeRoleInstance" RoleName="Role" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeInstanceHasTooFewFactTypeRoleInstancesError" RoleName="TooFewFactTypeRoleInstancesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectificationInstance" RoleName="ObjectifyingInstance" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectifiedInstanceHasObjectifyingInstanceRequiredError" RoleName="ObjectifyingInstanceRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="FactTypeRoleInstance">
		<se:ConditionalSerialization>
			<plx:return>
				<plx:unaryOperator type="booleanNot">
					<plx:callInstance name="IsImplicitBooleanValue" type="property">
						<plx:callObject>
							<plx:callInstance name="RolePlayer" type="property">
								<plx:callObject>
									<plx:callThis name="Role" type="property"/>
								</plx:callObject>
							</plx:callInstance>
						</plx:callObject>
					</plx:callInstance>
				</plx:unaryOperator>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Link RelationshipName="FactTypeInstanceHasRoleInstance" RoleName="FactTypeInstance" WriteStyle="NotWritten" />
		<se:Link RelationshipName="RoleInstanceHasPopulationUniquenessError" RoleName="PopulationUniquenessError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactTypeRoleInstanceHasPopulationUniquenessError" RoleName="PopulationUniquenessError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="Expression" Override="true">
		<se:Attribute ID="Language" WriteStyle="NotWritten"/>
		<se:Attribute ID="Body" WriteStyle="Element"/>
	</se:Element>
	<!-- UNDONE: File format change, remove derivation expression. -->
	<se:Element Class="FactTypeDerivationExpression" Name="DerivationExpression" Override="true"/>
	<se:Element Class="FactTypeDerivationRule" Name="FactTypeDerivationPath" Override="true" SortChildElements="true">
		<se:Attribute ID="DerivationCompleteness">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic name="FullyDerived" type="field" dataTypeName="DerivationCompleteness"/>
					</plx:left>
					<plx:right>
						<plx:callThis name="DerivationCompleteness" type="property"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="DerivationStorage">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic name="NotStored" type="field" dataTypeName="DerivationStorage"/>
					</plx:left>
					<plx:right>
						<plx:callThis name="DerivationStorage" type="property"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="SetProjection">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="SetProjection" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="Name" Name="Name">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="inequality">
					<plx:left>
						<plx:callThis name="DerivationCompleteness" type="property"/>
					</plx:left>
					<plx:right>
						<plx:callStatic dataTypeName="DerivationCompleteness"  name="FullyDerived" type="field"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="ExternalDerivation">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:unaryOperator type="booleanNot">
							<plx:callThis name="ExternalDerivation" type="property"/>
						</plx:unaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:callInstance name="Count" type="property">
									<plx:callObject>
										<plx:callThis name="LeadRolePathCollection" type="property"/>
									</plx:callObject>
								</plx:callInstance>
							</plx:left>
							<plx:right>
								<plx:value data="0" type="i4"/>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="DerivationProjections">
			<se:Link RelationshipName="RoleSetDerivationProjection" RoleName="RolePath"/>
		</se:Container>
		<se:Container Name="InformalRule">
			<se:Embed RelationshipName="FactTypeDerivationRuleHasDerivationNote" RoleName="DerivationNote"/>
		</se:Container>
		<se:Link RelationshipName="RoleSetDerivationProjection" RoleName="RolePath" Name="DerivationProjection" WriteStyle="PrimaryLinkElement"/>
		<se:Link RelationshipName="RoleProjectedDerivationRuleHasProjectionRequiredError" RoleName="ProjectionRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="RoleSetDerivationProjection">
		<se:Link RelationshipName="DerivedRoleProjection" RoleName="ProjectedRole" Name="RoleProjection" WriteStyle="PrimaryLinkElement"/>
		<se:Link RelationshipName="RoleSetDerivationProjectionHasPartialProjectionError" RoleName="PartialProjectionError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="DerivedRoleProjection">
		<se:Attribute ID="IsAutomatic" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsAutomatic" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="DerivationSource">
			<se:Link RelationshipName="DerivedRoleProjectedFromRolePathRoot" RoleName="Source"/>
			<se:Link RelationshipName="DerivedRoleProjectedFromPathedRole" RoleName="Source"/>
			<se:Link RelationshipName="DerivedRoleProjectedFromCalculatedPathValue" RoleName="Source"/>
			<se:Embed RelationshipName="DerivedRoleProjectedFromPathConstant" RoleName="Source"/>
		</se:Container>
		<se:Link RelationshipName="DerivedRoleProjectedFromRolePathRoot" RoleName="Source" Name="PathRoot"/>
		<se:Link RelationshipName="DerivedRoleProjectedFromPathedRole" RoleName="Source" Name="PathedRole"/>
		<se:Link RelationshipName="DerivedRoleProjectedFromCalculatedPathValue" RoleName="Source" Name="CalculatedValue"/>
		<se:Link RelationshipName="DerivedRoleProjectionHasDerivedRoleRequiresCompatibleProjectionError" RoleName="IncompatibleProjectionError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="QueryDerivationRule" Name="QueryDerivationPath" Override="true">
		<se:Container Name="DerivationProjections">
			<se:Link RelationshipName="RoleSetDerivationProjection" RoleName="RolePath"/>
		</se:Container>
		<se:Link RelationshipName="RoleSetDerivationProjection" RoleName="RolePath" Name="DerivationProjection" WriteStyle="PrimaryLinkElement"/>
		<se:Link RelationshipName="RoleProjectedDerivationRuleHasProjectionRequiredError" RoleName="ProjectionRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="SubqueryParameterInputs">
		<se:Link RelationshipName="SubqueryParameterInput" RoleName="Parameter" Name="ParameterInput" WriteStyle="PrimaryLinkElement"/>
	</se:Element>
	<se:Element Class="SubqueryParameterInput">
		<se:Container Name="InputFrom">
			<se:Link RelationshipName="SubqueryParameterInputFromRolePathRoot" RoleName="Source"/>
			<se:Link RelationshipName="SubqueryParameterInputFromPathedRole" RoleName="Source"/>
			<se:Link RelationshipName="SubqueryParameterInputFromCalculatedPathValue" RoleName="Source"/>
			<se:Embed RelationshipName="SubqueryParameterInputFromPathConstant" RoleName="Source"/>
		</se:Container>
		<se:Link RelationshipName="SubqueryParameterInputFromRolePathRoot" RoleName="Source" Name="PathRoot"/>
		<se:Link RelationshipName="SubqueryParameterInputFromPathedRole" RoleName="Source" Name="PathedRole"/>
		<se:Link RelationshipName="SubqueryParameterInputFromCalculatedPathValue" RoleName="Source" Name="CalculatedValue"/>
	</se:Element>
	<se:Element Class="SubtypeDerivationRule" Name="SubtypeDerivationPath" Override="true">
		<se:ConditionalSerialization>
			<plx:comment>We leave this in memory so that a user can easily switch subtypes, but do not serialize it unless we have a current subtype.</plx:comment>
			<plx:return>
				<plx:callInstance name="IsSubtype" type="property">
					<plx:callObject>
						<plx:callThis name="Subtype" type="property"/>
					</plx:callObject>
				</plx:callInstance>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Attribute ID="ExternalDerivation">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:unaryOperator type="booleanNot">
							<plx:callThis name="ExternalDerivation" type="property"/>
						</plx:unaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="inequality">
							<plx:left>
								<plx:callInstance name="Count" type="property">
									<plx:callObject>
										<plx:callThis name="LeadRolePathCollection" type="property"/>
									</plx:callObject>
								</plx:callInstance>
							</plx:left>
							<plx:right>
								<plx:value data="0" type="i4"/>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="DerivationCompleteness">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic name="FullyDerived" type="field" dataTypeName="DerivationCompleteness"/>
					</plx:left>
					<plx:right>
						<plx:callThis name="DerivationCompleteness" type="property"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="DerivationStorage">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic name="NotStored" type="field" dataTypeName="DerivationStorage"/>
					</plx:left>
					<plx:right>
						<plx:callThis name="DerivationStorage" type="property"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="InformalRule">
			<se:Embed RelationshipName="SubtypeDerivationRuleHasDerivationNote" RoleName="DerivationNote"/>
		</se:Container>
	</se:Element>
	<se:Element Class="SubtypeFact" Name="SubtypeFact" Override="true">
		<!-- UNDONE: Remove IsPrimary on next file format change -->
		<se:Attribute ID="IsPrimary" ReadOnly="true"/>
		<se:Attribute ID="ProvidesPreferredIdentifier" Name="PreferredIdentificationPath">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="ProvidesPreferredIdentifier" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
	</se:Element>
	<se:Element Class="QueryBase" SortChildElements="true" Override="true">
		<se:Attribute ID="Name" Name="_Signature" WriteCustomStorage="true"/>
		<se:Container Name="QueryParameters">
			<se:Embed RelationshipName="QueryDefinesParameter" RoleName="Parameter"/>
		</se:Container>
	</se:Element>
	<se:Element Class="QueryParameter" SortChildElements="true" Override="true">
		<se:Link Name="ParameterType" RelationshipName="QueryParameterHasParameterType" RoleName="ParameterType"/>
		<se:Container Name="ParameterBindings">
			<se:Link RelationshipName="QueryParameterBinding" RoleName="RolePath"/>
		</se:Container>
		<se:Link RelationshipName="QueryParameterBinding" RoleName="RolePath" Name="ParameterBinding" WriteStyle="PrimaryLinkElement"/>
		<se:Link RelationshipName="SubqueryParameterInput" RoleName="Inputs" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="QueryParameterBinding" LinkOnly="true">
		<se:Container Name="BoundTo">
			<se:Link RelationshipName="QueryParameterBoundToRolePathRoot" RoleName="Source"/>
			<se:Link RelationshipName="QueryParameterBoundToPathedRole" RoleName="Source"/>
		</se:Container>
		<se:Link RelationshipName="QueryParameterBoundToRolePathRoot" RoleName="Source" Name="PathRoot"/>
		<se:Link RelationshipName="QueryParameterBoundToPathedRole" RoleName="Source" Name="PathedRole"/>
	</se:Element>
	<se:Element Class="Subquery" Name="Subquery" Override="true">
		<se:Link RelationshipName="RolePathOwnerUsesSharedSubquery" RoleName="PathOwner" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="Objectification" LinkOnly="true">
		<se:Attribute ID="IsImplied">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsImplied" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link RelationshipName="ObjectificationImpliesFactType" RoleName="ImpliedFactType" WriteStyle="NotWritten"/>
	</se:Element>
	<!--Readings-->
	<se:Element Class="ReadingOrder" SortChildElements="true" Override="true">
		<se:Container Name="Readings">
			<se:Embed RelationshipName="ReadingOrderHasReading" RoleName="Reading"/>
		</se:Container>
		<se:Container Name="RoleSequence">
			<se:Link RelationshipName="ReadingOrderHasRole" RoleName="Role"/>
		</se:Container>
		<se:Link RelationshipName="ReadingOrderHasRole" RoleName="Role" Name="Role"/>
	</se:Element>
	<se:Element Class="Reading" Override="true">
		<se:Attribute ID="Text" Name="Data" WriteStyle="Element"/>
		<se:Attribute ID="Signature" WriteStyle="NotWritten"/>
		<se:Attribute ID="Language" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ReadingHasTooManyRolesError" RoleName="TooManyRolesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ReadingHasTooFewRolesError" RoleName="TooFewRolesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ReadingHasReadingRequiresUserModificationError" RoleName="RequiresUserModificationError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ReadingHasDuplicateSignatureError" RoleName="DuplicateSignatureError" WriteStyle="NotWritten"/>
	</se:Element>
	<!--Role-->
	<se:Element Class="Role" Override="true" SortChildElements="true">
		<se:Attribute ID="IsMandatory" Name ="_IsMandatory" WriteCustomStorage="true"/>
		<se:Attribute ID="Multiplicity" Name ="_Multiplicity" WriteCustomStorage="true"/>
		<se:Link Name="RolePlayer" RelationshipName="ObjectTypePlaysRole" RoleName="RolePlayer"/>
		<se:Container Name="ValueRestriction">
			<se:Embed RelationshipName="RoleHasValueConstraint" RoleName="ValueConstraint"/>
		</se:Container>
		<se:Container Name="CardinalityRestriction">
			<se:Embed RelationshipName="UnaryRoleHasCardinalityConstraint" RoleName="CardinalityConstraint"/>
		</se:Container>
		<!-- UNDONE: File format change, remove old role path constructs -->
		<se:Container Name="DerivationSource">
			<se:Link RelationshipName="RoleDerivesFromPathedRole_Deprecated" RoleName="Source"/>
			<se:Link RelationshipName="RoleDerivesFromCalculatedPathValue_Deprecated" RoleName="Source"/>
			<se:Embed RelationshipName="RoleDerivesFromPathConstant_Deprecated" RoleName="Source"/>
		</se:Container>
		<se:Container Name="RoleInstances">
			<se:Link RelationshipName="EntityTypeRoleInstance" RoleName="ObjectTypeInstance"/>
			<se:Link RelationshipName="FactTypeRoleInstance" RoleName="ObjectTypeInstance"/>
		</se:Container>
		<se:Link RelationshipName="RoleDerivesFromPathedRole_Deprecated" RoleName="Source" Name="PathedRole"/>
		<se:Link RelationshipName="RoleDerivesFromCalculatedPathValue_Deprecated" RoleName="Source" Name="CalculatedValue"/>
		<se:Link Name="EntityTypeRoleInstance" RelationshipName="EntityTypeRoleInstance" RoleName="ObjectTypeInstance" WriteStyle="PrimaryLinkElement" AllowDuplicates="true"/>
		<se:Link Name="FactTypeRoleInstance" RelationshipName="FactTypeRoleInstance" RoleName="ObjectTypeInstance" WriteStyle="PrimaryLinkElement" AllowDuplicates="true"/>
		<se:Link RelationshipName="RoleProxyHasRole" RoleName="Proxy" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ObjectifiedUnaryRoleHasRole" RoleName="ObjectifiedUnaryRole" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ConstraintRoleSequenceHasRole" RoleName="ConstraintRoleSequence" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ReadingOrderHasRole" RoleName="ReadingOrder" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="RoleHasRolePlayerRequiredError" RoleName="RolePlayerRequiredError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="PathedRole" RoleName="RolePath" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="DerivedRoleProjection" RoleName="DerivationProjection" WriteStyle="NotWritten"/>
	</se:Element>
	<!--RoleProxy-->
	<se:Element Class="RoleProxy" Override="true">
		<se:Link RelationshipName="RoleProxyHasRole" RoleName="TargetRole" Name="Role"/>
		<se:Link RelationshipName="ReadingOrderHasRole" RoleName="ReadingOrder" WriteStyle="NotWritten" />
	</se:Element>
	<!--ObjectifiedUnaryRole-->
	<se:Element Class="ObjectifiedUnaryRole" Override="true">
		<se:Link RelationshipName="ObjectifiedUnaryRoleHasRole" RoleName="TargetRole" Name="UnaryRole"/>
	</se:Element>
	<!--Constraints-->
	<se:Element Class="SetComparisonConstraint" SortChildElements="true" Override="true">
		<se:Attribute ID="Modality">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic name="Alethic" type="field" dataTypeName="ConstraintModality"/>
					</plx:left>
					<plx:right>
						<plx:callThis name="Modality" type="property"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="Definitions">
			<se:Embed RelationshipName="SetComparisonConstraintHasDefinition" RoleName="Definition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="SetComparisonConstraintHasNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="RoleSequences">
			<se:Embed RelationshipName="SetComparisonConstraintHasRoleSequence" RoleName="RoleSequence"/>
		</se:Container>
		<se:Link RelationshipName="SetComparisonConstraintHasCompatibleRolePlayerTypeError" RoleName="CompatibleRolePlayerTypeError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetComparisonConstraintHasTooFewRoleSequencesError" RoleName="TooFewRoleSequencesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetComparisonConstraintHasTooManyRoleSequencesError" RoleName="TooManyRoleSequencesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetComparisonConstraintHasExternalConstraintRoleSequenceArityMismatchError" RoleName="ArityMismatchError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetComparisonConstraintHasImplicationError" RoleName="ImplicationError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetComparisonConstraintHasContradictionError" RoleName="ContradictionError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetComparisonConstraintHasDuplicateNameError" RoleName="DuplicateNameError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetComparisonConstraintHasEqualityOrSubsetImpliedByMandatoryError" RoleName="EqualityOrSubsetImpliedByMandatoryError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ModelNoteReferencesSetComparisonConstraint" RoleName="Note" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ConstraintRoleSequence" LinkOnly="true" Override="true">
		<se:Link RelationshipName="ConstraintRoleSequenceHasJoinPathRequiredError" RoleName="JoinPathRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="SetComparisonConstraintRoleSequence" Name="RoleSequence" SortChildElements="true" Override="true">
		<se:Attribute ID="Name" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ConstraintRoleSequenceHasRole" RoleName="Role" Name="Role" WriteStyle="PrimaryLinkElement"/>
		<se:Container Name="JoinRule">
			<se:Embed RelationshipName="ConstraintRoleSequenceHasJoinPath" RoleName="JoinPath"/>
		</se:Container>
	</se:Element>
	<se:Element Class="SetConstraint" SortChildElements="true" Override="true">
		<se:Attribute ID="Modality">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callStatic name="Alethic" type="field" dataTypeName="ConstraintModality"/>
					</plx:left>
					<plx:right>
						<plx:callThis name="Modality" type="property"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="Definitions">
			<se:Embed RelationshipName="SetConstraintHasDefinition" RoleName="Definition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="SetConstraintHasNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="RoleSequence">
			<se:Link RelationshipName="ConstraintRoleSequenceHasRole" RoleName="Role"/>
			<se:Container Name="JoinRule">
				<se:Embed RelationshipName="ConstraintRoleSequenceHasJoinPath" RoleName="JoinPath"/>
			</se:Container>
		</se:Container>
		<se:Link RelationshipName="ConstraintRoleSequenceHasRole" RoleName="Role" Name="Role" WriteStyle="PrimaryLinkElement"/>
		<se:Link RelationshipName="SetConstraintHasCompatibleRolePlayerTypeError" RoleName="CompatibleRolePlayerTypeError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetConstraintHasTooFewRoleSequencesError" RoleName="TooFewRoleSequencesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetConstraintHasTooManyRoleSequencesError" RoleName="TooManyRoleSequencesError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FactSetConstraint" RoleName="FactType" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetConstraintHasImplicationError" RoleName="ImplicationError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetConstraintHasDuplicateNameError" RoleName="DuplicateNameError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ModelNoteReferencesSetConstraint" RoleName="Note" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ConstraintRoleSequenceHasRole" Name="Role" LinkOnly="true">
		<se:Container Name="ProjectedFrom">
			<se:Link RelationshipName="ConstraintRoleProjectedFromPathedRole_Deprecated" RoleName="Source"/>
			<se:Link RelationshipName="ConstraintRoleProjectedFromCalculatedPathValue_Deprecated" RoleName="Source"/>
			<se:Embed RelationshipName="ConstraintRoleProjectedFromPathConstant_Deprecated" RoleName="Source"/>
		</se:Container>
		<se:Link RelationshipName="ConstraintRoleProjectedFromPathedRole_Deprecated" RoleName="Source" Name="PathedRole"/>
		<se:Link RelationshipName="ConstraintRoleProjectedFromCalculatedPathValue_Deprecated" RoleName="Source" Name="CalculatedValue"/>
		<se:Link RelationshipName="ConstraintRoleProjection" RoleName="JoinPathProjection" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ConstraintRoleSequenceJoinPath" Name="JoinPath" Override="true">
		<se:Attribute ID="IsAutomatic" WriteCustomStorage="true">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsAutomatic" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="JoinPathProjections">
			<se:Link RelationshipName="ConstraintRoleSequenceJoinPathProjection" RoleName="RolePath"/>
		</se:Container>
		<se:Link RelationshipName="ConstraintRoleSequenceJoinPathProjection" RoleName="RolePath" Name="JoinPathProjection" WriteStyle="PrimaryLinkElement"/>
		<se:Link RelationshipName="ConstraintRoleSequenceJoinPathHasProjectionRequiredError" RoleName="ProjectionRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ConstraintRoleSequenceJoinPathProjection">
		<se:Link RelationshipName="ConstraintRoleProjection" RoleName="ProjectedConstraintRole" Name="ConstraintRoleProjection" WriteStyle="PrimaryLinkElement"/>
		<se:Link RelationshipName="ConstraintRoleSequenceProjectionHasPartialProjectionError" RoleName="PartialProjectionError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ConstraintRoleProjection">
		<se:Attribute ID="IsAutomatic">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsAutomatic" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="ProjectedFrom">
			<se:Link RelationshipName="ConstraintRoleProjectedFromRolePathRoot" RoleName="Source"/>
			<se:Link RelationshipName="ConstraintRoleProjectedFromPathedRole" RoleName="Source"/>
			<se:Link RelationshipName="ConstraintRoleProjectedFromCalculatedPathValue" RoleName="Source"/>
			<se:Embed RelationshipName="ConstraintRoleProjectedFromPathConstant" RoleName="Source"/>
		</se:Container>
		<se:Link RelationshipName="ConstraintRoleProjectedFromRolePathRoot" RoleName="Source" Name="PathRoot"/>
		<se:Link RelationshipName="ConstraintRoleProjectedFromPathedRole" RoleName="Source" Name="PathedRole"/>
		<se:Link RelationshipName="ConstraintRoleProjectedFromCalculatedPathValue" RoleName="Source" Name="CalculatedValue"/>
		<se:Link RelationshipName="ConstraintRoleProjectionHasConstraintRoleRequiresCompatibleJoinPathProjectionError" RoleName="IncompatibleProjectionError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="MandatoryConstraint" SortChildElements="true" Override="true">
		<se:Attribute ID="IsSimple">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsSimple" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="IsImplied">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsImplied" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link Name="ImpliedByObjectType" RelationshipName="ObjectTypeImpliesMandatoryConstraint" RoleName="ObjectType"/>
		<se:Link Name="InherentForObjectType" RelationshipName="MandatoryConstraintIsInherentForObjectType" RoleName="ObjectType"/>
		<se:Link RelationshipName="ExclusiveOrConstraintCoupler" RoleName="ExclusionConstraint" Name="ExclusiveOrExclusionConstraint"/>
		<se:Link RelationshipName="MandatoryConstraintHasPopulationMandatoryError" RoleName="PopulationMandatoryError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="MandatoryConstraintHasExclusionContradictsMandatoryError" RoleName="ExclusionContradictsMandatoryError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="MandatoryConstraintHasNotWellModeledSubsetAndMandatoryError" RoleName="NotWellModeledSubsetAndMandatoryError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="FrequencyConstraint" Override="true">
		<se:Link RelationshipName="FrequencyConstraintHasFrequencyConstraintExactlyOneError" RoleName="FrequencyConstraintExactlyOneError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FrequencyConstraintHasFrequencyConstraintNonRestrictiveRangeError" RoleName="FrequencyConstraintNonRestrictiveRangeError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FrequencyConstraintHasFrequencyConstraintMinMaxError" RoleName="FrequencyConstraintMinMaxError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FrequencyConstraintHasFrequencyConstraintViolatedByUniquenessConstraintError" RoleName="FrequencyConstraintViolatedByUniquenessConstraintError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="UniquenessConstraint" Override="true" SortChildElements="true">
		<se:Attribute ID="IsInternal">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsInternal" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link Name="PreferredIdentifierFor" RelationshipName="EntityTypeHasPreferredIdentifier" RoleName="PreferredIdentifierFor"/>
		<se:Link RelationshipName="UniquenessConstraintHasNMinusOneError" RoleName="NMinusOneError" WriteStyle="NotWritten"/>
	</se:Element>

	<se:Element Class="EqualityConstraint" SortChildElements="true" Override="true">
		<se:Link RelationshipName="SetComparisonConstraintHasExclusionContradictsEqualityError" RoleName="ExclusionContradictsEqualityError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ExclusionConstraint" SortChildElements="true" Override="true">
		<se:Link RelationshipName="ExclusiveOrConstraintCoupler" RoleName="MandatoryConstraint" Name="ExclusiveOrMandatoryConstraint"/>
		<se:Link RelationshipName="SetComparisonConstraintHasExclusionContradictsEqualityError" RoleName="ExclusionContradictsEqualityError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SetComparisonConstraintHasExclusionContradictsSubsetError" RoleName="ExclusionContradictsSubsetError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ExclusionConstraintHasExclusionContradictsMandatoryError" RoleName="ExclusionContradictsMandatoryError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="SubsetConstraint" SortChildElements="true" Override="true">
		<se:Link RelationshipName="SetComparisonConstraintHasExclusionContradictsSubsetError" RoleName="ExclusionContradictsSubsetError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SubsetConstraintHasNotWellModeledSubsetAndMandatoryError" RoleName="NotWellModeledSubsetAndMandatoryError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SubsetConstraintHasSupersetRoleOfSubtypeSubsetConstraintNotSubtypeError" RoleName="SupersetRoleOfSubtypeSubsetConstraintNotSubtypeError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="RingConstraint" Override="true">
		<se:Attribute ID="RingType" Name="Type"/>
		<se:Link RelationshipName="RingConstraintHasRingConstraintTypeNotSpecifiedError" RoleName="RingConstraintTypeNotSpecifiedError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ValueComparisonConstraint" Override="true">
		<se:Attribute ID="Operator" Name="Operator"/>
		<se:Link RelationshipName="ValueComparisonConstraintHasOperatorNotSpecifiedError" RoleName="OperatorNotSpecifiedError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ValueComparisonConstraintHasRolesNotComparableError" RoleName="RolesNotComparableError" WriteStyle="NotWritten"/>
	</se:Element>

	<se:Element Class="Function" Override="true">
		<se:ConditionalSerialization>
			<plx:return>
				<plx:binaryOperator type="inequality">
					<plx:left>
						<plx:callInstance name="Count" type="property">
							<plx:callObject>
								<plx:callThis name="CalculatedValueCollection" type="property"/>
							</plx:callObject>
						</plx:callInstance>
					</plx:left>
					<plx:right>
						<plx:value data="0" type="i4"/>
					</plx:right>
				</plx:binaryOperator>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Attribute ID="IsBoolean">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsBoolean" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="IsAggregate" WriteStyle="NotWritten"/>
		<se:Attribute ID="OperatorSymbol">
			<se:Condition WriteStyle="NotWritten">
				<plx:callStatic dataTypeName=".string" name="IsNullOrEmpty">
					<plx:passParam>
						<plx:callThis name="OperatorSymbol" type="property"/>
					</plx:passParam>
				</plx:callStatic>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="Parameters">
			<se:Embed RelationshipName="FunctionOperatesOnParameter" RoleName="Parameter"/>
		</se:Container>
		<se:Link RelationshipName="CalculatedPathValueIsCalculatedWithFunction" RoleName="CalculatedValue" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="FunctionHasDuplicateNameError" RoleName="DuplicateNameError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="FunctionParameter" Name="Parameter" Override="true">
		<se:Attribute ID="BagInput">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="BagInput" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link RelationshipName="CalculatedPathValueInputCorrespondsToFunctionParameter" RoleName="Input" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CalculatedPathValueParameterBindingErrorTargetsFunctionParameter" RoleName="ParameterBindingError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="RolePathOwner" Override="true" SortChildElements="true">
		<!-- UNDONE: File format change, remove old role path constructs (PathComponent, CalculatedValues) -->
		<se:Container Name="PathComponent">
			<se:Embed RelationshipName="RolePathOwnerHasPathComponent_Deprecated" RoleName="RolePath"/>
		</se:Container>
		<se:Container Name="PathComponents" SortChildElements="true">
			<se:Embed RelationshipName="RolePathOwnerOwnsLeadRolePath" RoleName="RolePath"/>
			<se:Link RelationshipName="RolePathOwnerUsesSharedLeadRolePath" RoleName="RolePath"/>
		</se:Container>
		<se:Container Name="CalculatedValues">
			<se:Embed RelationshipName="RolePathOwnerCalculatesCalculatedPathValue_Deprecated" RoleName="CalculatedValue"/>
		</se:Container>
		<se:Container Name="Subqueries" SortChildElements="true">
			<se:Embed RelationshipName="RolePathOwnerOwnsSubquery" RoleName="Subquery"/>
			<se:Link RelationshipName="RolePathOwnerUsesSharedSubquery" RoleName="Subquery"/>
		</se:Container>
		<se:Link RelationshipName="RolePathOwnerUsesSharedLeadRolePath" RoleName="RolePath" Name="SharedRolePath"/>
		<se:Link RelationshipName="RolePathOwnerUsesSharedSubquery" RoleName="Subquery" Name="SharedSubquery"/>
	</se:Element>
	<se:Element Class="LeadRolePath" Override="true" SortChildElements="true" Name="RolePath">
		<se:Container Name="ObjectUnifiers">
			<se:Embed RelationshipName="LeadRolePathHasObjectUnifier" RoleName="ObjectUnifier"/>
		</se:Container>
		<se:Container Name="SubqueryParameterInputs">
			<se:Link RelationshipName="SubqueryParameterInputs" RoleName="PathedEntryRole" />
		</se:Container>
		<se:Container Name="CalculatedValues">
			<se:Embed RelationshipName="LeadRolePathCalculatesCalculatedPathValue" RoleName="CalculatedValue"/>
		</se:Container>
		<se:Container Name="Conditions">
			<se:Link RelationshipName="LeadRolePathSatisfiesCalculatedCondition" RoleName="CalculatedCondition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="LeadRolePathHasNote" RoleName="Note"/>
		</se:Container>
		<se:Link RelationshipName="LeadRolePathSatisfiesCalculatedCondition" RoleName="CalculatedCondition" Name="CalculatedCondition"/>
		<se:Link RelationshipName="RoleSetDerivationProjection" RoleName="DerivationRule" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ConstraintRoleSequenceJoinPathProjection" RoleName="JoinPath" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="RolePathOwnerUsesSharedLeadRolePath" RoleName="PathOwner" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="QueryParameterBinding" RoleName="QueryParameter" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SubqueryParameterInputs" RoleName="PathedEntryRole" Name="SubqueryParameterInputsFor" WriteStyle="PrimaryLinkElement"/>
	</se:Element>
	<se:Element Class="CalculatedPathValue" Name="CalculatedValue" SortChildElements="true" Override="true">
		<se:Attribute ID="UniversalAggregationContext">
			<se:Condition WriteStyle="NotWritten">
				<plx:local name="function" dataTypeName="Function"/>
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:unaryOperator type="booleanNot">
							<plx:callThis name="UniversalAggregationContext" type="property"/>
						</plx:unaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="booleanOr">
							<plx:left>
								<plx:binaryOperator type="identityEquality">
									<plx:left>
										<plx:inlineStatement dataTypeName="Function">
											<plx:assign>
												<plx:left>
													<plx:nameRef name="function"/>
												</plx:left>
												<plx:right>
													<plx:callThis name="Function" type="property"/>
												</plx:right>
											</plx:assign>
										</plx:inlineStatement>
									</plx:left>
									<plx:right>
										<plx:nullKeyword/>
									</plx:right>
								</plx:binaryOperator>
							</plx:left>
							<plx:right>
								<plx:unaryOperator type="booleanNot">
									<plx:callInstance name="IsAggregate" type="property">
										<plx:callObject>
											<plx:nameRef name="function"/>
										</plx:callObject>
									</plx:callInstance>
								</plx:unaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link RelationshipName="CalculatedPathValueIsCalculatedWithFunction" RoleName="Function" Name="Function"/>
		<!-- UNDONE: File format change, remove old role path constructs -->
		<se:Link RelationshipName="CalculatedPathValueScopedWithPathedRole_Deprecated" RoleName="Scope" Name="Scope"/>
		<se:Container Name="AggregationContext" SortChildElements="true">
			<se:Link RelationshipName="CalculatedPathValueAggregationContextIncludesRolePathRoot" RoleName="PathRoot"/>
			<se:Link RelationshipName="CalculatedPathValueAggregationContextIncludesPathedRole" RoleName="PathedRole"/>
		</se:Container>
		<se:Container Name="Inputs">
			<se:Embed RelationshipName="CalculatedPathValueHasInput" RoleName="Input"/>
		</se:Container>
		<se:Link RelationshipName="CalculatedPathValueAggregationContextIncludesRolePathRoot" RoleName="PathRoot" WriteStyle="NotWritten">
			<se:ConditionalName Name="PathRoot" WriteStyle="Element">
				<plx:local name="function" dataTypeName="Function">
					<plx:initialize>
						<plx:callThis name="Function" type="property"/>
					</plx:initialize>
				</plx:local>
				<plx:binaryOperator type="booleanAnd">
					<plx:left>
						<plx:binaryOperator type="identityInequality">
							<plx:left>
								<plx:nameRef name="function"/>
							</plx:left>
							<plx:right>
								<plx:nullKeyword/>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:callInstance name="IsAggregate" type="property">
							<plx:callObject>
								<plx:nameRef name="function"/>
							</plx:callObject>
						</plx:callInstance>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>
		<se:Link RelationshipName="CalculatedPathValueAggregationContextIncludesPathedRole" RoleName="PathedRole" WriteStyle="NotWritten">
			<se:ConditionalName Name="PathedRole" WriteStyle="Element">
				<plx:local name="function" dataTypeName="Function">
					<plx:initialize>
						<plx:callThis name="Function" type="property"/>
					</plx:initialize>
				</plx:local>
				<plx:binaryOperator type="booleanAnd">
					<plx:left>
						<plx:binaryOperator type="identityInequality">
							<plx:left>
								<plx:nameRef name="function"/>
							</plx:left>
							<plx:right>
								<plx:nullKeyword/>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:callInstance name="IsAggregate" type="property">
							<plx:callObject>
								<plx:nameRef name="function"/>
							</plx:callObject>
						</plx:callInstance>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>
		<se:Link RelationshipName="LeadRolePathSatisfiesCalculatedCondition" RoleName="LeadRolePath" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CalculatedPathValueInputBindsToCalculatedPathValue" RoleName="Input" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="DerivedRoleProjectedFromCalculatedPathValue" RoleName="RoleProjection" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ConstraintRoleProjectedFromCalculatedPathValue" RoleName="ConstraintRoleProjection" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SubqueryParameterInputFromCalculatedPathValue" RoleName="ParameterInput" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CalculatedPathValueHasFunctionRequiredError" RoleName="FunctionRequiredError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CalculatedPathValueHasAggregationContextRequiredError" RoleName="AggregationContextRequiredError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CalculatedPathValueHasUnboundParameterError" RoleName="ParameterBindingError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CalculatedPathValueHasConsumptionRequiredError" RoleName="ConsumptionRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="CalculatedPathValueInput" SortChildElements="true" Name="Input" Override="true">
		<se:Attribute ID="DistinctValues">
			<se:Condition WriteStyle="NotWritten">
				<plx:local name="parameter" dataTypeName="FunctionParameter"/>
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:unaryOperator type="booleanNot">
							<plx:callThis name="DistinctValues" type="property"/>
						</plx:unaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="booleanOr">
							<plx:left>
								<plx:binaryOperator type="identityEquality">
									<plx:left>
										<plx:nullKeyword/>
									</plx:left>
									<plx:right>
										<plx:inlineStatement dataTypeName="FunctionParameter">
											<plx:assign>
												<plx:left>
													<plx:nameRef name="parameter"/>
												</plx:left>
												<plx:right>
													<plx:callThis name="Parameter" type="property"/>
												</plx:right>
											</plx:assign>
										</plx:inlineStatement>
									</plx:right>
								</plx:binaryOperator>
							</plx:left>
							<plx:right>
								<plx:unaryOperator type="booleanNot">
									<plx:callInstance name="BagInput" type="property">
										<plx:callObject>
											<plx:nameRef name="parameter"/>
										</plx:callObject>
									</plx:callInstance>
								</plx:unaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link RelationshipName="CalculatedPathValueInputCorrespondsToFunctionParameter" RoleName="Parameter" Name="Parameter"/>
		<se:Container Name="Source">
			<se:Link RelationshipName="CalculatedPathValueInputBindsToRolePathRoot" RoleName="Source"/>
			<se:Link RelationshipName="CalculatedPathValueInputBindsToPathedRole" RoleName="Source"/>
			<se:Link RelationshipName="CalculatedPathValueInputBindsToCalculatedPathValue" RoleName="Source"/>
			<se:Embed RelationshipName="CalculatedPathValueInputBindsToPathConstant" RoleName="Source"/>
		</se:Container>
		<se:Link RelationshipName="CalculatedPathValueInputBindsToRolePathRoot" RoleName="Source" Name="PathRoot"/>
		<se:Link RelationshipName="CalculatedPathValueInputBindsToPathedRole" RoleName="Source" Name="PathedRole"/>
		<se:Link RelationshipName="CalculatedPathValueInputBindsToCalculatedPathValue" RoleName="Source" Name="CalculatedValue"/>
	</se:Element>
	<se:Element Class="PathConstant" Name="Constant" Override="true">
		<se:Attribute ID="LexicalValue" Name="Value" WriteStyle="Element"/>
	</se:Element>
	<se:Element Class="RolePath" SortChildElements="true" Override="true" LinkOnly="true">
		<se:Attribute ID="SplitIsNegated">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:unaryOperator type="booleanNot">
							<plx:callThis name="SplitIsNegated" type="property"/>
						</plx:unaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="lessThanOrEqual">
							<plx:left>
								<plx:callInstance name="Count" type="property">
									<plx:callObject>
										<plx:callThis name="SubPathCollection" type="property"/>
									</plx:callObject>
								</plx:callInstance>
							</plx:left>
							<plx:right>
								<plx:value data="1" type="i4"/>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="SplitCombinationOperator">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="lessThanOrEqual">
					<plx:left>
						<plx:callInstance name="Count" type="property">
							<plx:callObject>
								<plx:callThis name="SubPathCollection" type="property"/>
							</plx:callObject>
						</plx:callInstance>
					</plx:left>
					<plx:right>
						<plx:value data="1" type="i4"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link RelationshipName="RolePathObjectTypeRoot" RoleName="RootObjectType" Name="RootObjectType" WriteStyle="PrimaryLinkElement"/>
		<se:Container Name="PathedRoles">
			<se:Link RelationshipName="PathedRole" RoleName="Role"/>
		</se:Container>
		<se:Container Name="SubPaths">
			<se:Embed RelationshipName="RoleSubPathIsContinuationOfRolePath" RoleName="SubPath"/>
		</se:Container>
		<se:Link RelationshipName="PathedRole" RoleName="Role" Name="PathedRole" WriteStyle="PrimaryLinkElement" AllowDuplicates="true"/>
		<se:Link RelationshipName="RolePathHasRootObjectTypeError" RoleName="RootObjectTypeRequiredError" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="RolePathObjectTypeRoot" Name="RootObjectType">
		<se:Attribute ID="IsNegated">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsNegated" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="ValueRestriction">
			<se:Embed RelationshipName="RolePathRootHasValueConstraint" RoleName="ValueConstraint"/>
		</se:Container>
		<se:Link RelationshipName="CalculatedPathValueInputBindsToRolePathRoot" RoleName="Input" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ConstraintRoleProjectedFromRolePathRoot" RoleName="ConstraintRoleProjection" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="DerivedRoleProjectedFromRolePathRoot" RoleName="RoleProjection" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SubqueryParameterInputFromRolePathRoot" RoleName="ParameterInput" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="PathObjectUnifierUnifiesRolePathRoot" RoleName="ObjectUnifier" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CalculatedPathValueAggregationContextIncludesRolePathRoot" RoleName="CalculatedValue" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="QueryParameterBoundToRolePathRoot" RoleName="ParameterBinding" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="RoleSubPath" Name="SubPath" Override="true"/>
	<se:Element Class="PathedRole" SortChildElements="true">
		<se:Attribute ID="IsNegated">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="IsNegated" type="property"/>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="PathedRolePurpose" Name="Purpose"/>
		<se:Container Name="ValueRestriction">
			<se:Embed RelationshipName="PathedRoleHasValueConstraint" RoleName="ValueConstraint"/>
		</se:Container>
		<se:Link RelationshipName="PathedRoleIsRemotelyCorrelatedWithPathedRole_Deprecated" RoleName="CorrelatingParent" Name="CorrelatedWith"/>
		<se:Link RelationshipName="CalculatedPathValueInputBindsToPathedRole" RoleName="Input" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="DerivedRoleProjectedFromPathedRole" RoleName="RoleProjection" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ConstraintRoleProjectedFromPathedRole" RoleName="ConstraintRoleProjection" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SubqueryParameterInputFromPathedRole" RoleName="ParameterInput" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="PathedRoleHasCompatibleJoinRolePlayerError" RoleName="JoinCompatibilityError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="PathedRoleHasSameFactTypeFollowsJoinError" RoleName="SameFactTypeRoleFollowsJoinError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="PathedRoleHasMandatoryOuterJoinError" RoleName="MandatoryOuterJoinError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="PathObjectUnifierUnifiesPathedRole" RoleName="ObjectUnifier" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="CalculatedPathValueAggregationContextIncludesPathedRole" RoleName="CalculatedValue" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="SubqueryParameterInputs" RoleName="RolePath" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="QueryParameterBoundToPathedRole" RoleName="ParameterBinding" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="PathObjectUnifier" Name="ObjectUnifier" Override="true" SortChildElements="true">
		<se:Link RelationshipName="PathObjectUnifierUnifiesRolePathRoot" RoleName="PathRoot" Name="PathRoot"/>
		<se:Link RelationshipName="PathObjectUnifierUnifiesPathedRole" RoleName="PathedRole" Name="PathedRole"/>
		<se:Link RelationshipName="PathObjectUnifierHasCompatibleObjectTypesError" RoleName="CompatibilityError" WriteStyle="NotWritten"/>
	</se:Element>

	<!--Errors-->
	<se:Element Class="ConstraintDuplicateNameError" Override="true">
		<se:Container Name="Constraints">
			<se:Link RelationshipName="SetComparisonConstraintHasDuplicateNameError" RoleName="SetComparisonConstraint"/>
			<se:Link RelationshipName="SetConstraintHasDuplicateNameError" RoleName="SetConstraint"/>
			<se:Link RelationshipName="ValueConstraintHasDuplicateNameError" RoleName="ValueConstraint"/>
			<se:Link RelationshipName="CardinalityConstraintHasDuplicateNameError" RoleName="CardinalityConstraint"/>
		</se:Container>
		<se:Link RelationshipName="SetComparisonConstraintHasDuplicateNameError" RoleName="SetComparisonConstraint" Name="SetComparisonConstraint"/>
		<se:Link RelationshipName="SetConstraintHasDuplicateNameError" RoleName="SetConstraint" Name="SetConstraint"/>
		<se:Link RelationshipName="ValueConstraintHasDuplicateNameError" RoleName="ValueConstraint" Name="ValueConstraint"/>
		<se:Link RelationshipName="CardinalityConstraintHasDuplicateNameError" RoleName="CardinalityConstraint" Name="CardinalityConstraint"/>
	</se:Element>
	<se:Element Class="ObjectTypeDuplicateNameError" Override="true">
		<se:Container Name="Objects">
			<se:Link RelationshipName="ObjectTypeHasDuplicateNameError" RoleName="ObjectType"/>
		</se:Container>
		<se:Link RelationshipName="ObjectTypeHasDuplicateNameError" RoleName="ObjectType" Name="Object"/>
	</se:Element>
	<se:Element Class="RecognizedPhraseDuplicateNameError" Override="true">
		<se:Container Name="Objects">
			<se:Link RelationshipName="RecognizedPhraseHasDuplicateNameError" RoleName="RecognizedPhrase"/>
		</se:Container>
		<se:Link RelationshipName="RecognizedPhraseHasDuplicateNameError" RoleName="RecognizedPhrase" Name="RecognizedPhrase"/>
	</se:Element>
	<se:Element Class="FunctionDuplicateNameError" Override="true">
		<se:Container Name="Functions">
			<se:Link RelationshipName="FunctionHasDuplicateNameError" RoleName="Function"/>
		</se:Container>
		<se:Link RelationshipName="FunctionHasDuplicateNameError" RoleName="Function" Name="Function"/>
	</se:Element>
	<se:Element Class="DuplicateReadingSignatureError" Override="true">
		<se:Container Name="Readings">
			<se:Link RelationshipName="ReadingHasDuplicateSignatureError" RoleName="Reading"/>
		</se:Container>
		<se:Link RelationshipName="ReadingHasDuplicateSignatureError" RoleName="Reading" Name="Reading"/>
	</se:Element>
	<se:Element Class="EntityTypeRequiresReferenceSchemeError" Override="true">
		<se:Link RelationshipName="ObjectTypeHasEntityTypeRequiresReferenceSchemeError" RoleName="ObjectType" Name="EntityType"/>
	</se:Element>
	<se:Element Class="ExternalConstraintRoleSequenceArityMismatchError" Override="true">
		<se:Link RelationshipName="SetComparisonConstraintHasExternalConstraintRoleSequenceArityMismatchError" RoleName="Constraint" Name="Constraint"/>
	</se:Element>
	<se:Element Class="ImpliedInternalUniquenessConstraintError" Override="true">
		<se:Link RelationshipName="FactTypeHasImpliedInternalUniquenessConstraintError" RoleName="FactType" Name="Fact"/>
	</se:Element>
	<se:Element Class="FactTypeRequiresInternalUniquenessConstraintError" Override="true">
		<se:Link RelationshipName="FactTypeHasFactTypeRequiresInternalUniquenessConstraintError" RoleName="FactType" Name="Fact"/>
	</se:Element>
	<se:Element Class="FactTypeRequiresReadingError" Override="true">
		<se:Link RelationshipName="FactTypeHasFactTypeRequiresReadingError" RoleName="FactType" Name="Fact"/>
	</se:Element>
	<se:Element Class="FrequencyConstraintExactlyOneError" Override="true">
		<se:Link RelationshipName="FrequencyConstraintHasFrequencyConstraintExactlyOneError" RoleName="FrequencyConstraint" Name="FrequencyConstraint"/>
	</se:Element>
	<se:Element Class="FrequencyConstraintNonRestrictiveRangeError" Override="true">
		<se:Link RelationshipName="FrequencyConstraintHasFrequencyConstraintNonRestrictiveRangeError" RoleName="FrequencyConstraint" Name="FrequencyConstraint"/>
	</se:Element>
	<se:Element Class="FrequencyConstraintMinMaxError" Override="true">
		<se:Link RelationshipName="FrequencyConstraintHasFrequencyConstraintMinMaxError" RoleName="FrequencyConstraint" Name="FrequencyConstraint"/>
	</se:Element>
	<se:Element Class="MinValueMismatchError" Override="true">
		<se:Link RelationshipName="ValueRangeHasMinValueMismatchError" RoleName="ValueRange" Name="ValueRange"/>
	</se:Element>
	<se:Element Class="MaxValueMismatchError" Override="true">
		<se:Link RelationshipName="ValueRangeHasMaxValueMismatchError" RoleName="ValueRange" Name="ValueRange"/>
	</se:Element>
	<se:Element Class="ValueRangeOverlapError" Override="true">
		<se:Link RelationshipName="ValueConstraintHasValueRangeOverlapError" RoleName="ValueConstraint" Name="ValueConstraint"/>
	</se:Element>
	<se:Element Class="ValueConstraintValueTypeDetachedError" Name="ValueTypeDetachedError" Override="true">
		<se:Link RelationshipName="ValueConstraintHasValueTypeDetachedError" RoleName="ValueConstraint" Name="ValueConstraint"/>
	</se:Element>
	<se:Element Class="RingConstraintTypeNotSpecifiedError" Override="true">
		<se:Link RelationshipName="RingConstraintHasRingConstraintTypeNotSpecifiedError" RoleName="RingConstraint" Name="RingConstraint"/>
	</se:Element>
	<se:Element Class="ValueComparisonConstraintOperatorNotSpecifiedError" Override="true">
		<se:Link RelationshipName="ValueComparisonConstraintHasOperatorNotSpecifiedError" RoleName="ValueComparisonConstraint" Name="ValueComparisonConstraint"/>
	</se:Element>
	<se:Element Class="ValueComparisonRolesNotComparableError" Override="true">
		<se:Link RelationshipName="ValueComparisonConstraintHasRolesNotComparableError" RoleName="ValueComparisonConstraint" Name="ValueComparisonConstraint"/>
	</se:Element>
	<se:Element Class="CardinalityRangeOverlapError" Override="true">
		<se:Link RelationshipName="CardinalityConstraintHasRangeOverlapError" RoleName="CardinalityConstraint" Name="CardinalityConstraint"/>
	</se:Element>
	<se:Element Class="CompatibleValueTypeInstanceValueError" Override="true">
		<se:ConditionalSerialization>
			<plx:return>
				<plx:callInstance name="ShouldSerialize">
					<plx:callObject>
						<plx:cast dataTypeName="ICustomSerializedElement">
							<plx:callThis name="ValueTypeInstance" type="property"/>
						</plx:cast>
					</plx:callObject>
				</plx:callInstance>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Link RelationshipName="ValueTypeInstanceHasCompatibleValueTypeInstanceValueError" RoleName="ValueTypeInstance" Name="ValueTypeInstance"/>
	</se:Element>
	<se:Element Class="TooFewEntityTypeRoleInstancesError" Override="true">
		<se:Link RelationshipName="EntityTypeInstanceHasTooFewEntityTypeRoleInstancesError" RoleName="EntityTypeInstance" Name="EntityTypeInstance"/>
	</se:Element>
	<se:Element Class="TooFewFactTypeRoleInstancesError" Override="true">
		<se:Link RelationshipName="FactTypeInstanceHasTooFewFactTypeRoleInstancesError" RoleName="FactTypeInstance" Name="FactTypeInstance"/>
	</se:Element>
	<se:Element Class="PopulationMandatoryError" Override="true">
		<se:ConditionalSerialization>
			<plx:return>
				<plx:callInstance name="ShouldSerialize">
					<plx:callObject>
						<plx:cast dataTypeName="ICustomSerializedElement">
							<plx:callThis name="ObjectTypeInstance" type="property"/>
						</plx:cast>
					</plx:callObject>
				</plx:callInstance>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Link RelationshipName="ObjectTypeInstanceHasPopulationMandatoryError" RoleName="ObjectTypeInstance" Name="ObjectTypeInstance"/>
		<se:Link RelationshipName="MandatoryConstraintHasPopulationMandatoryError" RoleName="MandatoryConstraint" Name="MandatoryConstraint"/>
	</se:Element>
	<se:Element Class="ObjectifiedInstanceRequiredError" Override="true">
		<se:ConditionalSerialization>
			<plx:return>
				<plx:callInstance name="ShouldSerialize">
					<plx:callObject>
						<plx:cast dataTypeName="ICustomSerializedElement">
							<plx:callThis name="ObjectTypeInstance" type="property"/>
						</plx:cast>
					</plx:callObject>
				</plx:callInstance>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Link RelationshipName="ObjectifyingInstanceHasObjectifiedInstanceRequiredError" RoleName="ObjectTypeInstance" Name="EntityTypeInstance">
			<se:ConditionalName Name="EntityTypeSubtypeInstance">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:callThis name="ObjectTypeInstance" type="property"/>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="EntityTypeSubtypeInstance"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>
	</se:Element>
	<se:Element Class="ObjectifyingInstanceRequiredError" Override="true">
		<se:Link RelationshipName="ObjectifiedInstanceHasObjectifyingInstanceRequiredError" RoleName="FactTypeInstance" Name="FactTypeInstance"/>
	</se:Element>
	<se:Element Class="PopulationUniquenessError" Override="true">
		<se:Container Name="RoleInstances">
			<se:Link RelationshipName="FactTypeRoleInstanceHasPopulationUniquenessError" RoleName="RoleInstance"/>
			<se:Link RelationshipName="EntityTypeRoleInstanceHasPopulationUniquenessError" RoleName="RoleInstance"/>
		</se:Container>
		<se:Link RelationshipName="FactTypeRoleInstanceHasPopulationUniquenessError" RoleName="RoleInstance" Name="FactTypeRoleInstance"/>
		<se:Link RelationshipName="EntityTypeRoleInstanceHasPopulationUniquenessError" RoleName="RoleInstance" Name="EntityTypeRoleInstance"/>
	</se:Element>
	<se:Element Class="TooFewReadingRolesError" Override="true">
		<se:Link RelationshipName="ReadingHasTooFewRolesError" RoleName="Reading" Name="Reading"/>
	</se:Element>
	<se:Element Class="ReadingRequiresUserModificationError" Override="true">
		<se:Link RelationshipName="ReadingHasReadingRequiresUserModificationError" RoleName="Reading" Name="Reading"/>
	</se:Element>
	<se:Element Class="TooFewRoleSequencesError" Override="true">
		<se:Link RelationshipName="SetComparisonConstraintHasTooFewRoleSequencesError" RoleName="SetComparisonConstraint" Name="SetComparisonConstraint"/>
		<se:Link RelationshipName="SetConstraintHasTooFewRoleSequencesError" RoleName="SetConstraint" Name="SetConstraint"/>
	</se:Element>
	<se:Element Class="TooManyReadingRolesError" Override="true">
		<se:Link RelationshipName="ReadingHasTooManyRolesError" RoleName="Reading" Name="Reading"/>
	</se:Element>
	<se:Element Class="TooManyRoleSequencesError" Override="true">
		<se:Link RelationshipName="SetComparisonConstraintHasTooManyRoleSequencesError" RoleName="SetComparisonConstraint" Name="SetComparisonConstraint"/>
		<se:Link RelationshipName="SetConstraintHasTooManyRoleSequencesError" RoleName="SetConstraint" Name="SetConstraint"/>
	</se:Element>
	<se:Element Class="DataTypeNotSpecifiedError" Override="true">
		<se:Link RelationshipName="ValueTypeHasUnspecifiedDataTypeError" RoleName="ValueTypeHasDataType" Name="ConceptualDataType"/>
	</se:Element>
	<se:Element Class="NMinusOneError" Override="true">
		<se:Link RelationshipName="UniquenessConstraintHasNMinusOneError" RoleName="Constraint" Name="UniquenessConstraint"/>
	</se:Element>
	<se:Element Class="ImplicationError" Override="true">
		<se:Link RelationshipName="SetComparisonConstraintHasImplicationError" RoleName="SetComparisonConstraint" Name="SetComparisonConstraint"/>
		<se:Link RelationshipName="SetConstraintHasImplicationError" RoleName="SetConstraint" Name="SetConstraint"/>
	</se:Element>
	<se:Element Class="ContradictionError" Override="true">
		<se:Container Name="Constraints">
			<se:Link RelationshipName="SetComparisonConstraintHasContradictionError" RoleName="SetComparisonConstraint" CreateAsRelationshipName="SetComparisonConstraintHasExclusionContradictsSubsetError"/>
			<se:Link RelationshipName="SetComparisonConstraintHasContradictionError" RoleName="SetComparisonConstraint" CreateAsRelationshipName="SetComparisonConstraintHasExclusionContradictsEqualityError"/>
		</se:Container>
		<se:Link RelationshipName="SetComparisonConstraintHasContradictionError" RoleName="SetComparisonConstraint" CreateAsRelationshipName="SetComparisonConstraintHasExclusionContradictsEqualityError" Name="EqualityConstraint">
			<se:ConditionalName Name="ExclusionConstraintThatContradictsWithEquality">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:callInstance name="SetComparisonConstraint" type="property">
							<plx:callObject>
								<plx:cast dataTypeName="SetComparisonConstraintHasContradictionError">
									<plx:nameRef name="elementLink" type="parameter"/>
								</plx:cast>
							</plx:callObject>
						</plx:callInstance>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="ExclusionConstraint"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>

		<se:Link RelationshipName="SetComparisonConstraintHasContradictionError" RoleName="SetComparisonConstraint" CreateAsRelationshipName="SetComparisonConstraintHasExclusionContradictsSubsetError" Name="SubsetConstraint">
			<se:ConditionalName Name="ExclusionConstraintThatContradictsWithSubset">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:callInstance name="SetComparisonConstraint" type="property">
							<plx:callObject>
								<plx:cast dataTypeName="SetComparisonConstraintHasContradictionError">
									<plx:nameRef name="elementLink" type="parameter"/>
								</plx:cast>
							</plx:callObject>
						</plx:callInstance>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="ExclusionConstraint"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>

	</se:Element>

	<se:Element Class="ExclusionContradictsEqualityError" Override="true">
		<se:Link RelationshipName="SetComparisonConstraintHasExclusionContradictsEqualityError" RoleName="SetComparisonConstraint" WriteStyle="NotWritten" />
	</se:Element>

	<se:Element Class="ExclusionContradictsSubsetError" Override="true">
		<se:Link RelationshipName="SetComparisonConstraintHasExclusionContradictsSubsetError" RoleName="SetComparisonConstraint" WriteStyle="NotWritten" />
	</se:Element>

	<se:Element Class="ExclusionContradictsMandatoryError" Override="true">
		<se:Container Name="Constraints">
			<se:Link RelationshipName="MandatoryConstraintHasExclusionContradictsMandatoryError" RoleName="MandatoryConstraint"/>
			<se:Link RelationshipName="ExclusionConstraintHasExclusionContradictsMandatoryError" RoleName="ExclusionConstraint"/>
		</se:Container>
		<se:Link RelationshipName="MandatoryConstraintHasExclusionContradictsMandatoryError" RoleName="MandatoryConstraint" Name="MandatoryConstraint"/>
		<se:Link RelationshipName="ExclusionConstraintHasExclusionContradictsMandatoryError" RoleName="ExclusionConstraint" Name="ExclusionConstraint"/>
	</se:Element>

	<se:Element Class="NotWellModeledSubsetAndMandatoryError" Override="true">
		<se:Container Name="Constraints">
			<se:Link RelationshipName="MandatoryConstraintHasNotWellModeledSubsetAndMandatoryError" RoleName="MandatoryConstraint"/>
			<se:Link RelationshipName="SubsetConstraintHasNotWellModeledSubsetAndMandatoryError" RoleName="SubsetConstraint"/>
		</se:Container>
		<se:Link RelationshipName="SubsetConstraintHasNotWellModeledSubsetAndMandatoryError" RoleName="SubsetConstraint" Name="SubsetConstraint"/>
		<se:Link RelationshipName="MandatoryConstraintHasNotWellModeledSubsetAndMandatoryError" RoleName="MandatoryConstraint" Name="MandatoryConstraint"/>
	</se:Element>
	<se:Element Class="PreferredIdentifierRequiresMandatoryError" Override="true">
		<se:Link RelationshipName="ObjectTypeHasPreferredIdentifierRequiresMandatoryError" RoleName="ObjectType" Name="ObjectType"/>
	</se:Element>
	<se:Element Class="CompatibleSupertypesError" Override="true">
		<se:Link RelationshipName="ObjectTypeHasCompatibleSupertypesError" RoleName="ObjectType" Name="ObjectType"/>
	</se:Element>
	<se:Element Class="CompatibleRolePlayerTypeError" Override="true">
		<se:Attribute ID="Column">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="identityInequality">
					<plx:left>
						<plx:callThis name="SetConstraint" type="property"/>
					</plx:left>
					<plx:right>
						<plx:nullKeyword/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Link RelationshipName="SetComparisonConstraintHasCompatibleRolePlayerTypeError" RoleName="SetComparisonConstraint" Name="SetComparisonConstraint"/>
		<se:Link RelationshipName="SetConstraintHasCompatibleRolePlayerTypeError" RoleName="SetConstraint" Name="SetConstraint"/>
	</se:Element>
	<se:Element Class="SupersetRoleOfSubtypeSubsetConstraintNotSubtypeError" Override="true">
		<se:Link RelationshipName="SubsetConstraintHasSupersetRoleOfSubtypeSubsetConstraintNotSubtypeError" RoleName="SubsetConstraint" Name="SubsetConstraint"/>
	</se:Element>
	<se:Element Class="JoinPathRequiredError" Override="true">
		<se:Link RelationshipName="ConstraintRoleSequenceHasJoinPathRequiredError" RoleName="RoleSequence" Name="ConstraintRoleSequence"/>
	</se:Element>
	<se:Element Class="RolePlayerRequiredError" Override="true">
		<se:Link RelationshipName="RoleHasRolePlayerRequiredError" RoleName="Role" Name="Role"/>
	</se:Element>
	<se:Element Class="FrequencyConstraintViolatedByUniquenessConstraintError" Override="true">
		<se:Link RelationshipName="FrequencyConstraintHasFrequencyConstraintViolatedByUniquenessConstraintError" RoleName="FrequencyConstraint" Name="FrequencyConstraint"/>
	</se:Element>
	<se:Element Class="EqualityOrSubsetImpliedByMandatoryError" Name="EqualityConstraintImpliedByMandatoryConstraintsError" Override="true">
		<se:ConditionalName Name="SubsetConstraintImpliedByMandatoryConstraintsError">
			<plx:binaryOperator type="typeEquality">
				<plx:left>
					<plx:callThis name="EqualityOrSubsetConstraint" type="property"/>
				</plx:left>
				<plx:right>
					<plx:directTypeReference dataTypeName="SubsetConstraint"/>
				</plx:right>
			</plx:binaryOperator>
		</se:ConditionalName>
		<se:Link RelationshipName="SetComparisonConstraintHasEqualityOrSubsetImpliedByMandatoryError" RoleName="SetComparisonConstraint" Name="EqualityConstraint">
			<se:ConditionalName Name="SubsetConstraint">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:callInstance name="SetComparisonConstraint" type="property">
							<plx:callObject>
								<plx:cast dataTypeName="SetComparisonConstraintHasEqualityOrSubsetImpliedByMandatoryError">
									<plx:nameRef name="elementLink" type="parameter"/>
								</plx:cast>
							</plx:callObject>
						</plx:callInstance>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="SubsetConstraint"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>
		<se:Link RelationshipName="SetComparisonConstraintHasImplicationError" RoleName="SetComparisonConstraint" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="PathRequiresRootObjectTypeError" Override="true">
		<se:Link RelationshipName="RolePathHasRootObjectTypeError" RoleName="RolePath" Name="RolePath">
			<se:ConditionalName Name="SubPath">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:callThis name="RolePath" type="property"/>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="RoleSubPath"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>
	</se:Element>
	<se:Element Class="JoinedPathRoleRequiresCompatibleRolePlayerError" Override="true">
		<se:Link RelationshipName="PathedRoleHasCompatibleJoinRolePlayerError" RoleName="PathedRole" Name="PathedRole"/>
	</se:Element>
	<se:Element Class="PathObjectUnifierRequiresCompatibleObjectTypesError" Override="true" Name="ObjectUnifierRequiresCompatibleObjectTypesError">
		<se:Link RelationshipName="PathObjectUnifierHasCompatibleObjectTypesError" RoleName="ObjectUnifier" Name="ObjectUnifier"/>
	</se:Element>
	<se:Element Class="PathSameFactTypeRoleFollowsJoinError" Override="true">
		<se:Link RelationshipName="PathedRoleHasSameFactTypeFollowsJoinError" RoleName="PathedRole" Name="PathedRole"/>
	</se:Element>
	<se:Element Class="PathOuterJoinRequiresOptionalRoleError" Override="true">
		<se:Link RelationshipName="PathedRoleHasMandatoryOuterJoinError" RoleName="PathedRole" Name="PathedRole"/>
	</se:Element>
	<se:Element Class="CalculatedPathValueRequiresFunctionError" Override="true">
		<se:Link RelationshipName="CalculatedPathValueHasFunctionRequiredError" RoleName="CalculatedPathValue" Name="CalculatedValue"/>
	</se:Element>
	<se:Element Class="CalculatedPathValueRequiresAggregationContextError" Override="true">
		<se:Link RelationshipName="CalculatedPathValueHasAggregationContextRequiredError" RoleName="CalculatedPathValue" Name="CalculatedValue"/>
	</se:Element>
	<se:Element Class="CalculatedPathValueMustBeConsumedError" Override="true">
		<se:Link RelationshipName="CalculatedPathValueHasConsumptionRequiredError" RoleName="CalculatedPathValue" Name="CalculatedValue"/>
	</se:Element>
	<se:Element Class="CalculatedPathValueParameterBindingError" Override="true">
		<se:Link RelationshipName="CalculatedPathValueHasUnboundParameterError" RoleName="CalculatedPathValue" Name="CalculatedValue" WriteStyle="PrimaryLinkElement"/>
	</se:Element>
	<se:Element Class="CalculatedPathValueHasUnboundParameterError">
		<se:Link RelationshipName="CalculatedPathValueParameterBindingErrorTargetsFunctionParameter" RoleName="Parameter" Name="Parameter"/>
	</se:Element>
	<se:Element Class="RoleProjectedDerivationRequiresProjectionError" Override="true" Name="FactTypeDerivationRequiresProjectionError">
		<se:ConditionalName Name="QueryDerivationRequiresProjectionError">
			<plx:binaryOperator type="typeEquality">
				<plx:left>
					<plx:callThis type="property" name="DerivationRule"/>
				</plx:left>
				<plx:right>
					<plx:directTypeReference dataTypeName="QueryDerivationRule"/>
				</plx:right>
			</plx:binaryOperator>
		</se:ConditionalName>
		<se:Link RelationshipName="RoleProjectedDerivationRuleHasProjectionRequiredError" RoleName="DerivationRule" Name="FactTypeDerivationPath">
			<se:ConditionalName Name="QueryDerivationPath">
				<plx:binaryOperator type="typeEquality">
					<plx:left>
						<plx:callThis type="property" name="DerivationRule"/>
					</plx:left>
					<plx:right>
						<plx:directTypeReference dataTypeName="QueryDerivationRule"/>
					</plx:right>
				</plx:binaryOperator>
			</se:ConditionalName>
		</se:Link>
	</se:Element>
	<se:Element Class="PartialRoleSetDerivationProjectionError" Override="true" Name="PartialFactTypeDerivationProjectionError">
		<se:ConditionalName Name="PartialQueryDerivationProjectionError">
			<plx:binaryOperator type="typeEquality">
				<plx:left>
					<plx:callInstance type="property" name="DerivationRule">
						<plx:callObject>
							<plx:callThis type="property" name="DerivationProjection"/>
						</plx:callObject>
					</plx:callInstance>
				</plx:left>
				<plx:right>
					<plx:directTypeReference dataTypeName="QueryDerivationRule"/>
				</plx:right>
			</plx:binaryOperator>
		</se:ConditionalName>
		<se:Link RelationshipName="RoleSetDerivationProjectionHasPartialProjectionError" RoleName="DerivationProjection" Name="DerivationProjection"/>
	</se:Element>
	<se:Element Class="DerivedRoleRequiresCompatibleProjectionError" Name="DerivedFactTypeRoleProjectionCompatibilityError" Override="true">
		<se:ConditionalName Name="QueryRoleProjectionCompatibilityError">
			<plx:binaryOperator type="typeEquality">
				<plx:left>
					<plx:callInstance type="property" name="DerivationRule">
						<plx:callObject>
							<plx:callInstance type="property" name="DerivationProjection">
								<plx:callObject>
									<plx:callThis type="property" name="Projection"/>
								</plx:callObject>
							</plx:callInstance>
						</plx:callObject>
					</plx:callInstance>
				</plx:left>
				<plx:right>
					<plx:directTypeReference dataTypeName="QueryDerivationRule"/>
				</plx:right>
			</plx:binaryOperator>
		</se:ConditionalName>
		<se:Link RelationshipName="DerivedRoleProjectionHasDerivedRoleRequiresCompatibleProjectionError" RoleName="Projection" Name="DerivedRoleProjection"/>
	</se:Element>
	<se:Element Class="ConstraintRoleSequenceJoinPathRequiresProjectionError" Name="JoinPathRequiresProjectionError" Override="true">
		<se:Link RelationshipName="ConstraintRoleSequenceJoinPathHasProjectionRequiredError" RoleName="JoinPath" Name="JoinPath"/>
	</se:Element>
	<se:Element Class="PartialConstraintRoleSequenceJoinPathProjectionError" Name="PartialJoinPathProjectionError" Override="true">
		<se:Link RelationshipName="ConstraintRoleSequenceProjectionHasPartialProjectionError" RoleName="JoinPathProjection" Name="JoinPathProjection"/>
	</se:Element>
	<se:Element Class="ConstraintRoleRequiresCompatibleJoinPathProjectionError" Name="JoinedConstraintRoleProjectionCompatibilityError" Override="true">
		<se:Link RelationshipName="ConstraintRoleProjectionHasConstraintRoleRequiresCompatibleJoinPathProjectionError" RoleName="Projection" Name="ConstraintRoleProjection"/>
	</se:Element>

	<!-- Grouping constructs -->
	<se:Element Class="ElementGroupingSet" Name="Grouping" SortChildElements="true" Sealed="true">
		<se:Link RelationshipName="ElementGroupingSetRelatesToORMModel" RoleName="Model" Name="ORMModel"/>
		<se:Container Name="Groups">
			<se:Embed RelationshipName="ElementGroupingSetContainsElementGrouping" RoleName="Grouping"/>
		</se:Container>
	</se:Element>
	<se:Element Class="ElementGrouping" Override="true" Name="Group" SortChildElements="true">
		<se:Attribute ID="TypeCompliance">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callThis name="TypeCompliance" type="property"/>
					</plx:left>
					<plx:right>
						<plx:callStatic dataTypeName="GroupingMembershipTypeCompliance" name="NotExcluded" type="field"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="Priority">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callThis name="Priority" type="property"/>
					</plx:left>
					<plx:right>
						<plx:value data="0" type="i4"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Container Name="Definitions">
			<se:Embed RelationshipName="ElementGroupingHasDefinition" RoleName="Definition"/>
		</se:Container>
		<se:Container Name="Notes">
			<se:Embed RelationshipName="ElementGroupingHasNote" RoleName="Note"/>
		</se:Container>
		<se:Container Name="GroupTypes">
			<se:Embed RelationshipName="ElementGroupingIsOfElementGroupingType" RoleName="GroupingType"/>
		</se:Container>
		<se:Container Name="Elements" SortChildElements="true">
			<se:Link RelationshipName="GroupingElementInclusion" RoleName="IncludedElement"/>
			<se:Link RelationshipName="GroupingElementExclusion" RoleName="ExcludedElement"/>
		</se:Container>
		<se:Container Name="NestedGroups" SortChildElements="true">
			<se:Link RelationshipName="ElementGroupingIncludesElementGrouping" RoleName="IncludedChildGrouping"/>
			<se:Link RelationshipName="ElementGroupingExcludesElementGrouping" RoleName="ExcludedChildGrouping"/>
		</se:Container>
		<se:Link RelationshipName="GroupingElementInclusion" RoleName="IncludedElement" Name="IncludedElement"/>
		<se:Link RelationshipName="GroupingElementExclusion" RoleName="ExcludedElement" Name="ExcludedElement"/>
		<se:Link RelationshipName="ElementGroupingIncludesElementGrouping" RoleName="IncludedChildGrouping" Name="IncludedGroup"/>
		<se:Link RelationshipName="ElementGroupingExcludesElementGrouping" RoleName="ExcludedChildGrouping" Name="ExcludedGroup"/>
		<se:Link RelationshipName="ElementGroupingHasDuplicateNameError" RoleName="DuplicateNameError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ElementGroupingHasMembershipContradictionError" RoleName="MembershipContradictionError" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ElementGroupingIncludesElementGrouping" RoleName="ParentGrouping" WriteStyle="NotWritten"/>
		<se:Link RelationshipName="ElementGroupingExcludesElementGrouping" RoleName="ParentGrouping" WriteStyle="NotWritten"/>
	</se:Element>
	<se:Element Class="ElementGroupingDuplicateNameError" Override="true" Name="GroupDuplicateNameError">
		<se:Container Name="Groups">
			<se:Link RelationshipName="ElementGroupingHasDuplicateNameError" RoleName="Grouping"/>
		</se:Container>
		<se:Link RelationshipName="ElementGroupingHasDuplicateNameError" RoleName="Grouping" Name="Group"/>
	</se:Element>
	<se:Element Class="ElementGroupingMembershipContradictionError" Override="true" Name="GroupMembershipContradictionError" SortChildElements="true">
		<se:Link RelationshipName="ElementGroupingHasMembershipContradictionError" RoleName="Grouping" Name="Group" WriteStyle="PrimaryLinkElement"/>
	</se:Element>
	<se:Element Class="ElementGroupingHasMembershipContradictionError" LinkOnly="true">
		<se:Link RelationshipName="GroupingMembershipContradictionErrorIsForElement" RoleName="Element" Name="Element"/>
	</se:Element>
	<se:Element Class="ReferenceModeNaming" Name="ReferenceModeNamingBase">
		<se:ConditionalSerialization>
			<plx:local name="objectType" dataTypeName="ObjectType"/>
			<plx:return>
				<plx:binaryOperator type="booleanOr">
					<plx:left>
						<plx:binaryOperator type="booleanOr">
							<plx:left>
								<plx:callThis name="UsesCustomFormat">
									<plx:passParam>
										<plx:callStatic name="ReferenceToEntityType" dataTypeName="ReferenceModeNamingUse" type="field"/>
									</plx:passParam>
									<plx:passParam>
										<plx:trueKeyword/>
									</plx:passParam>
								</plx:callThis>
							</plx:left>
							<plx:right>
								<plx:callThis name="UsesCustomFormat">
									<plx:passParam>
										<plx:callStatic name="PrimaryIdentifier" dataTypeName="ReferenceModeNamingUse" type="field"/>
									</plx:passParam>
									<plx:passParam>
										<plx:trueKeyword/>
									</plx:passParam>
								</plx:callThis>
							</plx:right>
						</plx:binaryOperator>
					</plx:left>
					<plx:right>
						<plx:binaryOperator type="booleanAnd">
							<plx:left>
								<plx:binaryOperator type="booleanOr">
									<plx:left>
										<plx:binaryOperator type="inequality">
											<plx:left>
												<plx:callThis name="NamingChoice" type="property"/>
											</plx:left>
											<plx:right>
												<plx:callStatic dataTypeName="ReferenceModeNamingChoice" name="ModelDefault" type="field"/>
											</plx:right>
										</plx:binaryOperator>
									</plx:left>
									<plx:right>
										<plx:binaryOperator type="inequality">
											<plx:left>
												<plx:callThis name="PrimaryIdentifierNamingChoice" type="property"/>
											</plx:left>
											<plx:right>
												<plx:callStatic dataTypeName="ReferenceModeNamingChoice" name="ModelDefault" type="field"/>
											</plx:right>
										</plx:binaryOperator>
									</plx:right>
								</plx:binaryOperator>
							</plx:left>
							<plx:right>
								<plx:binaryOperator type="booleanAnd">
									<plx:left>
										<plx:binaryOperator type="identityInequality">
											<plx:left>
												<plx:inlineStatement dataTypeName="ObjectType">
													<plx:assign>
														<plx:left>
															<plx:nameRef name="objectType"/>
														</plx:left>
														<plx:right>
															<plx:callThis name="ResolvedObjectType" type="property"/>
														</plx:right>
													</plx:assign>
												</plx:inlineStatement>
											</plx:left>
											<plx:right>
												<plx:nullKeyword/>
											</plx:right>
										</plx:binaryOperator>
									</plx:left>
									<plx:right>
										<plx:binaryOperator type="identityInequality">
											<plx:left>
												<plx:callInstance name="ReferenceModePattern" type="property">
													<plx:callObject>
														<plx:nameRef name="objectType"/>
													</plx:callObject>
												</plx:callInstance>
											</plx:left>
											<plx:right>
												<plx:nullKeyword/>
											</plx:right>
										</plx:binaryOperator>
									</plx:right>
								</plx:binaryOperator>
							</plx:right>
						</plx:binaryOperator>
					</plx:right>
				</plx:binaryOperator>
			</plx:return>
		</se:ConditionalSerialization>
		<se:Attribute ID="NamingChoice">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callThis name="NamingChoice" type="property"/>
					</plx:left>
					<plx:right>
						<plx:callStatic dataTypeName="ReferenceModeNamingChoice" name="ModelDefault" type="field"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="PrimaryIdentifierNamingChoice">
			<se:Condition WriteStyle="NotWritten">
				<plx:binaryOperator type="equality">
					<plx:left>
						<plx:callThis name="PrimaryIdentifierNamingChoice" type="property"/>
					</plx:left>
					<plx:right>
						<plx:callStatic dataTypeName="ReferenceModeNamingChoice" name="ModelDefault" type="field"/>
					</plx:right>
				</plx:binaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="CustomFormat">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="UsesCustomFormat">
						<plx:passParam>
							<plx:callStatic name="ReferenceToEntityType" dataTypeName="ReferenceModeNamingUse" type="field"/>
						</plx:passParam>
						<plx:passParam>
							<plx:trueKeyword/>
						</plx:passParam>
					</plx:callThis>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
		<se:Attribute ID="PrimaryIdentifierCustomFormat">
			<se:Condition WriteStyle="NotWritten">
				<plx:unaryOperator type="booleanNot">
					<plx:callThis name="UsesCustomFormat">
						<plx:passParam>
							<plx:callStatic name="PrimaryIdentifier" dataTypeName="ReferenceModeNamingUse" type="field"/>
						</plx:passParam>
						<plx:passParam>
							<plx:trueKeyword/>
						</plx:passParam>
					</plx:callThis>
				</plx:unaryOperator>
			</se:Condition>
		</se:Attribute>
	</se:Element>
	<se:Element Class="DefaultReferenceModeNaming" Name="DefaultReferenceModeNamingBase">
		<!--<se:Attribute ID="NamingChoice"/> not needed for default serialization-->
		<se:Attribute ID="ReferenceModeTargetKind" Name="TargetKind"/>
		<se:Attribute ID="CustomFormat">
			<se:Condition WriteStyle="NotWritten">
				<plx:callStatic name="IsNullOrEmpty" dataTypeName=".string">
					<plx:passParam>
						<plx:callThis name="CustomFormat" type="property"/>
					</plx:passParam>
				</plx:callStatic>
			</se:Condition>
		</se:Attribute>
	</se:Element>
</se:CustomSerializedElements>
