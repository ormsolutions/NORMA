<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="VerbalizationDocumentationHTML.xslt"?>
<snippets>
  <snippet name="Acyclicity" replacementCount="2">
    <statement>Description: Used to verbalize acyclic ring constraint in the majority of cases.
Format: No {0} may cycle back to itself via one or more traversals through {1}</statement>
    <unformattedSnippet>no {0} may cycle back to itself via one or more traversals through {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="AcyclicRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="AcyclicityWithRoleNumbers" replacementCount="4">
    <statement>Description: Used to verbalize acyclic ring constraints where more than two roles have a role player of the constrained type.
Format: No {0} may cycle back to itself via one or more instances of the role pair: roles {2} and {3} of {1}</statement>
    <unformattedSnippet>no {0} may cycle back to itself via one or more instances of the role pair:roles {2} and {3} of {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="AcyclicRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="AggregateBagProjection" replacementCount="1">
    <statement>Description: Leave aggregate parameter inputs as a bag of values.
Format: each {0}</statement>
    <unformattedSnippet>each {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AggregateParameterComplexAggregationContextListClose" replacementCount="0">
    <statement>Description: The closing of a composite aggregation list.
Format: combination</statement>
    <unformattedSnippet> combination</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AggregateParameterComplexAggregationContextListOpen" replacementCount="0">
    <statement>Description:The opening of a composite aggregation list.
Format: each</statement>
    <unformattedSnippet>each unique </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AggregateParameterComplexAggregationContextListSeparator" replacementCount="0">
    <statement>Description: The separator of a composite aggregation list.
Format: ,</statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AggregateParameterDecorator" replacementCount="2">
    <statement>Description: Decorate a single or complex aggregation context.
Format: {0} of {1}</statement>
    <unformattedSnippet>{0} for  {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AggregateParameterSimpleAggregationContext" replacementCount="1">
    <statement>Description: Provide a description of a single aggregation context.
Format: each {0}</statement>
    <unformattedSnippet>that {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AggregateSetProjection" replacementCount="1">
    <statement>Description: Limit values from an aggregate parameter input to distinct values.
Format: each distinct {0}</statement>
    <unformattedSnippet>each distinct {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndLeadListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndLeadListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndLeadListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndNestedListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndNestedListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndNestedListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndNestedListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndTailListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndTailListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndTailListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>where </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AndTailListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="AtMostOneQuantifier" replacementCount="1">
    <statement>Description: Used for 'at most one' before an object name to signify the quantity may only be zero or one.  Format: at most one {0}</statement>
    <unformattedSnippet>at most one {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="AtMostOneTypedOccurrence" replacementCount="1">
    <statement>Description: Used for a single-role frequency constraint with min=max=1.
Format: at most one {0}</statement>
    <unformattedSnippet>at most one {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CardinalityMultipleInstances" replacementCount="1">
    <statement>Description: Replaces the last phrase in cardinality statements if multiple instances are specified:
Format: {0} instances</statement>
    <unformattedSnippet>{0} instances</unformattedSnippet>
    <contains>
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ObjectTypeCardinality" />
    </containedIn>
    <usedBy>
      <constraint name="ObjectTypeCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CardinalitySingleInstance" replacementCount="1">
    <statement>Description: Replaces the last phrase in cardinality statements if a single instance is specified:
Format: {0} instance</statement>
    <unformattedSnippet>{0} instance</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ObjectTypeCardinality" />
    </containedIn>
    <usedBy>
      <constraint name="ObjectTypeCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ChainedListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListCollapsedSeparator" replacementCount="0">
    <statement>Description: The text for a collapsed separator in a chained list. Generally just a space.</statement>
    <unformattedSnippet> </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListComplexRestrictionBackReferenceSeparator" replacementCount="0">
    <statement>Description: A separator for a chained list where the chained restriction introduces additional
fact statements and the start of the next statement is a back reference.
See ChainedListComplexRestrictionSeparator for additional comments.
Format: \n </statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListComplexRestrictionCollapsedLeadSeparator" replacementCount="0">
    <statement>Description: Used in place of the ChainedListComplexRestrictionSeparator if the lead role player of
a chained list is the same as the previous statement. Chained lists can collapse the lead role if the list type is
listed in the RolePathCollapsibleLeadDirective snippet.
Format: \n\t and</statement>
    <unformattedSnippet>and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListComplexRestrictionSeparator" replacementCount="0">
    <statement>Description: A separator for a chained list where the chained restriction introduces
additional fact statements. Note that the complex restriction separator is not used before a TailListOpen of
an operator separated list, which is any split list not specific in the RolePathHeaderListDirective snippet.
Format: \n\t where</statement>
    <unformattedSnippet>where </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListLocalRestrictionBackReferenceSeparator" replacementCount="0">
    <statement>Description: A separator for a chained list where the chained restriction applies only
to elements contained in the preceding fact statement and the start of the next statement is a back reference.</statement>
    <unformattedSnippet> </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListLocalRestrictionSeparator" replacementCount="0">
    <statement>Description: A separator for a chained list where the chained restriction applies only
to elements contained in the preceding fact statement.
Format: where</statement>
    <unformattedSnippet> where </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListOpen" replacementCount="0">
    <statement>Description: The opening text for a chained list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListTopLevelComplexRestrictionBackReferenceSeparator" replacementCount="0">
    <statement>Description: The same as ChainedListComplexRestrictionBackReferenceSeparator, except used for a
top-level restriction. If the non-top-level separator includes an indentation, then this separator should omit the indent.
Format: \n and</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListTopLevelComplexRestrictionCollapsedLeadSeparator" replacementCount="0">
    <statement>Description: The same as ChainedListComplexRestrictionCollapsedLeadSeparator, except used for a
top-level restriction. If the non-top-level separator includes an indentation, then this separator should omit the indent.
Format: \n and</statement>
    <unformattedSnippet>and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ChainedListTopLevelComplexRestrictionSeparator" replacementCount="0">
    <statement>Description: The same as ChainedListComplexRestrictionSeparator, except used for a top-level
restriction. If the non-top-level separator includes an indentation, then this separator should omit the indent.
Format: \n where</statement>
    <unformattedSnippet>where </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="CloseVerbalizationSentence" replacementCount="0">
    <statement>Description: Text used to close a verbalized sentence.  Format: .</statement>
    <unformattedSnippet>.</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="CombinationIdentifier" replacementCount="1">
    <statement>Description: Verbalizes a combination.  Format: {0} combination</statement>
    <unformattedSnippet>{0} combination</unformattedSnippet>
    <contains>
      <snippet name="IdentityReferenceQuantifier" />
      <snippet name="UniversalQuantifier" />
    </contains>
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="FrequencyPopulation" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ModalPossibilityOperator" />
      <snippet name="MoreThanOneQuantifier" />
      <snippet name="OccursInPopulation" />
      <snippet name="SingularExistenceImplicationOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="CombinationUniqueness" replacementCount="1">
    <statement>Description: Verbalizes uniqueness of a combination.  Format: {0} combination is unique</statement>
    <unformattedSnippet>{0} combination is unique</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="CombinedObjectAndInstance" replacementCount="2">
    <statement>Description: Used to combine an object and an instance. Format: {0} {1}</statement>
    <unformattedSnippet>{0} {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="CombinedObjectAndInstanceTypeMissing" replacementCount="1">
    <statement>Description: Used to say an object and instance combination is missing. Format: Missing {0}</statement>
    <unformattedSnippet>Missing {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="CompactSimpleListClose" replacementCount="0">
    <statement>Description: Text used at the end of a compact simple list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPreferredVerbalizer" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in a compact simple list.  Format: ,</statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPreferredVerbalizer" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of a compact simple list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPreferredVerbalizer" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a compact simple list.  Format: ,</statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPreferredVerbalizer" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a compact simple list.  Format: ,</statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPreferredVerbalizer" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleOrListClose" replacementCount="0">
    <statement>Description: Text used at the end of a compact simple or list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleOrListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in a compact simple or list.  Format: , or </statement>
    <unformattedSnippet>, or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleOrListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of a compact simple or list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleOrListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a compact simple or list.  Format: or </statement>
    <unformattedSnippet> or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompactSimpleOrListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a compact simple or list.  Format: ,</statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompatibleTypesIdentityInequalityOperator" replacementCount="2">
    <statement>Description: Used to specify that two instances of compatible types are not the same instance.
Format: that {0} is not that {1}</statement>
    <unformattedSnippet>that {0} is not that {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="LogicalAndOperator" />
    </containedIn>
    <usedBy>
      <constraint name="AntisymmetricRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="CompoundListClose" replacementCount="0">
    <statement>Description: Text that is at the end of a compound list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="SubsetConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompoundListFinalSeparator" replacementCount="0">
    <statement>Description: Used after the last item listed in a compound list.  Format: ;</statement>
    <unformattedSnippet>; </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="SubsetConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompoundListOpen" replacementCount="0">
    <statement>Description: Text that is at the beginning of a compound list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="SubsetConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompoundListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a compound list.  Format: ;</statement>
    <unformattedSnippet>; </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="SubsetConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CompoundListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a compound list.  Format: ;</statement>
    <unformattedSnippet>; </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="SubsetConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="Conditional" replacementCount="2">
    <statement>Description: Verbalizes a simple conditional statement. Format: if {0} then {1}</statement>
    <unformattedSnippet>if {0} then {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="SubsetConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ConditionalMultiLine" replacementCount="2">
    <statement>Description: Verbalizes a conditional statement on two lines.
Format: if {0}
        then {1}</statement>
    <unformattedSnippet>if {0}then {1}</unformattedSnippet>
    <contains>
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
      <snippet name="EqualValueComparator" />
      <snippet name="ExactlyOneUntypedOccurrence" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="FrequencyUntypedOccurrences" />
      <snippet name="GreaterThanOrEqualValueComparator" />
      <snippet name="GreaterThanValueComparator" />
      <snippet name="LessThanOrEqualValueComparator" />
      <snippet name="LessThanValueComparator" />
      <snippet name="NotEqualValueComparator" />
      <snippet name="SelfReference" />
    </contains>
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ConditionalMultiLineIndented" replacementCount="2">
    <statement>Description: Verbalizes a conditional statement on two lines with the 'then' line indented.
Format: if {0}
          then {1}</statement>
    <unformattedSnippet>if {0}then {1}</unformattedSnippet>
    <contains>
      <snippet name="CompatibleTypesIdentityInequalityOperator" />
      <snippet name="DefiniteArticle" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="LogicalAndOperator" />
      <snippet name="ModalPossibilityOperator" />
      <snippet name="ReflexivePronoun" />
      <snippet name="ReflexiveQuantifier" />
      <snippet name="SameTypeIdentityInequalityOperator" />
      <snippet name="SelfReference" />
      <snippet name="StronglyIntransitiveConsequent" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="AntisymmetricRingVerbalizer" />
      <constraint name="AsymmetricRingVerbalizer" />
      <constraint name="IntransitiveRingVerbalizer" />
      <constraint name="PurelyReflexiveRingVerbalizer" />
      <constraint name="ReflexiveRingVerbalizer" />
      <constraint name="StronglyIntransitiveRingVerbalizer" />
      <constraint name="SymmetricRingVerbalizer" />
      <constraint name="TransitiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ConstraintProvidesPreferredIdentifier" replacementCount="2">
    <statement>Description: Verbalizes the preferred identifier for an object.
Format: this association with {0}provides the preferred identification scheme for {1}</statement>
    <unformattedSnippet>this association with {0} provides the preferred identification scheme for {1}</unformattedSnippet>
    <contains>
      <snippet name="ObjectType" />
    </contains>
    <containedIn />
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="ImpliedUniqueVerbalizer" />
      <constraint name="UniquenessPreferredVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ContextCombinationAssociation" replacementCount="1">
    <statement>Description: Verbalizes a range of combination occurrences for a specified type where the combination has been previous specified.  Format: that combination is associated with {1} in this context</statement>
    <unformattedSnippet>that combination is associated with {0} in this context</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ContextCombinationOccurrence" replacementCount="1">
    <statement>Description: Verbalizes a range of combination occurrences where the combination has been previous specified.  Format: that combination occurs {1} in this context</statement>
    <unformattedSnippet>that combination occurs {0} in this context</unformattedSnippet>
    <contains>
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
      <snippet name="ExactlyOneUntypedOccurrence" />
      <snippet name="FrequencyUntypedOccurrences" />
    </contains>
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="CountRangeExact" replacementCount="1">
    <statement>Description: Used for frequency and cardinality ranges where both the min and max values the same
Format: exactly {0}</statement>
    <unformattedSnippet>exactly {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="CardinalityMultipleInstances" />
      <snippet name="ConditionalMultiLine" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="FrequencyPopulation" />
      <snippet name="FrequencyUntypedOccurrences" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ObjectTypeCardinality" />
      <snippet name="UnaryRoleCardinality" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CountRangeMaxUnbounded" replacementCount="1">
    <statement>Description: Used for frequency and cardinality ranges where the max value is unbounded.
Format: at least {0}</statement>
    <unformattedSnippet>at least {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="CardinalityMultipleInstances" />
      <snippet name="ConditionalMultiLine" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="FrequencyPopulation" />
      <snippet name="FrequencyUntypedOccurrences" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ObjectTypeCardinality" />
      <snippet name="UnaryRoleCardinality" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CountRangeMinAndMax" replacementCount="2">
    <statement>Description: Used for frequency and cardinality ranges where both the min and max values are specified and different.
Format: at least {0} and at most {1}</statement>
    <unformattedSnippet>at least {0} and at most {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="CardinalityMultipleInstances" />
      <snippet name="ConditionalMultiLine" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="FrequencyPopulation" />
      <snippet name="FrequencyUntypedOccurrences" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ObjectTypeCardinality" />
      <snippet name="UnaryRoleCardinality" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="CountRangeMinUnbounded" replacementCount="1">
    <statement>Description: Used for a frequency range where the min value is less than 2, or a cardinality range with a 0 lower bound.
Format: at most {1}</statement>
    <unformattedSnippet>at most {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="CardinalityMultipleInstances" />
      <snippet name="ConditionalMultiLine" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="FrequencyPopulation" />
      <snippet name="FrequencyTypedOccurrences" />
      <snippet name="FrequencyUntypedOccurrences" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ObjectTypeCardinality" />
      <snippet name="UnaryRoleCardinality" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="DefaultValuePrefix" replacementCount="1">
    <statement>Description: Used to verbalize a default value.
Format: default value: {0}</statement>
    <unformattedSnippet>Default Value: {0}</unformattedSnippet>
    <contains>
      <snippet name="NonTextInstanceValue" />
      <snippet name="TextInstanceValue" />
    </contains>
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="DefiniteArticle" replacementCount="1">
    <statement>Description: Used for 'that' before an object name to signify a back reference to a uniquely qualified object type. Format: that {0}</statement>
    <unformattedSnippet>that {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="DynamicRuleDeletions" />
      <snippet name="DynamicRuleVerbalization" />
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ForEachNegatableCompactQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="LogicalAndOperator" />
      <snippet name="ModalPossibilityOperator" />
      <snippet name="SingularExistenceImplicationOperator" />
    </containedIn>
    <usedBy>
      <constraint name="AntisymmetricRingVerbalizer" />
      <constraint name="AsymmetricRingVerbalizer" />
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DefaultBinaryMissingUniquenessVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="ImpliedUniqueVerbalizer" />
      <constraint name="IntransitiveRingVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="SymmetricRingVerbalizer" />
      <constraint name="TransitiveRingVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="DerivationNoteVerbalization" replacementCount="1">
    <statement>Description: Verbalizes the informal note specified for an element derivation rule. Format: Derivation  Note: {0}</statement>
    <unformattedSnippet>Derivation Note: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="DerivedFactTypeReference" replacementCount="1">
    <statement>Description: used to reference a derived fact type in a list of derived elements.
Format: {0}</statement>
    <unformattedSnippet>{0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="DerivedFromListClose" replacementCount="0">
    <statement>Description: Text used to close the derived from list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="DerivedFromListFinalSeparator" replacementCount="0">
    <statement>Description: Text used to separate the last two items in a derived from list. Format: &lt;br/&gt;</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="DerivedFromListOpen" replacementCount="0">
    <statement>Description:  Text and formatting to begin a list of elements derived from the current selection.Format: Used by derivations: &lt;br/&gt;</statement>
    <unformattedSnippet>Used By Derivations:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="DerivedFromListPairSeparator" replacementCount="0">
    <statement>Description: Text used to separate items in a derived from list. Format: &lt;br/&gt;</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="DerivedFromListSeparator" replacementCount="0">
    <statement>Description: Text used to separate items in a derived from list. Format: &lt;br/&gt;</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="DerivedSubtypeReference" replacementCount="1">
    <statement>Description: used to reference a derived subtype in a list of derived elements.
Format: subtype {0}</statement>
    <unformattedSnippet>subtype {0}</unformattedSnippet>
    <contains>
      <snippet name="ObjectType" />
    </contains>
    <containedIn>
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="DescriptionVerbalization" replacementCount="1">
    <statement>Description: Verbalizes the text specified for an element description. Format: Informal Description: {0}</statement>
    <unformattedSnippet>Informal Description: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="DynamicRuleAdditions" replacementCount="1">
    <statement>Description: Dynamic rule additions section. Specify instances and facts to add.
Format: Add: {0}</statement>
    <unformattedSnippet>Add: {0}</unformattedSnippet>
    <contains>
      <snippet name="VariableAddAction" />
    </contains>
    <containedIn>
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="DynamicRuleDeletions" replacementCount="1">
    <statement>Description: Dynamic rule deletions section. Specify instances and facts to delete.
Format: Remove: {0}</statement>
    <unformattedSnippet>Delete: {0}</unformattedSnippet>
    <contains>
      <snippet name="DefiniteArticle" />
    </contains>
    <containedIn>
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="DynamicRuleQuantifierCondition" replacementCount="1">
    <statement>Description: Dynamic rule conditions attached to the quanfiers section. Verbalize the path body (with additions and deletions filtered)
Format: where {0}</statement>
    <unformattedSnippet>where {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="DynamicRuleQuantifiers" />
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="DynamicRuleQuantifiers" replacementCount="2">
    <statement>Description: Dynamic rule quantification section. Contains quantifiers for body variables used in additions and deletions, plus remaining conditions from the path.
Format: For each {0}{1}</statement>
    <unformattedSnippet>For each  {0}{1}</unformattedSnippet>
    <contains>
      <snippet name="DynamicRuleQuantifierCondition" />
      <snippet name="SelfReference" />
      <snippet name="VariableAddedQuantifier" />
      <snippet name="VariableDeletedQuantifier" />
      <snippet name="VariableInitialQuantifier" />
    </contains>
    <containedIn>
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="DynamicRuleReference" replacementCount="1">
    <statement>Description: used to reference a dynamic rule in a list of derived elements.
Format: dynamic rule {0}</statement>
    <unformattedSnippet>dynamic rule {0}</unformattedSnippet>
    <contains>
      <snippet name="ObjectType" />
    </contains>
    <containedIn>
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="DynamicRuleStandaloneCondition" replacementCount="1">
    <statement>Description: Dynamic rule conditions attached to the end of the rule when there are now to the quanfiers section. Verbalize the path body (with additions and deletions filtered)
Format: When: {0}</statement>
    <unformattedSnippet>When:{0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="DynamicRuleVerbalization" replacementCount="4">
    <statement>Description: Root verbalization for a dynamic rule. Containers simple replacement fields for the four possible parts of a dynamic rule verbalization (quantifier + condition, additions, deletions, standalone conditions).
Format: {0}{1}{2}{3}</statement>
    <unformattedSnippet>{0}{1}{2}{3}</unformattedSnippet>
    <contains>
      <snippet name="DefiniteArticle" />
      <snippet name="DynamicRuleAdditions" />
      <snippet name="DynamicRuleDeletions" />
      <snippet name="DynamicRuleQuantifierCondition" />
      <snippet name="DynamicRuleQuantifiers" />
      <snippet name="DynamicRuleStandaloneCondition" />
      <snippet name="SelfReference" />
      <snippet name="VariableAddAction" />
      <snippet name="VariableAddedQuantifier" />
      <snippet name="VariableDeletedQuantifier" />
      <snippet name="VariableInitialQuantifier" />
    </contains>
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="EntityTypeVerbalization" replacementCount="1">
    <statement>Description: Verbalizes an object as being an entity type. Format: {0} is an entity type</statement>
    <unformattedSnippet>{0} is an entity type</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="Equality" replacementCount="2">
    <statement>Description: Used to verbalize a simple equality constraint. Format: {0} if and only if {1}</statement>
    <unformattedSnippet>{0} if and only if {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="EqualityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="EqualsListClose" replacementCount="0">
    <statement>Description: Text that is at the end of an equals list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="PurelyReflexiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="EqualsListFinalSeparator" replacementCount="0">
    <statement>Description: Used between the last two items in an equals list.  Format: =</statement>
    <unformattedSnippet> = </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="PurelyReflexiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="EqualsListOpen" replacementCount="0">
    <statement>Description: Text that is at the beginning of an equals list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="PurelyReflexiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="EqualsListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an equals list.  Format: =</statement>
    <unformattedSnippet> = </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="PurelyReflexiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="EqualsListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an equals list.  Format: =</statement>
    <unformattedSnippet> = </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="PurelyReflexiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="EqualValueComparator" replacementCount="2">
    <statement>Description: Used to compare the two values in a value comparison constraint with a 'equal' operator.
Format: {0} is equal to {1}</statement>
    <unformattedSnippet>{0} is equal to {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ErrorClosePrimaryReport" replacementCount="0">
    <statement>Description: Close a primary error report opened with ErrorOpenPrimaryReport</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ErrorCloseSecondaryReport" replacementCount="0">
    <statement>Description: Close a secondary error report opened with ErrorOpenSecondaryReport.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ErrorOpenPrimaryReport" replacementCount="0">
    <statement>Description: Used to open a primary error report. Primary error reports block further verbalization.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ErrorOpenSecondaryReport" replacementCount="0">
    <statement>Description: Used to open a secondary error report. Secondary reports contain errors that do not block verbalization.
Replacement: {0}=error text,{1}=error id
Format: Model Error: {0}</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ErrorPrimary" replacementCount="2">
    <statement>Description: Used to verbalize a single primary error.
Replacement: {0}=error text,{1}=error id
Format: Model Error: {0}</statement>
    <unformattedSnippet>Model Error: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ErrorSecondary" replacementCount="2">
    <statement>Description: Used to verbalize a single secondary error.
Format: Model Error: {0}</statement>
    <unformattedSnippet>Model Error: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ExactlyOneQuantifier" replacementCount="1">
    <statement>Description: Used for 'exactly one' before an object name to signify the quantity may only be one.  Format: exactly one {0}</statement>
    <unformattedSnippet>exactly one {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ExactlyOneTypedOccurrence" replacementCount="1">
    <statement>Description: Used for a fallback uniqueness verbalization, or for a frequency constraint with min=max=1.
Format: exactly one {0}</statement>
    <unformattedSnippet>exactly one {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ExactlyOneUntypedOccurrence" replacementCount="0">
    <statement>Description: Used for a fallback uniqueness verbalization, or for a frequency constraint with min=max=1.
Format: exactly once</statement>
    <unformattedSnippet>exactly once</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="FrequencyPopulation" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ExclusionBinaryLeadReading" replacementCount="2">
    <statement>Description: Used to verbalize an exclusion constraint, on a binary lead reading.
Format: No {0} the same {1}</statement>
    <unformattedSnippet>no {0} the same {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ExclusionCombined" replacementCount="2">
    <statement>Description: Used to combine the first role player and the roles played for an Exclusion constraint (i.e: No Person authored and reviewed). Format: {0} {1}</statement>
    <unformattedSnippet>{0} {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ExistentialAddedQuantifier" replacementCount="1">
    <statement>Description: Used for 'some' before the name of an object in the 'added' dynamic state to signify the context in which the object is being referred to.  Format: some added {0}</statement>
    <unformattedSnippet>some added {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ExistentialDeletedQuantifier" replacementCount="1">
    <statement>Description: Used for 'some' before the name of an object in the 'deleted' dynamic state to signify the context in which the object is being referred to.  Format: some deleted {0}</statement>
    <unformattedSnippet>some deleted {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ExistentialInitialQuantifier" replacementCount="1">
    <statement>Description: Used for 'some' before the name of an object in the 'initial' dynamic state to signify the context in which the object is being referred to.  Format: some initial {0}</statement>
    <unformattedSnippet>some initial {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ExistentialQuantifier" replacementCount="1">
    <statement>Description: Used for 'some' before an object name to signify the context in which the object is being referred to.  Format: some {0}</statement>
    <unformattedSnippet>some {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ForEachNegatableCompactQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="LogicalAndOperator" />
      <snippet name="ModalPossibilityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="AntisymmetricRingVerbalizer" />
      <constraint name="AsymmetricRingVerbalizer" />
      <constraint name="DefaultBinaryMissingUniquenessVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="IntransitiveRingVerbalizer" />
      <constraint name="IrreflexiveRingVerbalizer" />
      <constraint name="PurelyReflexiveRingVerbalizer" />
      <constraint name="ReflexiveRingVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="StronglyIntransitiveRingVerbalizer" />
      <constraint name="SymmetricRingVerbalizer" />
      <constraint name="TransitiveRingVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="FactTypeAddedState" replacementCount="1">
    <statement>Description: Used to indicate that a fact type is in the 'added' dynamic state.  Format: ({0}) is added</statement>
    <unformattedSnippet>({0}) is added</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeDeletedState" replacementCount="1">
    <statement>Description: Used to indicate that a fact type is in the 'initial' dynamic state.  Format: ({0}) is deleted</statement>
    <unformattedSnippet>({0}) is deleted</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeInitialState" replacementCount="1">
    <statement>Description: Used to indicate that a fact type is in the 'initial' dynamic state.  Format: ({0}) is initial</statement>
    <unformattedSnippet>({0}) is initial</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeInstanceBlockEnd" replacementCount="0">
    <statement>Description: Formatted single snippet used to end a sample population verbalization of fact types block.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeInstanceBlockStart" replacementCount="0">
    <statement>Description: Text and formatting to begin a sample population verbalization of fact types block. Format: Examples:</statement>
    <unformattedSnippet>Examples: </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeInstanceIdentifier" replacementCount="1">
    <statement>Description: The text describing the identifier for an objectified FactType instance with an external identifier. Format: Identifier:</statement>
    <unformattedSnippet>Identifier: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeListClose" replacementCount="0">
    <statement>Description: Text used to close the fact type verbalization list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeListFinalSeparator" replacementCount="0">
    <statement>Description: Text used to separate the last two items in a fact type verbalization list. Format: &lt;br/&gt;</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeListOpen" replacementCount="0">
    <statement>Description:  Text and formatting to begin a list of fact types represented by basic predicate text.Format: FactTypes: &lt;br/&gt;</statement>
    <unformattedSnippet>Fact Types:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeListPairSeparator" replacementCount="0">
    <statement>Description: Text used to separate items in a fact type verbalization list. Format: &lt;br/&gt;</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FactTypeListSeparator" replacementCount="0">
    <statement>Description: Text used to separate items in a fact type verbalization list. Format: &lt;br/&gt;</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ForEachCompactQuantifier" replacementCount="2">
    <statement>Description: Verbalizes for each instance of an object, some rule applies to those instances.  Format: for each {0}, {1}</statement>
    <unformattedSnippet>for each {0}, {1}</unformattedSnippet>
    <contains>
      <snippet name="AtMostOneQuantifier" />
      <snippet name="DefiniteArticle" />
      <snippet name="ExactlyOneQuantifier" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="GroupEquality" />
      <snippet name="GroupExclusion" />
      <snippet name="GroupExclusiveOr" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="OneQuantifier" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="ImpliedUniqueVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ForEachIndentedQuantifier" replacementCount="2">
    <statement>Description: Verbalizes for each instance of an object then creates a line break where the rules that apply to those instances are listed.  Format: for each {0}, \n{1}</statement>
    <unformattedSnippet>for each {0},{1}</unformattedSnippet>
    <contains>
      <snippet name="AtMostOneTypedOccurrence" />
      <snippet name="CombinationIdentifier" />
      <snippet name="Conditional" />
      <snippet name="ConditionalMultiLine" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
      <snippet name="DefiniteArticle" />
      <snippet name="Equality" />
      <snippet name="EqualValueComparator" />
      <snippet name="ExactlyOneUntypedOccurrence" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="FrequencyNotPopulatedOrRange" />
      <snippet name="FrequencyTypedCombinationOccurrences" />
      <snippet name="FrequencyTypedOccurrences" />
      <snippet name="FrequencyUntypedOccurrences" />
      <snippet name="GreaterThanOrEqualValueComparator" />
      <snippet name="GreaterThanValueComparator" />
      <snippet name="LessThanOrEqualValueComparator" />
      <snippet name="LessThanValueComparator" />
      <snippet name="NotEqualValueComparator" />
      <snippet name="PluralExistenceImplicationOperator" />
      <snippet name="SelfReference" />
      <snippet name="SingularExistenceImplicationOperator" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="FrequencyConstraint" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="SubsetConstraint" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ForEachNegatableCompactQuantifier" replacementCount="2">
    <statement>Description: Verbalizes for each instance of an object, some rule applies to those instances.
Format positive: for each {0}, {1}
Format negative: for some {0}, {1}</statement>
    <unformattedSnippet>for each {0}, {1}</unformattedSnippet>
    <contains>
      <snippet name="DefiniteArticle" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="MoreThanOneQuantifier" />
      <snippet name="OneQuantifier" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ModalPossibilityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="DefaultBinaryMissingUniquenessVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ForEachNegatableIndentedQuantifier" replacementCount="2">
    <statement>Description: Verbalizes for each instance of an object then creates a line break where the rules that apply to those instances are listed.
Format positive: for each {0}, \n{1}
Format negative: for some {0}, \n{1}</statement>
    <unformattedSnippet>for each {0},{1}</unformattedSnippet>
    <contains>
      <snippet name="CombinationIdentifier" />
      <snippet name="ConditionalMultiLine" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="DefiniteArticle" />
      <snippet name="ExactlyOneUntypedOccurrence" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="MoreThanOneQuantifier" />
      <snippet name="OneQuantifier" />
      <snippet name="SingularExistenceImplicationOperator" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ModalPossibilityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="FrequencyNotPopulatedOrRange" replacementCount="1">
    <statement>Description: Combined with a frequency range to indicate that a frequency constraint with a lower bound does not imply existence.
Format: either no, or {0}</statement>
    <unformattedSnippet>either 0, or {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
    </usedBy>
  </snippet>
  <snippet name="FrequencyPopulation" replacementCount="3">
    <statement>Description: Used as for the main body text of a frequency constraint on one FactType.
Format: each {0} in the population of {1} occurs there {2} times</statement>
    <unformattedSnippet>each {0} in the population of &amp;#8220;{1}&amp;#8221; occurs there {2}</unformattedSnippet>
    <contains>
      <snippet name="CombinationIdentifier" />
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
      <snippet name="ExactlyOneUntypedOccurrence" />
      <snippet name="FrequencyUntypedOccurrences" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
    </usedBy>
  </snippet>
  <snippet name="FrequencyTypedCombinationOccurrences" replacementCount="2">
    <statement>Description: Used to specify an instance count or range for a combination of object types.
Format: {1} combinations of {0}</statement>
    <unformattedSnippet>{1} combinations of {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
    </usedBy>
  </snippet>
  <snippet name="FrequencyTypedOccurrences" replacementCount="2">
    <statement>Description: Used to specify an instance count or range for a specific object type.
Format: {1} instances of {0}</statement>
    <unformattedSnippet>{1} instances of {0}</unformattedSnippet>
    <contains>
      <snippet name="CountRangeMinUnbounded" />
    </contains>
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
    </usedBy>
  </snippet>
  <snippet name="FrequencyUntypedOccurrences" replacementCount="1">
    <statement>Description: Used to specify an instance count or range using an untyped occurrence phrase
Format: {0} times</statement>
    <unformattedSnippet>{0} times</unformattedSnippet>
    <contains>
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
    </contains>
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="FrequencyPopulation" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
    </usedBy>
  </snippet>
  <snippet name="FullFactTypeDerivation" replacementCount="2">
    <statement>Description: Used to specify a fully derived fact type with its derivation rule.
Format: *{0} if and only if {1}</statement>
    <unformattedSnippet>*{0} if and only if{1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FullFactTypeStoredDerivation" replacementCount="2">
    <statement>Description: Used to specify a fully derived (and stored) fact type with its derivation rule.
Format: **{0} if and only if {1}</statement>
    <unformattedSnippet>**{0} if and only if{1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FullStoredFactTypeDescription" replacementCount="0">
    <statement>Description: A textual specification of stored derivation for a fully derived fact type.
instances of this fact type are stored immediately after they are derived</statement>
    <unformattedSnippet>instances of this fact type are stored immediately after they are derived</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FullStoredSubtypeDescription" replacementCount="0">
    <statement>Description: A textual specification of stored derivation for a fully derived subtype.
instances of this subtype are stored immediately after they are derived</statement>
    <unformattedSnippet>instances of this subtype are stored immediately after they are derived</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FullSubtypeDerivation" replacementCount="2">
    <statement>Description: Used to specify a fully derived subtype derivation rule.
Format: *each {0} is by definition {1}</statement>
    <unformattedSnippet>*Each {0} is by definition {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="FullSubtypeStoredDerivation" replacementCount="2">
    <statement>Description: Used to specify a fully derived (and stored) subtype derivation rule.
Format: **each {0} is by definition {1}</statement>
    <unformattedSnippet>**Each {0} is by definition {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="GreaterThanOrEqualValueComparator" replacementCount="2">
    <statement>Description: Used to compare the two values in a value comparison constraint with a 'greater than or equal' operator.
Format: {0} is greater than or equal to {1}</statement>
    <unformattedSnippet>{0} is greater than or equal to {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="GreaterThanValueComparator" replacementCount="2">
    <statement>Description: Used to compare the two values in a value comparison constraint with a 'greater than' operator.
Format: {0} is greater than {1}</statement>
    <unformattedSnippet>{0} is greater than {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="GroupEquality" replacementCount="1">
    <statement>Description: Assert group equality. Format: all or none of the following hold: {0}</statement>
    <unformattedSnippet>all or none of the following hold:{0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="EqualityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="GroupExclusion" replacementCount="1">
    <statement>Description: Assert group exclusion. Format: at most one of the following holds: {0}</statement>
    <unformattedSnippet>at most one of the following holds:{0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="GroupExclusiveOr" replacementCount="1">
    <statement>Description: Assert group exclusive-or. Format: exactly one of the following holds: {0}</statement>
    <unformattedSnippet>exactly one of the following holds:{0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="HeadVariableProjection" replacementCount="2">
    <statement>Description: Project a calculation or constant value onto a head variable.
Format: {0} = {1}</statement>
    <unformattedSnippet>{0} = {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="HyphenBoundPredicatePart" replacementCount="2">
    <statement>Description: Format string to combine predicate text from hyphen binding with the replacement field. Format: {0}{{0}}{1}</statement>
    <unformattedSnippet>{0}{{0}}{1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityEqualityListClose" replacementCount="0">
    <statement>Description: Text that is at the end of an identity equality list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityEqualityListFinalSeparator" replacementCount="0">
    <statement>Description: Used between the last two items in an identity equality list.  Format: that is a</statement>
    <unformattedSnippet> that is a </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityEqualityListOpen" replacementCount="0">
    <statement>Description: Text that is at the beginning of an identity equality list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityEqualityListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an identity equality list.  Format: that is a</statement>
    <unformattedSnippet> that is a </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityEqualityListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an identity equality list.  Format: that is a</statement>
    <unformattedSnippet> that is a </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityListClose" replacementCount="0">
    <statement>Description:  Text and formatting to end a list of different-typed identifiers representating the same instance.
Format: </statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityListFinalSeparator" replacementCount="0">
    <statement>Description:  Text and formatting to separate the last pair of 3 or more items or different-typed identifiers representating the same instance.
Format: that is </statement>
    <unformattedSnippet> that is </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityListOpen" replacementCount="0">
    <statement>Description:  Text and formatting to begin a list of different-typed identifiers representating the same instance.
Format: </statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityListPairSeparator" replacementCount="0">
    <statement>Description:  Text and formatting to separate a two-item list of different-typed identifiers representating the same instance.
Format: that is </statement>
    <unformattedSnippet> that is </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityListSeparator" replacementCount="0">
    <statement>Description:  Text and formatting to separate all but the last item of 3 or more items or different-typed identifiers representating the same instance.
Format: that is </statement>
    <unformattedSnippet> that is </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IdentityReferenceQuantifier" replacementCount="1">
    <statement>Description: Used for 'the same' before an object name to signify exactly which object is being reference.  Format: the same {0}</statement>
    <unformattedSnippet>the same {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="CombinationIdentifier" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ModalPossibilityOperator" />
      <snippet name="OccursInPopulation" />
    </containedIn>
    <usedBy>
      <constraint name="DefaultBinaryMissingUniquenessVerbalizer" />
      <constraint name="IrreflexiveRingVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ImpersonalIdentityCorrelation" replacementCount="2">
    <statement>Description: Relate two variables of different types that represent the same instance where the first
variable is an impersonal object type.
Format: {0} that is {1}</statement>
    <unformattedSnippet>{0} that is {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ImpersonalLeadIdentityCorrelation" replacementCount="2">
    <statement>Description: A form of ImpersonalIdentityCorrelation for lead role scenarios. Relate two variables of different
types that represent the same instance where the first variable is an impersonal object type.
Format:  {1} is {0} that</statement>
    <unformattedSnippet>{1} is {0} that</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ImpersonalPronoun" replacementCount="0">
    <statement>Description: Use in place of a role player name to reference an impersonal object type with a clear antecedent.</statement>
    <unformattedSnippet>that</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ImpliedModalNecessityOperator" replacementCount="1">
    <statement>Description: Used to define the strength of the constraint.  Alethic, positive adds nothing before an object name.  Deontic, positive adds 'it is obligatory that' before an object name.  Alethic, negative adds 'it is impossible that' before an object name.  Deontic, negative adds 'it is forbidden that' before an object name.
Format for alethic and positive: {0}  Format for deontic and positive: it is obligatory that {0}  Format for alethic and negative: it is impossible that {0}  Format for deontic and negative: it is forbidden that {0}</statement>
    <unformattedSnippet>{0}</unformattedSnippet>
    <contains>
      <snippet name="Acyclicity" />
      <snippet name="AcyclicityWithRoleNumbers" />
      <snippet name="AtMostOneQuantifier" />
      <snippet name="AtMostOneTypedOccurrence" />
      <snippet name="CardinalityMultipleInstances" />
      <snippet name="CardinalitySingleInstance" />
      <snippet name="CombinationIdentifier" />
      <snippet name="Conditional" />
      <snippet name="ConditionalMultiLine" />
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="ContextCombinationOccurrence" />
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
      <snippet name="DefiniteArticle" />
      <snippet name="Equality" />
      <snippet name="EqualValueComparator" />
      <snippet name="ExactlyOneQuantifier" />
      <snippet name="ExactlyOneUntypedOccurrence" />
      <snippet name="ExclusionBinaryLeadReading" />
      <snippet name="ExclusionCombined" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ForEachNegatableCompactQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="FrequencyNotPopulatedOrRange" />
      <snippet name="FrequencyPopulation" />
      <snippet name="FrequencyTypedCombinationOccurrences" />
      <snippet name="FrequencyTypedOccurrences" />
      <snippet name="FrequencyUntypedOccurrences" />
      <snippet name="GreaterThanOrEqualValueComparator" />
      <snippet name="GreaterThanValueComparator" />
      <snippet name="GroupEquality" />
      <snippet name="GroupExclusion" />
      <snippet name="GroupExclusiveOr" />
      <snippet name="IdentityReferenceQuantifier" />
      <snippet name="InQuantifier" />
      <snippet name="LessThanOrEqualValueComparator" />
      <snippet name="LessThanValueComparator" />
      <snippet name="LogicalAndOperator" />
      <snippet name="MinClosedMaxClosed" />
      <snippet name="MinClosedMaxOpen" />
      <snippet name="MinClosedMaxUnbounded" />
      <snippet name="MinOpenMaxClosed" />
      <snippet name="MinOpenMaxOpen" />
      <snippet name="MinOpenMaxUnbounded" />
      <snippet name="MinUnboundedMaxClosed" />
      <snippet name="MinUnboundedMaxOpen" />
      <snippet name="MultiValueValueConstraint" />
      <snippet name="NonTextInstanceValue" />
      <snippet name="NotEqualValueComparator" />
      <snippet name="ObjectType" />
      <snippet name="ObjectTypeCardinality" />
      <snippet name="OccursInPopulation" />
      <snippet name="OneQuantifier" />
      <snippet name="PeriodSeparator" />
      <snippet name="PluralExistenceImplicationOperator" />
      <snippet name="ReferenceScheme" />
      <snippet name="ReflexivePronoun" />
      <snippet name="ReflexiveQuantifier" />
      <snippet name="SelfReference" />
      <snippet name="SingleValueValueConstraint" />
      <snippet name="SingularExistenceImplicationOperator" />
      <snippet name="StronglyIntransitiveConsequent" />
      <snippet name="SubtypeMetaReading" />
      <snippet name="TextInstanceValue" />
      <snippet name="UnaryRoleCardinality" />
      <snippet name="UniversalQuantifier" />
    </contains>
    <containedIn>
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
    </containedIn>
    <usedBy>
      <constraint name="AcyclicRingVerbalizer" />
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
      <constraint name="FrequencyConstraint" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="ImpliedUniqueVerbalizer" />
      <constraint name="IrreflexiveRingVerbalizer" />
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="PurelyReflexiveRingVerbalizer" />
      <constraint name="ReflexiveRingVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="StronglyIntransitiveRingVerbalizer" />
      <constraint name="SubsetConstraint" />
      <constraint name="SymmetricRingVerbalizer" />
      <constraint name="TransitiveRingVerbalizer" />
      <constraint name="UnaryRoleCardinalityConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="IndentedCompoundListClose" replacementCount="0">
    <statement>Description: Text that is at the end of an indented compound list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedCompoundListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in an indented compound list.  Format: ;</statement>
    <unformattedSnippet>; </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedCompoundListOpen" replacementCount="0">
    <statement>Description: Text that is at the beginning of an indented compound list.  Format: \n</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedCompoundListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented compound list.  Format: ;</statement>
    <unformattedSnippet>; </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedCompoundListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented compound list.  Format: ;</statement>
    <unformattedSnippet>; </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedListClose" replacementCount="0">
    <statement>Description: Text used at the end of an indented list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in an indented list.  Format: and</statement>
    <unformattedSnippet> and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of an indented list.  Format: \n</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented list.  Format: and</statement>
    <unformattedSnippet> and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented list.  Format: and</statement>
    <unformattedSnippet> and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedLogicalAndListClose" replacementCount="0">
    <statement>Description: Text used at the end of an indented logical and list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IndentedLogicalAndListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in an indented logical and list.  Format: and that</statement>
    <unformattedSnippet>and that </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IndentedLogicalAndListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of an indented logical and list.  Format: \n</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IndentedLogicalAndListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented logical and list.  Format: and that</statement>
    <unformattedSnippet>and that </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IndentedLogicalAndListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented logical and list.  Format: and that</statement>
    <unformattedSnippet>and that </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="IndentedLogicalOrListClose" replacementCount="0">
    <statement>Description: Text used at the end of an indented logical or list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedLogicalOrListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in an indented logical or list.  Format: or</statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedLogicalOrListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of an indented logical or list.  Format: \n</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedLogicalOrListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented logical or list.  Format: or</statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndentedLogicalOrListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented logical or list.  Format: or</statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="IndependentVerbalization" replacementCount="1">
    <statement>Description: Verbalizes an object as being independent. Format: {0} is independent (it may have instances that play no other roles)</statement>
    <unformattedSnippet>{0} is independent (it may have instances that play no other roles)</unformattedSnippet>
    <contains>
      <snippet name="ObjectType" />
    </contains>
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="InQuantifier" replacementCount="2">
    <statement>Description: Used to verbalize [RolePlayer in Fact], e.g. Person in Person has Age.
Format: {0} in {1}</statement>
    <unformattedSnippet>{0} in {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="RoleValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="IsIdentifiedBy" replacementCount="2">
    <statement>Description: Used to specify that one instance is identified by the other instance.
Format: {0} is identified by {1}</statement>
    <unformattedSnippet>{0} is identified by {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="JoinedEqualityConstraintReference" replacementCount="1">
    <statement>Description: used to reference an equality constraint with a sequence that has a join path in a list of derived elements.
Format: equality constraint {0}</statement>
    <unformattedSnippet>equality constraint {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="JoinedSetComparisonSequenceReference" />
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="JoinedExclusionConstraintReference" replacementCount="1">
    <statement>Description: used to reference an exclusion constraint with a sequence that has a join path in a list of derived elements.
Format: exclusion constraint {0}</statement>
    <unformattedSnippet>exclusion constraint {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="JoinedSetComparisonSequenceReference" />
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="JoinedFrequencyConstraintReference" replacementCount="1">
    <statement>Description: used to reference a frequency constraint with a join path in a list of derived elements.
Format: frequency constraint {0}</statement>
    <unformattedSnippet>frequency constraint {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="JoinedRingConstraintReference" replacementCount="1">
    <statement>Description: used to reference a ring constraint with a join path in a list of derived elements.
Format: ring constraint {0}</statement>
    <unformattedSnippet>ring constraint {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="JoinedSetComparisonSequenceReference" replacementCount="2">
    <statement>Description: used to reference a set comparison sequence that has a join path in a list of derived elements.
Format: {0}, sequence {1}</statement>
    <unformattedSnippet>{0}, sequence {1}</unformattedSnippet>
    <contains>
      <snippet name="JoinedEqualityConstraintReference" />
      <snippet name="JoinedExclusionConstraintReference" />
      <snippet name="JoinedSubsetConstraintReference" />
      <snippet name="ObjectType" />
    </contains>
    <containedIn>
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="JoinedSubsetConstraintReference" replacementCount="1">
    <statement>Description: used to reference a subset constraint with a sequence that has a join path in a list of derived elements.
Format: subset constraint {0}</statement>
    <unformattedSnippet>subset constraint {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="JoinedSetComparisonSequenceReference" />
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="JoinedUniquenessConstraintReference" replacementCount="1">
    <statement>Description: used to reference a ring constraint with a join path in a list of derived elements.
Format: uniqueness constraint {0}</statement>
    <unformattedSnippet>uniqueness constraint {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="JoinedValueComparisonConstraintReference" replacementCount="1">
    <statement>Description: used to reference a value comparison constraint with a join path in a list of derived elements.
Format: value comparison constraint {0}</statement>
    <unformattedSnippet>value comparison constraint {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="KnownFalseChainedListOpen" replacementCount="0">
    <statement>This is closed by NegatedChainedListClose and should have the same format as NegatedChainedListOpen.</statement>
    <unformattedSnippet>it is known to be false that (</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="KnownNotFalseChainedListOpen" replacementCount="0">
    <statement>This is closed by NegatedChainedListClose and should have the same format as NegatedChainedListOpen.</statement>
    <unformattedSnippet>it is not known to be false that (</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="LessThanOrEqualValueComparator" replacementCount="2">
    <statement>Description: Used to compare the two values in a value comparison constraint with a 'less than or equal' operator.
Format: {0} is less than or equal to {1}
						</statement>
    <unformattedSnippet>{0} is less than or equal to {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="LessThanValueComparator" replacementCount="2">
    <statement>Description: Used to compare the two values in a value comparison constraint with a 'less than' operator.
Format: {0} is less than {1}
						</statement>
    <unformattedSnippet>{0} is less than {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="LogicalAndOperator" replacementCount="2">
    <statement>Description: Used to 'and' together exactly two other snippets.
Format: {0} and {1}</statement>
    <unformattedSnippet>{0} and {1}</unformattedSnippet>
    <contains>
      <snippet name="CompatibleTypesIdentityInequalityOperator" />
      <snippet name="DefiniteArticle" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="SameTypeIdentityInequalityOperator" />
      <snippet name="SelfReference" />
    </contains>
    <containedIn>
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="AntisymmetricRingVerbalizer" />
      <constraint name="IntransitiveRingVerbalizer" />
      <constraint name="TransitiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="MinClosedMaxClosed" replacementCount="2">
    <statement>Description: Used to verbalize a range inclusion with the minimum bound closed and the maximum bound closed.
Format: at least {0} to at most {1}</statement>
    <unformattedSnippet>at least {0} to at most {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MinClosedMaxOpen" replacementCount="2">
    <statement>Description: Used to verbalize a range inclusion with the minimum bound closed and the maximum bound open.
Format: at least {0} to below {1}</statement>
    <unformattedSnippet>at least {0} to below {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MinClosedMaxUnbounded" replacementCount="1">
    <statement>Description: Used to verbalize a range inclusion with the minimum bound closed and the maximum unbounded.
Format: at least {0}</statement>
    <unformattedSnippet>at least {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MinOpenMaxClosed" replacementCount="2">
    <statement>Description: Used to verbalize a range inclusion with the minimum bound open and the maximum bound closed.
Format: above {0} to at most {1}</statement>
    <unformattedSnippet>above {0} to at most {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MinOpenMaxOpen" replacementCount="2">
    <statement>Description: Used to verbalize a range inclusion with the minimum bound open and the maximum bound open.
Format: above {0} to below {1}</statement>
    <unformattedSnippet>above {0} to below {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MinOpenMaxUnbounded" replacementCount="1">
    <statement>Description: Used to verbalize a range inclusion with the minimum bound open and the maximum unbounded.
Format: above {0}</statement>
    <unformattedSnippet>above {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MinUnboundedMaxClosed" replacementCount="1">
    <statement>Description: Used to verbalize a range inclusion with the minimum unbounded and the maximum bound closed.
Format: at most {1}</statement>
    <unformattedSnippet>at most {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MinUnboundedMaxOpen" replacementCount="1">
    <statement>Description: Used to verbalize a range inclusion with the minimum unbounded and the maximum bound open.
Format: below {1}</statement>
    <unformattedSnippet>below {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ModalNecessityOperator" replacementCount="1">
    <statement>Description: Used to define the strength of the constraint.  Alethic adds 'it is necessary that' before  an object name.  Deontic adds 'it is obligatory that' before an object name.
Format for alethic: it is necessary that {0}  Format for deontic: it is obligatory that {0}</statement>
    <unformattedSnippet>it is necessary that {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ModalPossibilityOperator" replacementCount="1">
    <statement>Description: Used to define the strength of the constraint.  Alethic, positive adds 'it is possible that' before an object name.  Deontic, positive adds 'it is permitted that' before an object name.  Alethic, negative adds 'it is impossible that' before an object name.  Deontic, negative adds 'it is forbidden that' before an object name.
Format for alethic and positive: it is possible that {0}  Format for deontic and positive: it is permitted that {0}  Format for alethic and negative: it is impossible that {0}  Format for deontic and negative: it is forbidden that {0}</statement>
    <unformattedSnippet>it is possible that {0}</unformattedSnippet>
    <contains>
      <snippet name="CombinationIdentifier" />
      <snippet name="DefiniteArticle" />
      <snippet name="ExistentialQuantifier" />
      <snippet name="ForEachNegatableCompactQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="IdentityReferenceQuantifier" />
      <snippet name="MoreThanOneQuantifier" />
      <snippet name="NegativeReadingForUnaryOnlyDisjunctiveMandatory" />
      <snippet name="OccursInPopulation" />
      <snippet name="SelfReference" />
      <snippet name="SingularExistenceImplicationOperator" />
    </contains>
    <containedIn>
      <snippet name="ConditionalMultiLineIndented" />
    </containedIn>
    <usedBy>
      <constraint name="AntisymmetricRingVerbalizer" />
      <constraint name="AsymmetricRingVerbalizer" />
      <constraint name="DefaultBinaryMissingUniquenessVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="IntransitiveRingVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ModelVerbalization" replacementCount="1">
    <statement>Description: Format string to verbalize the model element. Replacement field {0} is the Model name, and {1} is the guid id for the model.</statement>
    <unformattedSnippet>Object-Role Model: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="MoreThanOneQuantifier" replacementCount="1">
    <statement>Description: Used for 'more than one' before an object name to define quantity as more than one.  Format: more than one {0}</statement>
    <unformattedSnippet>more than one {0}</unformattedSnippet>
    <contains>
      <snippet name="CombinationIdentifier" />
    </contains>
    <containedIn>
      <snippet name="ForEachNegatableCompactQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="ModalPossibilityOperator" />
      <snippet name="SingularExistenceImplicationOperator" />
    </containedIn>
    <usedBy>
      <constraint name="DefaultBinaryMissingUniquenessVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="MultilineIndentedCompoundListClose" replacementCount="0">
    <statement>Description: Text used at the end of an indented compound list.  Format:</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MultilineIndentedCompoundListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in an indented compound list.  Format: ;</statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MultilineIndentedCompoundListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of an indented compound list with one item on each line.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MultilineIndentedCompoundListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented compound list.  Format: ;</statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MultilineIndentedCompoundListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in an indented compound list.  Format: ;</statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="MultiValueValueConstraint" replacementCount="2">
    <statement>Description: Used to verbalize a value range constraint with multiple values.
Format: the possible values of {0} are {1}</statement>
    <unformattedSnippet>the possible values of {0} are {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="NegatedAndLeadListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndLeadListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>at least one of the following is false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndLeadListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndNestedListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndNestedListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>at least one of the following is false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndNestedListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>at least one of the following is false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndNestedListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndTailListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndTailListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>at least one of the following is false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndTailListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>at least one of the following is false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedAndTailListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedChainedListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>)</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedChainedListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>it is not true that (</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrLeadListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrLeadListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>all of the following are false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrLeadListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrNestedListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrNestedListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>all of the following are false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrNestedListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>all of the following are false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrNestedListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrTailListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrTailListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>all of the following are false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrTailListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>all of the following are false:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedOrTailListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedVariableExistence" replacementCount="1">
    <statement>Description: Assert variable non-existence for an a previous declared variable in an existence statement.
Note that VariableExistence can be used with a negated quantifier if the negated variable has not been previously introduced.
Format: {0} does not exist</statement>
    <unformattedSnippet>{0} does not exist</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedVariableExistenceAddedState" replacementCount="1">
    <statement>Description: Assert variable non-existence in the added state.
Format: {0} does not exist in added state</statement>
    <unformattedSnippet>{0} does not exist in added state</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedVariableExistenceDeletedState" replacementCount="1">
    <statement>Description: Assert variable non-existence in the deleted state.
Format: {0} does not in deleted state</statement>
    <unformattedSnippet>{0} does not exist in deleted state</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedVariableExistenceInitialState" replacementCount="1">
    <statement>Description: Assert variable non-existence in the initial state.
Format: {0} does not exist in initial state</statement>
    <unformattedSnippet>{0} does not exist in initial state</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorLeadListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorLeadListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>either none or many of the following are true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorLeadListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorNestedListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorNestedListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>either none or many of the following are true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorNestedListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>either none or many of the following are true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorNestedListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorTailListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorTailListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>either none or many of the following are true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorTailListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>either none or many of the following are true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegatedXorTailListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="NegativeReadingForUnaryOnlyDisjunctiveMandatory" replacementCount="2">
    <statement>Description: Used to verbalize that an object is not included in a set.  Format: some {0} participates in none of the following:{1}</statement>
    <unformattedSnippet>some {0} participates in none of the following:{1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ModalPossibilityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="NonTextInstanceValue" replacementCount="1">
    <statement>Description: Used to output a non-text instance value. Format: {0}</statement>
    <unformattedSnippet>{0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="DefaultValuePrefix" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="NotEqualValueComparator" replacementCount="2">
    <statement>Description: Used to compare the two values in a value comparison constraint with a 'not equal' operator.
Format: {0} is not equal to {1}</statement>
    <unformattedSnippet>{0} is not equal to {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="NotesVerbalization" replacementCount="1">
    <statement>Description: Verbalizes the text specified for a model note. Format: Notes: {0}</statement>
    <unformattedSnippet>Notes: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectifiesFactTypeVerbalization" replacementCount="2">
    <statement>Description: Verbalizes the objectification made for a FactType. Format: {0} objectifies "{1}"</statement>
    <unformattedSnippet>{0} objectifies &amp;#8220;{1}&amp;#8221;</unformattedSnippet>
    <contains>
      <snippet name="ObjectType" />
    </contains>
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectType" replacementCount="2">
    <statement>Description: Verbalizes an object. {0} is the name, {1} is the guid id for the element</statement>
    <unformattedSnippet>{0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConstraintProvidesPreferredIdentifier" />
      <snippet name="DerivedSubtypeReference" />
      <snippet name="DynamicRuleReference" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="IndependentVerbalization" />
      <snippet name="JoinedSetComparisonSequenceReference" />
      <snippet name="ObjectifiesFactTypeVerbalization" />
      <snippet name="ObjectTypeCardinality" />
      <snippet name="SelfReference" />
      <snippet name="SubtypeMetaReading" />
      <snippet name="UnaryRoleCardinality" />
    </containedIn>
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="ObjectTypeCardinalityConstraint" />
      <constraint name="UnaryRoleCardinalityConstraint" />
      <constraint name="UniquenessPreferredVerbalizer" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ObjectTypeCardinality" replacementCount="2">
    <statement>Description: Used as the boiler plate for object type cardinality.
Format: each population of {0} contains {1}</statement>
    <unformattedSnippet>each population of {0} contains {1}</unformattedSnippet>
    <contains>
      <snippet name="CardinalityMultipleInstances" />
      <snippet name="CardinalitySingleInstance" />
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
      <snippet name="ObjectType" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ObjectTypeCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ObjectTypeInstanceListClose" replacementCount="0">
    <statement>Description: Text used to close the sample population verbalization list. Format: .</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectTypeInstanceListFinalSeparator" replacementCount="0">
    <statement>Description: Text used to separate the last two items in a sample population verbalization list, or object types. Format: ,</statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectTypeInstanceListOpen" replacementCount="0">
    <statement> Description:  Text and formatting to begin a sample population verbalization of object types block. Format: Examples:</statement>
    <unformattedSnippet>Examples: </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectTypeInstanceListPairSeparator" replacementCount="0">
    <statement>Description: Text used to separate items in a sample population verbalization list. Format: , </statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectTypeInstanceListSeparator" replacementCount="0">
    <statement>Description: Text used to separate items in a sample population verbalization list.	Format: ,</statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectTypeMissing" replacementCount="1">
    <statement>Description: Verbalizes an object type as being missing.</statement>
    <unformattedSnippet>Missing{0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectTypeMissingWithIdentifier" replacementCount="2">
    <statement>Description: Verbalizes an object type as being missing with an identifier. Used for items that reference an object type but have their own id. {0} is the subscript, {1} is the identifier.</statement>
    <unformattedSnippet>Missing{0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ObjectTypeWithSubscript" replacementCount="3">
    <statement>Description: Verbalizes an object type with a subscript. {0} is the name, {1} is the guid id for the element, {2} is the subscript</statement>
    <unformattedSnippet>{0}{2}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OccursInPopulation" replacementCount="2">
    <statement>Description: Verbalizes that an object occurs at most once or more than once in a given population.
Format positive: in each population of {1}, {0} occurs at most once
Format negative: {0} occurs more than once in the same population of {1}</statement>
    <unformattedSnippet>in each population of {1}, {0} occurs at most once</unformattedSnippet>
    <contains>
      <snippet name="CombinationIdentifier" />
      <snippet name="IdentityReferenceQuantifier" />
      <snippet name="UniversalQuantifier" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ModalPossibilityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="OneQuantifier" replacementCount="1">
    <statement>Description: Used for 'at most one' or 'more than one' before an object.
Format positive: at most one {0}
Format negative: more than one {0}</statement>
    <unformattedSnippet>at most one {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachCompactQuantifier" />
      <snippet name="ForEachNegatableCompactQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="SingularExistenceImplicationOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ImpliedUniqueVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="OrLeadListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrLeadListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrLeadListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrNestedListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrNestedListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrNestedListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrNestedListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrTailListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrTailListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrTailListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>where </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="OrTailListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PartialFactTypeDerivation" replacementCount="2">
    <statement>Description: Used to specify a partially derived fact type with its derivation rule.
Format: +{0} if {1}</statement>
    <unformattedSnippet>+{0} if{1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PartialFactTypeStoredDerivation" replacementCount="2">
    <statement>Description: Used to specify a partially derived (and stored) fact type with its derivation rule.
Format: ++{0} if {1}</statement>
    <unformattedSnippet>++{0} if{1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PartialStoredFactTypeDescription" replacementCount="0">
    <statement>Description: A textual specification of stored derivation for a partially derived fact type.
derived instances of this fact type are also stored immediately after they are derived</statement>
    <unformattedSnippet>derived instances of this fact type are also stored immediately after they are derived</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PartialStoredSubtypeDescription" replacementCount="0">
    <statement>Description: A textual specification of stored derivation for a partially derived subtype.
derived instances of this subtype are also stored immediately after they are derived</statement>
    <unformattedSnippet>derived instances of this subtype are also stored immediately after they are derived</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PartialSubtypeDerivation" replacementCount="2">
    <statement>Description: Used to specify a partially derived subtype derivation rule.
Format: +each derived {0} is by definition {1}</statement>
    <unformattedSnippet>+each derived {0} is by definition {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PartialSubtypeStoredDerivation" replacementCount="2">
    <statement>Description: Used to specify a partially derived (and stored) subtype derivation rule.
Format: ++each derived {0} is by definition {1}</statement>
    <unformattedSnippet>++each derived {0} is by definition {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PeriodSeparator" replacementCount="2">
    <statement>Description: Used to delimit two snippet replacements by a snippet.
Format: {0}.{1}</statement>
    <unformattedSnippet>{0}.{1}</unformattedSnippet>
    <contains>
      <snippet name="ReferenceScheme" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="RoleValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="PersonalIdentityCorrelation" replacementCount="2">
    <statement>Description: Relate two variable names of different types that represent the same instance where the first
variable is a personal object type.
Format:  {0} who is {1}</statement>
    <unformattedSnippet>{0} who is {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PersonalLeadIdentityCorrelation" replacementCount="2">
    <statement>Description: A form of PersonalIdentityCorrelation for lead role scenarios. Relate two variables of
different types that represent the same instance where the first variable is an personal object type.
Format: {1} is {0} who</statement>
    <unformattedSnippet>{1} is {0} who</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PersonalPronoun" replacementCount="0">
    <statement>Description: Use in place of a role player name to reference a personal object type with a clear antecedent.</statement>
    <unformattedSnippet>who</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PluralExistenceImplicationOperator" replacementCount="2">
    <statement>Description: Verbalizes an existence condition for a multiple items and a consequent.  Format: there are {0} such that {1}</statement>
    <unformattedSnippet>there are {0} such that{1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
    </usedBy>
  </snippet>
  <snippet name="PortableDataTypeLength" replacementCount="1">
    <statement>Description: Verbalizes the length of a portable data type. Format: ({0})</statement>
    <unformattedSnippet> ({0})</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="PortableDataTypeVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="PortableDataTypeLengthAndScale" replacementCount="2">
    <statement>Description: Verbalizes the length (used here as precision) and scale of a portable data type. Format: ({0},{1})</statement>
    <unformattedSnippet> ({0}, {1})</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="PortableDataTypeVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="PortableDataTypeVerbalization" replacementCount="2">
    <statement>Description: Verbalizes an object's portable data type, plus a suffix showing optional data type properties. Format: Data Type: {0}{1}</statement>
    <unformattedSnippet>Data Type: {0}{1}</unformattedSnippet>
    <contains>
      <snippet name="PortableDataTypeLength" />
      <snippet name="PortableDataTypeLengthAndScale" />
    </contains>
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="PredicatePart" replacementCount="1">
    <statement>Description: Format string to decorate predicate text in between replacement fields. Must contain a {{0}}. Replacement field {0} is the FactType name, and {1} is the guid id for the element.</statement>
    <unformattedSnippet>{{0}}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="QueryNamedParameter" replacementCount="2">
    <statement>Description: Describe a query parameter with an associated name.
Format: {0}=name, {1}=type name</statement>
    <unformattedSnippet>{1}={0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="QueryParameterContainer" />
      <snippet name="QueryVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="QueryParameterContainer" replacementCount="1">
    <statement>Description: Outer container for listing query parameters. Used as part of a query verbalization.
Format: given {0}</statement>
    <unformattedSnippet>given {0} </unformattedSnippet>
    <contains>
      <snippet name="QueryNamedParameter" />
      <snippet name="QueryUnnamedParameter" />
    </contains>
    <containedIn>
      <snippet name="QueryVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="QueryUnnamedParameter" replacementCount="1">
    <statement>Description: Describe a query parameter with no associated name. Format: given {0}</statement>
    <unformattedSnippet>{0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="QueryParameterContainer" />
      <snippet name="QueryVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="QueryVerbalization" replacementCount="3">
    <statement>Description: Root verbalization for a query. Containers a parameter (defined with QueryParameterContainer if present) and projection lists plus the derivation rule.
Format: {0}select {1} where {2}</statement>
    <unformattedSnippet>{0}select {1} where{2}</unformattedSnippet>
    <contains>
      <snippet name="QueryNamedParameter" />
      <snippet name="QueryParameterContainer" />
      <snippet name="QueryUnnamedParameter" />
    </contains>
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ReferenceModeVerbalization" replacementCount="1">
    <statement>Description: Verbalizes the mode in which an object is referenced. Format: Reference Mode: {0}</statement>
    <unformattedSnippet>Reference Mode: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ReferenceScheme" replacementCount="2">
    <statement>Description: Used to enclose and format a reference scheme replacement in brackets.
Format: {0}({1})</statement>
    <unformattedSnippet>{0}({1})</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="PeriodSeparator" />
    </containedIn>
    <usedBy>
      <constraint name="RoleValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="ReferenceSchemeVerbalization" replacementCount="1">
    <statement>Description: Verbalizes the way in which an object is referenced. Format: Reference Scheme: {0}</statement>
    <unformattedSnippet>Reference Scheme: {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="ReflexivePronoun" replacementCount="0">
    <statement>Description: Use in place of a role player name to refer to an object type with a clear antecedent.</statement>
    <unformattedSnippet>itself</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ReflexiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ReflexiveQuantifier" replacementCount="1">
    <statement>Description: Used in place of a reflexive pronoun when an antecedent is not guaranteed.  Format: {0} itself</statement>
    <unformattedSnippet>{0} itself</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="ReflexiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="RoleHeader" replacementCount="1">
    <statement>Description: A header for contained role data.  Format: role for {0}</statement>
    <unformattedSnippet>role for {0}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="RoleHeaderWithName" replacementCount="2">
    <statement>Description: A role header used to indicate a role name.  Format: role for {0}, named {0}</statement>
    <unformattedSnippet>role for {0}, named {1}</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="RolePathBlockLeadCollapseForSnippetDirective" replacementCount="0">
    <statement>Description: Specify a space-separated list of snippet names to specify list snippets that
would allow lead role collapsing based on the RolePathCollapsibleLeadDirective, but do not actually support this construct.
This allows a final override to block the collapsing behavior for specific snippets. This is checked for the
(Negated)[Chained|And|Or|Xor][Tail|Nested]List[(Collapsed)Open|Separator] and the ChainedList*Restrction* snippets.
Format: AndTailListOpen OrTailListOpen</statement>
    <unformattedSnippet>AndTailListOpen OrTailListOpen ChainedListLocalRestrictionSeparator ChainedListComplexRestrictionSeparator ChainedListTopLevelComplexRestrictionSeparator</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="RolePathCollapsibleLeadDirective" replacementCount="0">
    <statement>Description: Specify a space-separated list of items to determine if a list style supports
collapsing a repeated lead role. Allowed values are {Chain, And, Or, Xor, !And, !Or, !Xor, !Chain}. The !Chain directive
here applies to the long form of negation, not the inlined form where the verbose negation constructs are not used.
A collapsed lead completely eliminates a lead role player. For example, '... Person has FirstName and has LastName',
with Person eliminated from the second fact type rendering.
Format: And Or Chain</statement>
    <unformattedSnippet>And Or Chain</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="RolePathCollapsibleListOpenForBackReferenceDirective" replacementCount="0">
    <statement>Description: Specify a space-separated list of items to determine if the first item in a list style supports
collapsing to allow a back reference. The allowed values here are the same as the RolePathCollapsibleLeadDirective and
should not intersect the values used for the RolePathHeaderListDirective. A back reference uses a personal or impersonal
pronoun in place of a restatement of the lead role player. The back reference must immediately follow the preceding noun.
This directive allows a backreference to be used by replacing the *[Tail|Nested]ListOpen snippets with the *[Tail|Nested]ListCollapsedOpen
snippets. Lead list types do not support back referencing.
Format: And Or Chain</statement>
    <unformattedSnippet>And Or Chain</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="RolePathHeaderListDirective" replacementCount="0">
    <statement>Description: Specify a space-separated list of items to determine if split lists are rendered as
integrated or separate blocks. Allowed values are {And, Or, Xor, !And, !Or, !Xor}.
Format: !And !Or Xor !Xor</statement>
    <unformattedSnippet>!And !Or Xor !Xor</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="RolePathListCloseOutdentSnippets" replacementCount="0">
    <statement>Description: A space separated list of list closure snippet names from this enum that reverse an indentation.
Trailing outdents can be tracked specially during formatting so that external text or outer list separator and close
elements on the same line as the outdent keeps the same indentation level.
Format: ChainedListClose NegatedChainedListClose AndTailListClose AndNestedListClose NegatedAndLeadListClose NegatedAndTailListClose NegatedAndNestedListClose OrTailListClose OrNestedListClose NegatedOrLeadListClose NegatedOrTailListClose NegatedOrNestedListClose XorLeadListClose XorTailListClose XorNestedListClose NegatedXorLeadListClose NegatedXorTailListClose NegatedXorNestedListClose</statement>
    <unformattedSnippet>ChainedListClose NegatedChainedListClose AndTailListClose AndNestedListClose NegatedAndLeadListClose NegatedAndTailListClose NegatedAndNestedListClose OrTailListClose OrNestedListClose NegatedOrLeadListClose NegatedOrTailListClose NegatedOrNestedListClose XorLeadListClose XorTailListClose XorNestedListClose NegatedXorLeadListClose NegatedXorTailListClose NegatedXorNestedListClose</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="RolePathOutdentAwareTrailingListSnippets" replacementCount="0">
    <statement>Description: A space separated list of list separators and close elements that must be placed before any
active trailing outdent snippets.
Format: NegatedAndLeadListSeparator NegatedAndNestedListSeparator NegatedAndTailListSeparator NegatedOrLeadListSeparator NegatedOrNestedListSeparator NegatedOrTailListSeparator XorLeadListSeparator XorNestedListSeparator XorTailListSeparator NegatedXorLeadListSeparator NegatedXorNestedListSeparator NegatedXorTailListSeparator</statement>
    <unformattedSnippet>NegatedAndLeadListSeparator NegatedAndNestedListSeparator NegatedAndTailListSeparator NegatedOrLeadListSeparator NegatedOrNestedListSeparator NegatedOrTailListSeparator XorLeadListSeparator XorNestedListSeparator XorTailListSeparator NegatedXorLeadListSeparator NegatedXorNestedListSeparator NegatedXorTailListSeparator NegatedChainedListClose</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="SameTypeIdentityInequalityOperator" replacementCount="2">
    <statement>Description: Used to specify that two instances of the same type are not the same instance.
Format: {0} is not {1}</statement>
    <unformattedSnippet>{0} is not {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="LogicalAndOperator" />
    </containedIn>
    <usedBy>
      <constraint name="AntisymmetricRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="SelfReference" replacementCount="1">
    <statement>Description: Allows the snippet replacement to verbalize itself. Format: {0}</statement>
    <unformattedSnippet>{0}</unformattedSnippet>
    <contains>
      <snippet name="DerivedFactTypeReference" />
      <snippet name="DerivedSubtypeReference" />
      <snippet name="DynamicRuleReference" />
      <snippet name="JoinedEqualityConstraintReference" />
      <snippet name="JoinedExclusionConstraintReference" />
      <snippet name="JoinedFrequencyConstraintReference" />
      <snippet name="JoinedRingConstraintReference" />
      <snippet name="JoinedSetComparisonSequenceReference" />
      <snippet name="JoinedSubsetConstraintReference" />
      <snippet name="JoinedUniquenessConstraintReference" />
      <snippet name="JoinedValueComparisonConstraintReference" />
      <snippet name="ObjectType" />
      <snippet name="SelfReference" />
    </contains>
    <containedIn>
      <snippet name="ConditionalMultiLine" />
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="DynamicRuleQuantifiers" />
      <snippet name="DynamicRuleVerbalization" />
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="LogicalAndOperator" />
      <snippet name="ModalPossibilityOperator" />
      <snippet name="SelfReference" />
    </containedIn>
    <usedBy>
      <constraint name="AntisymmetricRingVerbalizer" />
      <constraint name="AsymmetricRingVerbalizer" />
      <constraint name="FrequencyConstraint" />
      <constraint name="IntransitiveRingVerbalizer" />
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="StronglyIntransitiveRingVerbalizer" />
      <constraint name="SymmetricRingVerbalizer" />
      <constraint name="TransitiveRingVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleListClose" replacementCount="0">
    <statement>Description: Text used at the end of a simple list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="FrequencyConstraint" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the final item in simple list. Format: , and</statement>
    <unformattedSnippet>, and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="FrequencyConstraint" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleListOpen" replacementCount="0">
    <statement>Description:  Text used at the end of a simple list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="FrequencyConstraint" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in simple list with two items. Format: and</statement>
    <unformattedSnippet> and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="FrequencyConstraint" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in simple list. Format: ,</statement>
    <unformattedSnippet>, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="FrequencyConstraint" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
      <constraint name="UniquenessPossibilityVerbalizer" />
      <constraint name="ValueComparisonConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalAndListClose" replacementCount="0">
    <statement>Description: Text used at the end of a simple logical and list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalAndListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in a simple logical and list.  Format: and</statement>
    <unformattedSnippet> and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalAndListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of a simple logical and list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalAndListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a simple logical and list.  Format: and</statement>
    <unformattedSnippet> and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalAndListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a simple logical and list.  Format: and</statement>
    <unformattedSnippet> and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="EqualityConstraint" />
      <constraint name="ExclusionConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalOrListClose" replacementCount="0">
    <statement>Description:  Text used at the end of a simple logical or list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalOrListFinalSeparator" replacementCount="0">
    <statement>Description:  Used to separate the last two items in a simple logical or list.  Format: or</statement>
    <unformattedSnippet> or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalOrListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of a simple logical or list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalOrListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a simple logical or list.  Format: or</statement>
    <unformattedSnippet> or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="SimpleLogicalOrListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a simple logical or list.  Format: or</statement>
    <unformattedSnippet> or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="SingleValueValueConstraint" replacementCount="2">
    <statement>Description: Used to verbalize a value range constraint with one range, where the min value is equal to the max value.
Format: the possible value of {0} is {1}</statement>
    <unformattedSnippet>the possible value of {0} is {1}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="SingularExistenceImplicationOperator" replacementCount="2">
    <statement>Description: Verbalizes an existence condition for a single item and a consequent.  Format: there is {0} such that {1}</statement>
    <unformattedSnippet>there is {0} such that{1}</unformattedSnippet>
    <contains>
      <snippet name="CombinationIdentifier" />
      <snippet name="DefiniteArticle" />
      <snippet name="MoreThanOneQuantifier" />
      <snippet name="OneQuantifier" />
    </contains>
    <containedIn>
      <snippet name="ForEachIndentedQuantifier" />
      <snippet name="ForEachNegatableIndentedQuantifier" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="ModalPossibilityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="FrequencyConstraint" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="StronglyIntransitiveConsequent" replacementCount="2">
    <statement>Description: Used to verbalize a strongly intransitive ring constraint.
Format: it is not true that {0} is indirectly related to {1} by repeatedly applying this fact type</statement>
    <unformattedSnippet>it is not true that {0} is indirectly related to {1} by repeatedly applying this fact type</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="ConditionalMultiLineIndented" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="StronglyIntransitiveRingVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="SubtypeMetaReading" replacementCount="3">
    <statement>Description: Used to describe the relationship between a Subtype and its Supertype at the meta level (i.e: Each Man is an instance of Person).
Format: {0}=subtype, {1}=supertype, {2}=SubtypeFact identifier</statement>
    <unformattedSnippet>each {0} is an instance of {1}</unformattedSnippet>
    <contains>
      <snippet name="ObjectType" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="TextInstanceValue" replacementCount="1">
    <statement>Description: Used to output a text instance value. Format: '{0}'</statement>
    <unformattedSnippet>'{0}'</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="DefaultValuePrefix" />
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="NearestValueConstraintVerbalizer" />
      <constraint name="RoleValueConstraint" />
      <constraint name="ValueTypeValueConstraint" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalAndListClose" replacementCount="0">
    <statement>Description: Text used at the end of a top level indented logical and list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalAndListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in a top level indented logical and list.  Format: \n and that</statement>
    <unformattedSnippet>and that </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalAndListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of a top level indented logical and list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalAndListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a top level indented logical and list.  Format: \n and that</statement>
    <unformattedSnippet>and that </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalAndListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a top level indented logical and list.  Format: \n and that</statement>
    <unformattedSnippet>and that </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="UniquenessPossibilityVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalOrListClose" replacementCount="0">
    <statement>Description: Text used at the end of a top level indented logical or list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalOrListFinalSeparator" replacementCount="0">
    <statement>Description: Used to separate the last two items in a top level indented logical or list.  Format: \n or</statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalOrListOpen" replacementCount="0">
    <statement>Description: Text used at the beginning of a top level indented logical or list.</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalOrListPairSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a top level indented logical or list.  Format: \n or</statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="TopLevelIndentedLogicalOrListSeparator" replacementCount="0">
    <statement>Description: Used to separate items in a top level indented logical or list.  Format: \n or</statement>
    <unformattedSnippet>or </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy>
      <constraint name="DisjunctiveMandatoryVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="UnaryRoleCardinality" replacementCount="3">
    <statement>Description: Used as the boiler plate for unary role cardinality.
Format: for each population of '{0}', the number of {1} instances is {2}</statement>
    <unformattedSnippet>for each population of &amp;#8220;{0}&amp;#8221;,the number of {1} instances is {2}</unformattedSnippet>
    <contains>
      <snippet name="CountRangeExact" />
      <snippet name="CountRangeMaxUnbounded" />
      <snippet name="CountRangeMinAndMax" />
      <snippet name="CountRangeMinUnbounded" />
      <snippet name="ObjectType" />
    </contains>
    <containedIn>
      <snippet name="ImpliedModalNecessityOperator" />
    </containedIn>
    <usedBy>
      <constraint name="UnaryRoleCardinalityConstraint" />
    </usedBy>
  </snippet>
  <snippet name="UniversalQuantifier" replacementCount="1">
    <statement>Description: Used for 'each' before an object name to signify the quantity associated with the object.  Format: each {0}</statement>
    <unformattedSnippet>each {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="CombinationIdentifier" />
      <snippet name="ImpliedModalNecessityOperator" />
      <snippet name="OccursInPopulation" />
    </containedIn>
    <usedBy>
      <constraint name="CombinedMandatoryUniqueVerbalizer" />
      <constraint name="DisjunctiveMandatoryVerbalizer" />
      <constraint name="FrequencyConstraint" />
      <constraint name="ImpliedMandatoryVerbalizer" />
      <constraint name="ImpliedUniqueVerbalizer" />
      <constraint name="SimpleMandatoryVerbalizer" />
      <constraint name="UniquenessConstraintVerbalizer" />
    </usedBy>
  </snippet>
  <snippet name="ValueTypeVerbalization" replacementCount="1">
    <statement>Description: Verbalizes an object as being a value type. Format: {0} is a value type</statement>
    <unformattedSnippet>{0} is a value type</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VariableAddAction" replacementCount="1">
    <statement>Description: A decorated for a variable listed in the 'add' section of a dynamic rule.
Format: new {0}</statement>
    <unformattedSnippet>new {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="DynamicRuleAdditions" />
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="VariableAddedQuantifier" replacementCount="1">
    <statement>Description: A universally quanfied variable in a dynamic rule is part of the 'added' state.
Format: added {0}</statement>
    <unformattedSnippet>added {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="DynamicRuleQuantifiers" />
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="VariableDeletedQuantifier" replacementCount="1">
    <statement>Description: A universally quanfied variable in a dynamic rule is part of the 'deleted' state.
Format: deleted {0}</statement>
    <unformattedSnippet>deleted {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="DynamicRuleQuantifiers" />
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="VariableExistence" replacementCount="1">
    <statement>Description: Assert variable existence as a complete statement, as opposed to the
VariableIntroductionClause used to introduce a variable using a prefix.
Format: {0} exists</statement>
    <unformattedSnippet>{0} exists</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VariableInitialQuantifier" replacementCount="1">
    <statement>Description: A universally quanfied variable in a dynamic rule is part of the 'initial' state.
Format: initial {0}</statement>
    <unformattedSnippet>initial {0}</unformattedSnippet>
    <contains />
    <containedIn>
      <snippet name="DynamicRuleQuantifiers" />
      <snippet name="DynamicRuleVerbalization" />
    </containedIn>
    <usedBy />
  </snippet>
  <snippet name="VariableIntroductionClause" replacementCount="1">
    <statement>Description: Introduce variables inline in the verbalization phrase. The replacement is either
a single value or a list, and the quantifiers (some, no, that) are already included in the replacement list.
Format: for {0},</statement>
    <unformattedSnippet>for {0}, </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VariableIntroductionSeparator" replacementCount="0">
    <statement>Description: The list separator for introducing multiple variables in a single clause.
Format: and</statement>
    <unformattedSnippet> and </unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerCloseVerbalization" replacementCount="0">
    <statement>Description: Used by the verbalizer to close a verbalization opened by VerbalizerOpenVerbalization</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerDecreaseIndent" replacementCount="0">
    <statement>Description: Used by the verbalizer to close indent opened by VerbalizerIncreaseIndent</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerDocumentFooter" replacementCount="0">
    <statement>Description: Used by the verbalizer to close a document</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerDocumentHeader" replacementCount="14">
    <statement>Description: Used by the verbalizer to open a document. The document header gets replacement fields in the following order:
{0} font-family
{1} font-size
{2} predicate text color
{3} predicate text bold
{4} object name color
{5} object name bold
{6} formal item color
{7} formal item bold
{8} note color
{9} note bold
{10} reference mode color
{11} reference mode bold
{12} instance value color
{13} instance value bold</statement>
    <unformattedSnippet>
			


	ORM2 Verbalization
	
		body, table {{ font-family: {0}; font-size: {1}pt; color: {2}; {3} }}
		body {{ padding: 0em .1em; }}
		table.hidden, tr.hidden, td.hidden {{ margin: 0em; padding: 0em; border-collapse: collapse;}}
		td.hidden {{ vertical-align: top; }}
		table.hidden {{ display:inline; }}
		a {{text-decoration:none; }}
		a:hover {{background-color:infobackground; }}
		.objectType {{ color: {4}; {5} }}
		.objectTypeMissing {{ color: {4}; {5} }}
		.referenceMode {{ color: {10}; {11} }}
		.predicateText {{ color: {2}; {3} }}
		.quantifier {{ color: {6}; {7} }}
		.primaryErrorReport {{ color: red; font-weight: bolder; }}
		.secondaryErrorReport {{ color: red; }}
		.verbalization {{ }}
		.indent {{ left: 20px; position: relative; }}
		.smallIndent {{ left: 8px; position: relative;}}
		.listSeparator {{ color: windowtext; font-weight: 200;}}
		.logicalOperator {{ color: {6}; {7}}}
		.note {{ color: {8}; font-style: italic; {9} }}
		.definition {{ color: {8}; font-style: italic; {9} }}
		.notAvailable {{ font-style: italic; }}
		.instance {{ color: {12}; {13} }}
	

</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerFontWeightBold" replacementCount="0">
    <statement>Description: The text to insert to indicate a bold font.</statement>
    <unformattedSnippet>font-weight: bold;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerFontWeightNormal" replacementCount="0">
    <statement>Description: The text to insert to indicate a normal font weight.</statement>
    <unformattedSnippet>font-weight: normal;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerIncreaseIndent" replacementCount="0">
    <statement>Description: Used by the verbalizer to indent a child verbalization</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerNewLine" replacementCount="0">
    <statement>Description: Used by the verbalizer to enter a new line. Format: \n</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="VerbalizerOpenVerbalization" replacementCount="0">
    <statement>Description: Used by the verbalizer around a single verbalization</statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorLeadListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorLeadListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>exactly one of the following is true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorLeadListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorNestedListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorNestedListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>exactly one of the following is true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorNestedListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>exactly one of the following is true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorNestedListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorTailListClose" replacementCount="0">
    <statement></statement>
    <unformattedSnippet></unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorTailListCollapsedOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>exactly one of the following is true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorTailListOpen" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>exactly one of the following is true:</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
  <snippet name="XorTailListSeparator" replacementCount="0">
    <statement></statement>
    <unformattedSnippet>;</unformattedSnippet>
    <contains />
    <containedIn />
    <usedBy />
  </snippet>
</snippets>