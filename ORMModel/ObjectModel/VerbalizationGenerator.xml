<?xml version="1.0" encoding="utf-8"?>
<VerbalizationRoot
	xmlns="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator VerbalizationGenerator.xsd"
	snippetsLocation="VerbalizationCoreSnippets/VerbalizationCoreSnippets.xml"
	snippetsSchemaLocation="VerbalizationCoreSnippets/VerbalizationCoreSnippets.xsd">
	<Copyright name="Common Public License Copyright Notice">
		<CopyrightLine>/**************************************************************************\</CopyrightLine>
		<CopyrightLine>* Natural Object-Role Modeling Architect for Visual Studio                 *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* Copyright © Neumont University. All rights reserved.                     *</CopyrightLine>
		<CopyrightLine>* Copyright © ORM Solutions, LLC. All rights reserved.                     *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* The use and distribution terms for this software are covered by the      *</CopyrightLine>
		<CopyrightLine>* Common Public License 1.0 (http://opensource.org/licenses/cpl) which     *</CopyrightLine>
		<CopyrightLine>* can be found in the file CPL.txt at the root of this distribution.       *</CopyrightLine>
		<CopyrightLine>* By using this software in any fashion, you are agreeing to be bound by   *</CopyrightLine>
		<CopyrightLine>* the terms of this license.                                               *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* You must not remove this notice, or any other, from this software.       *</CopyrightLine>
		<CopyrightLine>\**************************************************************************/</CopyrightLine>
	</Copyright>
	<Constructs>
		<ORMModel>
			<Snippet ref="ModelVerbalization">
				<ContextName/>
				<ContextId/>
			</Snippet>
		</ORMModel>
		<!-- Generate FactType verbalization along with constraints -->
		<FactType>
			<ConditionalSnippet conditionalMatch="HasStoredDerivationRule">
				<Snippet conditionalMatch="DerivationRuleIsPartial" ref="PartialStoredFactTypeDescription"/>
				<Snippet ref="FullStoredFactTypeDescription"/>
			</ConditionalSnippet>
		</FactType>
		<SubtypeFact>
			<Snippet ref="ImpliedModalNecessityOperator" conditionalBlockContext="SubtypeFactRolePlayers">
				<Snippet ref="SubtypeMetaReading">
					<Snippet ref="ObjectType">
						<SubtypeName/>
						<SubtypeId/>
					</Snippet>
					<Snippet ref="ObjectType">
						<SupertypeName/>
						<SupertypeId/>
					</Snippet>
					<ContextId/>
				</Snippet>
			</Snippet>
		</SubtypeFact>
		<QueryBase>
			<Snippet ref="QueryVerbalization" conditionalMatch="HasVerbalizableQueryDerivationPath">
				<ConditionalReplacement>
					<Snippet ref="QueryParameterContainer" conditionalMatch="IsParameterized">
						<IterateQueryParameters listStyle="SimpleLogicalAndList">
							<ConditionalSnippet>
								<Snippet ref="QueryNamedParameter" conditionalMatch="IsNamedParameter"/>
								<Snippet ref="QueryUnnamedParameter"/>
								<SnippetReplacements>
									<ProvidedRolePlayer rolePlayerKey="QueryParameter" markAsHead="true"/>
									<ParameterName/>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateQueryParameters>
					</Snippet>
				</ConditionalReplacement>
				<IterateRoles listStyle="SimpleLogicalAndList" match="providedFactRoles">
					<ProvidedRolePlayer rolePlayerKey="FactRole" markAsHead="true"/>
				</IterateRoles>
				<DerivationPath/>
			</Snippet>
		</QueryBase>
		<!-- Generate ObjectType verbalization along with constraints -->
		<ObjectType>
			<ConditionalSnippet>
				<Snippet ref="EntityTypeVerbalization" conditionalMatch="IsEntityType"/>
				<Snippet ref="ValueTypeVerbalization"/>
				<SnippetReplacements>
					<Snippet ref="ObjectType">
						<ContextName isObjectType="true"/>
						<ContextId/>
					</Snippet>
				</SnippetReplacements>
			</ConditionalSnippet>
			<ConditionalSnippet conditionalMatch="HasVerbalizableSubtypeDerivationPath">
				<Snippet conditionalMatch="DerivationRuleIsPartialAndStored" ref="PartialSubtypeStoredDerivation"/>
				<Snippet conditionalMatch="DerivationRuleIsPartial" ref="PartialSubtypeDerivation"/>
				<Snippet conditionalMatch="DerivationRuleIsStored" ref="FullSubtypeStoredDerivation"/>
				<Snippet ref="FullSubtypeDerivation"/>
				<SnippetReplacements>
					<ProvidedRolePlayer rolePlayerKey="DerivationRule"/>
					<DerivationPath/>
				</SnippetReplacements>
			</ConditionalSnippet>
			<ErrorReportHere/>
			<Snippet ref="ObjectifiesFactTypeVerbalization" conditionalMatch="IsObjectifiedFactType" conditionalBlockContext="ObjectifiedFactType">
				<Snippet ref="ObjectType">
					<ContextName isObjectType="true"/>
					<ContextId/>
				</Snippet>
				<Fact/>
			</Snippet>
			<Snippet ref="ReferenceSchemeVerbalization" conditionalMatch="HasUnobjectifiedPreferredIdentifier">
				<!-- UNDONE: Non-trivial join path external identifiers are not currently supported. Verbalize
				the join path here when they are. -->
				<IterateRoles match="preferredIdentifier" listStyle="CompoundList">
					<Fact/>
				</IterateRoles>
			</Snippet>
			<Snippet ref="ReferenceModeVerbalization" conditionalMatch="HasReferenceMode">
				<ReferenceMode/>
			</Snippet>
			<Snippet ref="IndependentVerbalization" conditionalMatch="IsIndependent">
				<Snippet ref="ObjectType">
					<ContextName isObjectType="true"/>
					<ContextId/>
				</Snippet>
			</Snippet>
			<Snippet ref="PortableDataTypeVerbalization" conditionalMatch="HasPortableDataType">
				<PortableDataType/>
			</Snippet>
			<ConditionalSnippet conditionalMatch="HasStoredDerivationRule">
				<Snippet conditionalMatch="DerivationRuleIsPartial" ref="PartialStoredSubtypeDescription"/>
				<Snippet ref="FullStoredSubtypeDescription"/>
			</ConditionalSnippet>
			<Snippet ref="SelfReference" conditionalMatch="VerbalizeFactTypesWithBrowserObjectType">
				<IterateRoles match="playedRoles" listStyle="FactTypeList" verifyCanVerbalizeFactType="true" uniqueFactType="true">
					<Fact subtypeMetaReading="true" closeSentence="true"/>
				</IterateRoles>
			</Snippet>
		</ObjectType>
		<Definition>
			<Snippet ref="DescriptionVerbalization">
				<NoteText/>
			</Snippet>
		</Definition>
		<Note>
			<Snippet ref="NotesVerbalization">
				<NoteText/>
			</Snippet>
		</Note>
		<DerivationNote>
			<Snippet ref="DerivationNoteVerbalization">
				<ExpressionBody/>
			</Snippet>
		</DerivationNote>
		<ErrorReports>
			<ErrorReport type="ErrorReport" childHelperFor="Role" childHelperErrorReport="true"/>
		</ErrorReports>
		<!-- Generate constraint verbalizations -->
		<Constraints>
			<Constraint type="SubsetConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireAllPrimaryLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="Conditional">
									<IterateSequences listStyle="null" pass="first">
										<SequenceJoinPath markTrailingOutdentStart="true">
											<IterateRoles listStyle="null" match="constraintRoles">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="true"/>
													<ProvidedPredicateReplacement quantify="true"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</IterateSequences>
									<IterateSequences listStyle="null" pass="notFirst">
										<SequenceJoinPath markTrailingOutdentStart="true">
											<IterateRoles match="constraintRoles" listStyle="null">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="true"/>
													<ProvidedPredicateReplacement quantify="true"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</IterateSequences>
								</Snippet>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachIndentedQuantifier">
									<IterateSequences listStyle="null" pass="first">
										<IterateRoles match="providedConstraintRoles" listStyle="null" pass="first" markProvidedConstraintRolesAsHead="true"/>
									</IterateSequences>
									<Snippet ref="Conditional">
										<IterateSequences listStyle="null" pass="first">
											<SequenceJoinPath markTrailingOutdentStart="true">
												<IterateRoles match="constraintRoles" listStyle="null" pass="first">
													<Fact readingChoice="PreferLeadReading">
														<ProvidedPredicateReplacement match="included" quantify="true"/>
														<ProvidedPredicateReplacement quantify="true"/>
													</Fact>
												</IterateRoles>
											</SequenceJoinPath>
										</IterateSequences>
										<IterateSequences listStyle="null" pass="notFirst">
											<SequenceJoinPath markTrailingOutdentStart="true">
												<IterateRoles match="constraintRoles" listStyle="null" pass="first">
													<Fact readingChoice="PreferLeadReading">
														<ProvidedPredicateReplacement match="included" quantify="true"/>
														<ProvidedPredicateReplacement quantify="true"/>
													</Fact>
												</IterateRoles>
											</SequenceJoinPath>
										</IterateSequences>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="Conditional" applyTrailingOutdentHere="true">
							<IterateSequences listStyle="CompoundList" pass="first" compositeList="true">
								<SequenceJoinPath markTrailingOutdentStart="true">
									<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="true"/>
											<ProvidedPredicateReplacement quantify="true"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
							</IterateSequences>
							<IterateSequences listStyle="CompoundList" pass="notFirst" compositeList="true">
								<SequenceJoinPath markTrailingOutdentStart="true">
									<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="true"/>
											<ProvidedPredicateReplacement quantify="true"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
							</IterateSequences>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- Implied single-role internal uniqueness constraint on proxy role of implied binary fact -->
			<Constraint type="ImpliedUniqueVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<ConstrainedRoles constraintArity="1" factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachCompactQuantifier">
									<IterateRoles listStyle="null" match="included" hyphenBind="true"/>
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="OneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier">
						<IterateRoles listStyle="null" match="included"/>
						<IterateRoles listStyle="null" match="excluded"/>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="1" factArity="2">
					<!-- sign="negative" is implied by the previous element -->
					<!-- The pattern is the same whether or not we have a lead reading, so don't use ConditionalReading here -->
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
							<Snippet ref="ModalPossibilityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
			</Constraint>
			<!-- Implied simple mandatory on constraint on proxy role of implied binary fact -->
			<Constraint type="ImpliedMandatoryVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- FactType.DefaultBinaryMissingUniquenessVerbalizer -->
			<Constraint type="DefaultBinaryMissingUniquenessVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- The context here is an alethic constraint covering the opposite single role -->
				<EnableSubscripts custom="defaultPlain"/>
				<ConstrainedRoles factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireNonLeadReading">
							<Snippet ref="ModalPossibilityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="MoreThanOneQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ModalPossibilityOperator">
								<ConditionalReplacement>
									<Snippet ref="ForEachNegatableCompactQuantifier" alternateSign="negative" conditionalMatch="BinaryRingFactType">
										<IterateRoles match="excluded" pass="first" listStyle="null" subscript="true"/>
										<Fact readingChoice="Context">
											<PredicateReplacement match="included">
												<Snippet ref="MoreThanOneQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement subscript="true">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
										</Fact>
									</Snippet>
									<Fact readingChoice="Context">
										<PredicateReplacement match="included">
											<Snippet ref="MoreThanOneQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="IdentityReferenceQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</ConditionalReplacement>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- FactType.CombinedMandatoryUniqueVerbalizer -->
			<Constraint type="CombinedMandatoryUniqueVerbalizer" childHelperFor="FactType" childHelperErrorReport="true" patternGroup="InternalConstraint">
				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2" sign="positive">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExactlyOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachCompactQuantifier">
									<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
										<Fact>
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
											<PredicateReplacement>
												<Snippet ref="ExactlyOneQuantifier"/>
											</PredicateReplacement>
										</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- Break mandatory constraint verbalization into two parts, at least for now. The
			issue is that the 'compatibleColumns' setting used for disjunctive mandatory constraints
			across multiple compatible types is not compatible with the code generate by custom subscripts,
			and getting the items compatible is non-trivial. -->
			<Constraint type="MandatoryConstraint" patternGroup="SetConstraint" deferMatchesTo="VerbalizeByConstraintArity"/>
			<Constraint type="SimpleMandatoryVerbalizer" childHelperFor="MandatoryConstraint" patternGroup="SetConstraint">
				<!-- Handle internal constraint patterns first -->
				<!-- 3.1.1 unary predicate -->
				<!-- Each A R -->
				<EnableSubscripts custom="defaultPlain"/>
				<ConstrainedRoles constraintArity="1" factArity="1" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="UniversalQuantifier">
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>

				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles constraintArity="1" factArity="2" maxFactArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading or front text -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachNegatableCompactQuantifier">
									<IterateRoles match="included" listStyle="null" hyphenBind="true" subscript="true"/>
									<Fact>
										<PredicateReplacement match="included" subscript="true">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- 3.1.3 n-ary predicate -->
				<ConstrainedRoles constraintArity="1" minFactArity="3" sign="positive">
					<ConditionalReading>
						<!-- mandatory role starts reading -->
						<!-- Each A R some B1 ... some Bn -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading-->
						<!-- For each A,
							some B1 R ... that A ... some Bn -->
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachIndentedQuantifier">
									<IterateRoles match="included" listStyle="null" hyphenBind="true" subscript="true"/>
									<Fact>
										<PredicateReplacement match="included" subscript="true">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<ConstrainedRoles constraintArity="1" minFactArity="3">
					<!-- sign="negative" implied by previous condition -->
					<ConditionalReading>
						<!-- mandatory role starts reading -->
						<!-- Each A R some B1 ... some Bn -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement once="useNegation">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading-->
						<!-- For each A,
							some B1 R ... that A ... some Bn -->
						<ReadingChoice>
							<Snippet ref="ForEachNegatableIndentedQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true" subscript="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included" subscript="true">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement once="useNegation">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="DisjunctiveMandatoryVerbalizer" childHelperFor="MandatoryConstraint" patternGroup="SetConstraint">

				<!-- Start disjunctive mandatory constraints -->
				<!-- Unaries are the only reading choice that has an optional negative reading -->
				<ConstrainedRoles sign="negative" maxFactArity="1" sameConstraintRolePlayers="true">
					<Snippet ref="ModalPossibilityOperator">
						<Snippet ref="NegativeReadingForUnaryOnlyDisjunctiveMandatory">
							<IterateRoles listStyle="null" match="constraintRoles" pass="first"/>
							<IterateFacts listStyle="IndentedCompoundList"/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" maxFactArity="1" sameConstraintRolePlayers="true">
					<ConditionalReading>
						<ReadingChoice match="RequireAllLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<IterateRoles listStyle="TopLevelIndentedLogicalOrList" match="constraintRoles">
									<Fact readingChoice="Context">
										<PredicateReplacement match="primary" pass="first">
											<Snippet ref="UniversalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Snippet ref="null"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="null" pass="first" match="constraintRoles"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<IterateRoles listStyle="SimpleLogicalOrList" match="constraintRoles">
										<Fact readingChoice="PreferPrimaryLeadReadingNoFrontText">
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" sameConstraintRolePlayers="true" blockHelpers="pathVerbalizer">
					<ConditionalReading>
						<ReadingChoice match="RequireAllPrimaryLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<CompositeList listStyle="TopLevelIndentedLogicalOrList">
									<IterateRoles minFactArity="2" match="constraintRoles">
										<Fact readingChoice="Context">
											<PredicateReplacement match="primary" pass="first">
												<Snippet ref="UniversalQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="primary">
												<Snippet ref="null"/>
											</PredicateReplacement>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
									<IterateRoles factArity="1" match="constraintRoles">
										<Fact readingChoice="Context">
											<PredicateReplacement>
												<Snippet ref="null"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
								</CompositeList>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachCompactQuantifier">
									<IterateRoles match="providedConstraintRoles" pass="first" listStyle="SimpleList" markProvidedConstraintRolesAsHead="true" resolveProvidedConstraintRoleSupertype ="true" quantifyProvidedConstraintRoles="false"/>
									<CompositeList listStyle="IndentedLogicalOrList">
										<IterateRoles match="providedConstraintRoles" minFactArity="2">
											<Fact readingChoice="PreferPrimaryLeadReadingNoFrontText">
												<ProvidedPredicateReplacement match="primary" quantify="true"/>
												<!-- If there are multiple constrained roles in the same fact type then both the
												constrained role and the role are registered. The excluded fallback picks up the
												registered role. -->
												<ProvidedPredicateReplacement match="excluded" quantify="true"/>
											</Fact>
										</IterateRoles>
										<IterateRoles factArity="1" match="providedConstraintRoles">
											<Fact>
												<ProvidedPredicateReplacement match="included" quantify="true"/>
											</Fact>
										</IterateRoles>
									</CompositeList>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" blockHelpers="pathVerbalizer">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateRoles match="providedConstraintRoles" pass="first" listStyle="SimpleList" markProvidedConstraintRolesAsHead="true" resolveProvidedConstraintRoleSupertype ="true" quantifyProvidedConstraintRoles="false"/>
							<CompositeList listStyle="IndentedLogicalOrList">
								<IterateRoles match="providedConstraintRoles" minFactArity="2">
									<Fact readingChoice="PreferPrimaryLeadReadingNoFrontText">
										<ProvidedPredicateReplacement match="primary" minimizeHeadSubscripting="true" quantify="true"/>
										<ProvidedPredicateReplacement match="excluded" minimizeHeadSubscripting="true" quantify="true"/>
									</Fact>
								</IterateRoles>
								<IterateRoles factArity="1" match="providedConstraintRoles">
									<Fact>
										<ProvidedPredicateReplacement match="included" minimizeHeadSubscripting="true" quantify="true"/>
									</Fact>
								</IterateRoles>
							</CompositeList>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<!-- Exclusive-Or Constraint (Exclusion 6.1.2)-->
				<!--<ConstrainedRoles columnArity="1">
					
				</ConstrainedRoles>-->
			</Constraint>
			<!-- Start Uniqueness Constraint-->
			<Constraint type="UniquenessConstraint" patternGroup="SetConstraint" deferMatchesTo="VerbalizeParts"/>
			<Constraint type="UniquenessConstraintVerbalizer" childHelperFor="UniquenessConstraint" patternGroup="SetConstraint" automaticJoinPathPattern="OppositeRole">
				<EnableSubscripts factCount="1" custom="defaultPlain"/>
				<!-- Internal constraints -->
				<ConstrainedRoles factCount="1" factArity="1" sign="positive">
					<!-- span='all' is implicit in the other conditions. 0 arity includedRoles is blocked. -->
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="UniversalQuantifier">
								<IterateRoles match="included" listStyle="SimpleList"/>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="1">
					<!-- span="all" sign="negative" is implicit in the other conditions are previous element-->
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="OccursInPopulation">
								<Snippet ref="IdentityReferenceQuantifier">
									<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								</Snippet>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="all" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="CombinationIdentifier">
								<Snippet ref="UniversalQuantifier">
									<IterateRoles match="included" listStyle="CompactSimpleList"/>
								</Snippet>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="all">
					<!-- sign="negative" is implied by the previous element -->
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="OccursInPopulation">
								<Snippet ref="CombinationIdentifier">
									<Snippet ref="IdentityReferenceQuantifier">
										<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
									</Snippet>
								</Snippet>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachNegatableCompactQuantifier">
									<IterateRoles listStyle="null" match="included" pass="first" hyphenBind="true"/>
									<Fact readingChoice="Context">
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="OneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="allMinusMoreThanOne" sign="negative">
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="ForEachNegatableIndentedQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true" subscript="true"/>
								<Snippet ref="SingularExistenceImplicationOperator">
									<Snippet ref="MoreThanOneQuantifier">
										<Snippet ref="CombinationIdentifier">
											<IterateRoles match="excluded" listStyle="SimpleList" hyphenBind="true" subscript="true"/>
										</Snippet>
									</Snippet>
									<Fact readingChoice="Context">
										<PredicateReplacement subscript="true">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1">
					<ReadingContext>
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="ForEachNegatableIndentedQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true" subscript="true"/>
								<Fact readingChoice="Context">
									<PredicateReplacement match="included" subscript="true">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded" subscript="true">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>

				<!-- External constraints -->
				<!-- Positive Reading -->
				<ConstrainedRoles trivialOppositeRolePath="true" sign="positive" minFactArity="2" maxFactArity="2" blockHelpers="pathVerbalizer">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoFrontText">
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleList" hyphenBind="true">
									<ReadingContext match="PreferNonPrimaryLeadReadingNoFrontText"/>
								</IterateRoles>
								<IterateRoles match="providedConstraintRoles" listStyle="IndentedList">
									<Fact readingChoice="Context">
										<ProvidedPredicateReplacement match="excluded" pass="first">
											<Snippet ref="AtMostOneQuantifier" />
										</ProvidedPredicateReplacement>
										<ProvidedPredicateReplacement match="excluded">
											<Snippet ref="null" />
										</ProvidedPredicateReplacement>
										<ProvidedPredicateReplacement match="included" quantify="true"/>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachNegatableIndentedQuantifier">
									<IterateRoles match="providedConstraintRoles" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
									<Snippet ref="SingularExistenceImplicationOperator">
										<Snippet ref="OneQuantifier">
											<ProvidedRolePlayer rolePlayerKey="SingleLeadRolePath"/>
										</Snippet>
										<SequenceJoinPath>
											<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="false"/>
													<ProvidedPredicateReplacement quantify="false"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<!-- Negative Reading for External Uniqueness Constraint-->
				<ConstrainedRoles trivialOppositeRolePath="true" sign="negative" minFactArity="2" maxFactArity="2" blockHelpers="pathVerbalizer">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoFrontText">
							<Snippet ref="ModalPossibilityOperator">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleList">
									<Fact readingChoice="Context">
										<ProvidedPredicateReplacement match="excluded" pass="first">
											<Snippet ref="MoreThanOneQuantifier" />
										</ProvidedPredicateReplacement>
										<ProvidedPredicateReplacement match="excluded">
											<Snippet ref="null" />
										</ProvidedPredicateReplacement>
										<ProvidedPredicateReplacement match="included">
											<Snippet ref="IdentityReferenceQuantifier" />
										</ProvidedPredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachNegatableIndentedQuantifier">
									<IterateRoles match="providedConstraintRoles" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
									<Snippet ref="SingularExistenceImplicationOperator">
										<Snippet ref="OneQuantifier">
											<ProvidedRolePlayer rolePlayerKey="SingleLeadRolePath"/>
										</Snippet>
										<SequenceJoinPath>
											<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="false"/>
													<ProvidedPredicateReplacement quantify="false"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles minFactArity="1" maxFactArity="1" blockHelpers="pathVerbalizer preProjectionKeys">
					<Snippet ref="ImpliedModalNecessityOperator" conditionalMatch="HasPreProjectionKeys">
						<ConditionalReplacement>
							<SequenceJoinPath pathPreValidated="true" conditionalMatch="HasSingleLeadPreProjectionKey" leadVariableQuantifier="OneQuantifier"/>
							<Snippet ref="SingularExistenceImplicationOperator">
								<Snippet ref="OneQuantifier">
									<IterateRoles match="preProjectionKeys" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
								</Snippet>
								<SequenceJoinPath>
									<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="false"/>
											<ProvidedPredicateReplacement quantify="false"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
							</Snippet>
						</ConditionalReplacement>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles blockHelpers="pathVerbalizer preProjectionKeys">
					<Snippet ref="ImpliedModalNecessityOperator" conditionalMatch="HasPreProjectionKeys">
						<Snippet ref="ForEachNegatableIndentedQuantifier">
							<IterateRoles match="providedConstraintRoles" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList" skipUnaryValueRole="true"/>
							<ConditionalReplacement>
								<SequenceJoinPath pathPreValidated="true" conditionalMatch="HasSingleLeadPreProjectionKey" leadVariableQuantifier="OneQuantifier"/>
								<Snippet ref="SingularExistenceImplicationOperator">
									<Snippet ref="OneQuantifier">
										<IterateRoles match="preProjectionKeys" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
									</Snippet>
									<SequenceJoinPath>
										<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="false"/>
												<ProvidedPredicateReplacement quantify="false"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</Snippet>
							</ConditionalReplacement>
						</Snippet>
					</Snippet>
					<Snippet ref="ImpliedModalNecessityOperator" conditionalMatch="NoPreProjectionKeys">
						<Snippet ref="ForEachNegatableIndentedQuantifier">
							<Snippet ref="CombinationIdentifier">
								<!-- UNDONE: Switch the roles here to get a unique set of role players opposite unary value roles.
								Apply same approach to the frequency constraint. Low priority: this is only used in fallback conditions. -->
								<IterateRoles match="providedConstraintRoles" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
							</Snippet>
							<Snippet ref="ConditionalMultiLine">
								<SequenceJoinPath>
									<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="false"/>
											<ProvidedPredicateReplacement quantify="false"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
								<Snippet ref="ContextCombinationOccurrence">
									<Snippet ref="ExactlyOneUntypedOccurrence"/>
								</Snippet>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="UniquenessPossibilityVerbalizer" childHelperFor="UniquenessConstraint" patternGroup="SetConstraint">
				<EnableSubscripts factCount="1" custom="defaultPlain"/>
				<!-- Internal constraints -->
				<ConstrainedRoles factCount="1" span="all" factArity="2">
					<Snippet ref="ModalPossibilityOperator" alternateSign="positive">
						<IterateRoles match="included" listStyle="TopLevelIndentedLogicalAndList" loopReset="resetSubscripts">
							<ConditionalReading>
								<ReadingChoice match="RequirePrimaryLeadReading">
									<Fact readingChoice="Context">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="MoreThanOneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</ReadingChoice>
								<ReadingChoice>
									<Snippet ref="ForEachNegatableCompactQuantifier" alternateSign="negative">
										<IterateContextRoles pass="first" listStyle="null" match="primary" subscript="true"/>
										<Fact readingChoice="Context">
											<PredicateReplacement match="primary" subscript="true">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
											<PredicateReplacement>
												<Snippet ref="MoreThanOneQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</Snippet>
								</ReadingChoice>
							</ConditionalReading>
						</IterateRoles>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" minFactArity="3" span="all">
					<Snippet ref="ModalPossibilityOperator" alternateSign="positive">
						<IterateRoles listStyle="TopLevelIndentedLogicalAndList" loopReset="resetSubscripts" subscript="true" reverse="true">
							<Snippet ref="ForEachNegatableCompactQuantifier" alternateSign="negative">
								<IterateContextRoles listStyle="SimpleList" match="secondary" subscript="true"/>
								<Fact readingChoice="PreferPrimaryLeadReading">
									<PredicateReplacement match="secondary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="MoreThanOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</IterateRoles>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="UniquenessPreferredVerbalizer" childHelperFor="UniquenessConstraint" patternGroup="SetConstraint">
				<!-- UNDONE: Preferred uniqueness over a unary doesn't say anything useful. -->
				<ConstrainedRoles minFactArity="2">
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="constraintRoles"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- End Uniqueness Constraint  -->
			<!-- Begin Frequency Constraint  -->
			<Constraint patternGroup="SetConstraint" type="FrequencyConstraint" automaticJoinPathPattern="OppositeRole">
				<EnableSubscripts nonOptimizedFrequencyPattern="true"/>
				<ConstrainedRoles factCount="1" factArity="2" constraintArity="1" sign="positive" frequencyRangePattern="MinUnbounded">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<ConditionalReplacement>
											<Snippet ref="AtMostOneTypedOccurrence" conditionalMatch="FrequencyRangeExactlyOne"/>
											<Snippet ref="FrequencyTypedOccurrences">
												<Snippet ref="CountRangeMinUnbounded">
													<MinFrequencyValue/>
													<MaxFrequencyValue/>
												</Snippet>
											</Snippet>
										</ConditionalReplacement>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="FrequencyPopulation">
									<IterateRoles match="constraintRoles" listStyle="null"/>
									<Fact/>
									<ConditionalReplacement>
										<Snippet ref="ExactlyOneUntypedOccurrence" conditionalMatch="FrequencyRangeExactlyOne"/>
										<Snippet ref="FrequencyUntypedOccurrences">
											<ConditionalSnippet>
												<Snippet ref="CountRangeExact" conditionalMatch="FrequencyRangeExact"/>
												<Snippet ref="CountRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
												<Snippet ref="CountRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
												<Snippet ref="CountRangeMinAndMax"/>
												<SnippetReplacements>
													<MinFrequencyValue/>
													<MaxFrequencyValue/>
												</SnippetReplacements>
											</ConditionalSnippet>
										</Snippet>
									</ConditionalReplacement>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" minFactArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="FrequencyPopulation">
							<ConditionalReplacement>
								<IterateRoles conditionalMatch="SingleRoleRoleSequence" match="constraintRoles" listStyle="null"/>
								<Snippet ref="CombinationIdentifier">
									<IterateRoles match="constraintRoles" listStyle="CompactSimpleList"/>
								</Snippet>
							</ConditionalReplacement>
							<Fact/>
							<ConditionalReplacement>
								<Snippet ref="ExactlyOneUntypedOccurrence" conditionalMatch="FrequencyRangeExactlyOne"/>
								<Snippet ref="FrequencyUntypedOccurrences">
									<ConditionalSnippet>
										<Snippet ref="CountRangeExact" conditionalMatch="FrequencyRangeExact"/>
										<Snippet ref="CountRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
										<Snippet ref="CountRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
										<Snippet ref="CountRangeMinAndMax"/>
										<SnippetReplacements>
											<MinFrequencyValue/>
											<MaxFrequencyValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</Snippet>
							</ConditionalReplacement>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" minFactArity="1" maxFactArity="1" blockHelpers="pathVerbalizer preProjectionKeys">
					<Snippet ref="ImpliedModalNecessityOperator" conditionalMatch="HasPreProjectionKeys">
						<ConditionalSnippet>
							<Snippet ref="SingularExistenceImplicationOperator" conditionalMatch="FrequencyRangeExactlyOne"/>
							<Snippet ref="PluralExistenceImplicationOperator"/>
							<SnippetReplacements>
								<ConditionalReplacement>
									<Snippet ref="AtMostOneTypedOccurrence" conditionalMatch="FrequencyRangeExactlyOne">
										<IterateRoles match="preProjectionKeys" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
									</Snippet>
									<ConditionalSnippet>
										<Snippet ref="FrequencyTypedOccurrences" conditionalMatch="HasSinglePreProjectionKey"/>
										<Snippet ref="FrequencyTypedCombinationOccurrences"/>
										<SnippetReplacements>
											<IterateRoles match="preProjectionKeys" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
											<ConditionalSnippet>
												<Snippet ref="SelfReference" conditionalMatch="FrequencyRangeMinUnbounded"/>
												<Snippet ref="FrequencyNotPopulatedOrRange"/>
												<SnippetReplacements>
													<ConditionalSnippet>
														<Snippet ref="CountRangeExact" conditionalMatch="FrequencyRangeExact"/>
														<Snippet ref="CountRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
														<Snippet ref="CountRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
														<Snippet ref="CountRangeMinAndMax"/>
														<SnippetReplacements>
															<MinFrequencyValue/>
															<MaxFrequencyValue/>
														</SnippetReplacements>
													</ConditionalSnippet>
												</SnippetReplacements>
											</ConditionalSnippet>
										</SnippetReplacements>
									</ConditionalSnippet>
								</ConditionalReplacement>
								<SequenceJoinPath>
									<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="false"/>
											<ProvidedPredicateReplacement quantify="false"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
							</SnippetReplacements>
						</ConditionalSnippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" blockHelpers="pathVerbalizer preProjectionKeys">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachIndentedQuantifier">
							<ConditionalSnippet>
								<Snippet ref="CombinationIdentifier" conditionalMatch="NoPreProjectionKeys"/>
								<Snippet ref="SelfReference"/>
								<SnippetReplacements>
									<IterateRoles match="providedConstraintRoles" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList" skipUnaryValueRole="true"/>
								</SnippetReplacements>
							</ConditionalSnippet>
							<ConditionalReplacement>
								<ConditionalSnippet conditionalMatch="HasPreProjectionKeys">
									<Snippet ref="SingularExistenceImplicationOperator" conditionalMatch="FrequencyRangeExactlyOne"/>
									<Snippet ref="PluralExistenceImplicationOperator"/>
									<SnippetReplacements>
										<ConditionalReplacement>
											<Snippet ref="AtMostOneTypedOccurrence" conditionalMatch="FrequencyRangeExactlyOne">
												<IterateRoles match="preProjectionKeys" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
											</Snippet>
											<ConditionalSnippet>
												<Snippet ref="FrequencyTypedOccurrences" conditionalMatch="HasSinglePreProjectionKey"/>
												<Snippet ref="FrequencyTypedCombinationOccurrences"/>
												<SnippetReplacements>
													<IterateRoles match="preProjectionKeys" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
													<ConditionalSnippet>
														<Snippet ref="SelfReference" conditionalMatch="FrequencyRangeMinUnbounded"/>
														<Snippet ref="FrequencyNotPopulatedOrRange"/>
														<SnippetReplacements>
															<ConditionalSnippet>
																<Snippet ref="CountRangeExact" conditionalMatch="FrequencyRangeExact"/>
																<Snippet ref="CountRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
																<Snippet ref="CountRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
																<Snippet ref="CountRangeMinAndMax"/>
																<SnippetReplacements>
																	<MinFrequencyValue/>
																	<MaxFrequencyValue/>
																</SnippetReplacements>
															</ConditionalSnippet>
														</SnippetReplacements>
													</ConditionalSnippet>
												</SnippetReplacements>
											</ConditionalSnippet>
										</ConditionalReplacement>
										<SequenceJoinPath>
											<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="false"/>
													<ProvidedPredicateReplacement quantify="false"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</SnippetReplacements>
								</ConditionalSnippet>
								<Snippet ref="ConditionalMultiLine">
									<!-- UNDONE: This fallback case is not complete, but it gives us something when the join path is
									not specified. -->
									<SequenceJoinPath>
										<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="false"/>
												<ProvidedPredicateReplacement quantify="false"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
									<Snippet ref="ContextCombinationOccurrence">
										<ConditionalReplacement>
											<Snippet ref="ExactlyOneUntypedOccurrence" conditionalMatch="FrequencyRangeExactlyOne"/>
											<Snippet ref="FrequencyUntypedOccurrences">
												<ConditionalSnippet>
													<Snippet ref="CountRangeExact" conditionalMatch="FrequencyRangeExact"/>
													<Snippet ref="CountRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
													<Snippet ref="CountRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
													<Snippet ref="CountRangeMinAndMax"/>
													<SnippetReplacements>
														<MinFrequencyValue/>
														<MaxFrequencyValue/>
													</SnippetReplacements>
												</ConditionalSnippet>
											</Snippet>
										</ConditionalReplacement>
									</Snippet>
								</Snippet>
							</ConditionalReplacement>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- End Frequency Constraint -->
			<!-- Begin Value Comparison Constraint  -->
			<Constraint type="ValueComparisonConstraint" patternGroup="SetConstraint">
				<EnableSubscripts custom="defaultSubscript" factCount="1"/>
				<ConstrainedRoles sign="positive" factCount="1">
					<!-- UNDONE: Don't have a proper spec. -->
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLine">
							<IterateRoles match="constraintRoles" uniqueFactType="true" listStyle="CompoundList">
								<Fact>
									<PredicateReplacement match="included">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<ConditionalSnippet>
								<!-- Match one of the six verbalizable value comparison operators. Note that the 'Undefined' operators blocks verbalization. -->
								<Snippet ref="LessThanValueComparator" conditionalMatch="ValueComparisonOperatorLessThan"/>
								<Snippet ref="LessThanOrEqualValueComparator" conditionalMatch="ValueComparisonOperatorLessThanOrEqual"/>
								<Snippet ref="GreaterThanValueComparator" conditionalMatch="ValueComparisonOperatorGreaterThan"/>
								<Snippet ref="GreaterThanOrEqualValueComparator" conditionalMatch="ValueComparisonOperatorGreaterThanOrEqual"/>
								<Snippet ref="EqualValueComparator" conditionalMatch="ValueComparisonOperatorEqual"/>
								<Snippet ref="NotEqualValueComparator" conditionalMatch="ValueComparisonOperatorNotEqual"/>
								<SnippetReplacements>
									<IterateRoles match="constraintRoles" pass="first" listStyle="null"/>
									<IterateRoles match="constraintRoles" pass="notFirst" listStyle="null"/>
								</SnippetReplacements>
							</ConditionalSnippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" blockHelpers="pathVerbalizer preProjectionKeys">
					<Snippet ref="ImpliedModalNecessityOperator" conditionalMatch="HasPreProjectionKeys">
						<Snippet ref="ForEachIndentedQuantifier">
							<IterateRoles match="preProjectionKeys" markProvidedConstraintRolesAsHead="true" listStyle="SimpleList"/>
							<Snippet ref="ConditionalMultiLine">
								<SequenceJoinPath/>
								<ConditionalSnippet>
									<!-- Match one of the six verbalizable value comparison operators. Note that the 'Undefined' operators blocks verbalization. -->
									<Snippet ref="LessThanValueComparator" conditionalMatch="ValueComparisonOperatorLessThan"/>
									<Snippet ref="LessThanOrEqualValueComparator" conditionalMatch="ValueComparisonOperatorLessThanOrEqual"/>
									<Snippet ref="GreaterThanValueComparator" conditionalMatch="ValueComparisonOperatorGreaterThan"/>
									<Snippet ref="GreaterThanOrEqualValueComparator" conditionalMatch="ValueComparisonOperatorGreaterThanOrEqual"/>
									<Snippet ref="EqualValueComparator" conditionalMatch="ValueComparisonOperatorEqual"/>
									<Snippet ref="NotEqualValueComparator" conditionalMatch="ValueComparisonOperatorNotEqual"/>
									<SnippetReplacements>
										<IterateRoles match="providedConstraintRoles" pass="first" listStyle="null">
											<ProvidedRolePlayer rolePlayerKey="ConstraintRole"/>
										</IterateRoles>
										<IterateRoles match="providedConstraintRoles" pass="notFirst" listStyle="null">
											<ProvidedRolePlayer rolePlayerKey="ConstraintRole"/>
										</IterateRoles>
									</SnippetReplacements>
								</ConditionalSnippet>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- End Value Comparison Constraint  -->
			<!-- Begin Role Value Constraint -->
			<Constraint patternGroup="RoleValueConstraint" type="RoleValueConstraint">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<ConditionalReplacement>
							<!-- BinaryWithRoleName matches this pattern: The values of [OpposingRolePlayerName.]roleName[(RolePlayerRefMode)] are value-spec. -->
							<IterateRoles match="included" listStyle="null" conditionalMatch="BinaryWithRoleName">
								<Snippet ref="PeriodSeparator">
									<IterateContextRoles match="excluded" listStyle="null"/>
									<ConditionalReplacement>
										<Snippet ref="ReferenceScheme" conditionalMatch="RolePlayerHasReferenceScheme">
											<RoleName/>
											<RolePlayerReferenceMode/>
										</Snippet>
										<RoleName/>
									</ConditionalReplacement>
								</Snippet>
							</IterateRoles>
							<!-- The fallback pattern is: The values of RolePlayer[sub] in Full Fact Verbalization are value-spec. -->
							<ReadingContext>
								<Snippet ref="InQuantifier">
									<IterateRoles match="included" listStyle="null" hyphenBind="true"/>
									<Fact readingChoice="Context"/>
								</Snippet>
							</ReadingContext>
						</ConditionalReplacement>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MinValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MaxValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End Role Value Constraint-->
			<!-- Begin Value Type Value Constraint -->
			<Constraint patternGroup="ValueTypeValueConstraint" type="ValueTypeValueConstraint">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<Snippet ref="ObjectType">
							<ContextName isObjectType="true"/>
							<ContextId/>
						</Snippet>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MinValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MaxValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End Value Type Value Constraint -->
			<!-- Begin nearest EntityType ValueConstraint -->
			<Constraint patternGroup="NearestValueConstraint" type="NearestValueConstraintVerbalizer" childHelperFor="ObjectType">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<Snippet ref="ObjectType">
							<ContextName isObjectType="true"/>
							<ContextId/>
						</Snippet>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MinValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MaxValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End nearest EntityType ValueConstraint -->
			<!-- Begin ObjectType Cardinality Constraint-->
			<Constraint patternGroup="ObjectTypeCardinalityConstraint" type="ObjectTypeCardinalityConstraint">
				<Snippet ref="ImpliedModalNecessityOperator" alternateSign="positive">
					<Snippet ref="ObjectTypeCardinality">
						<Snippet ref="ObjectType">
							<ContextName isObjectType="true"/>
							<ContextId/>
						</Snippet>
						<ConditionalReplacement>
							<ConditionalSnippet conditionalMatch="SingleRange" conditionalBlockContext="SingleRangeBounds">
								<Snippet ref="CardinalitySingleInstance" conditionalMatch="RangeExactlyOne"/>
								<Snippet ref="CardinalityMultipleInstances"/>
								<SnippetReplacements>
									<ConditionalSnippet>
										<Snippet ref="CountRangeExact" conditionalMatch="RangeExact"/>
										<Snippet ref="CountRangeMaxUnbounded" conditionalMatch="RangeUpperUnbounded"/>
										<Snippet ref="CountRangeMinUnbounded" conditionalMatch="RangeLowerUnbounded"/>
										<Snippet ref="CountRangeMinAndMax"/>
										<SnippetReplacements>
											<RangeLowerBound/>
											<RangeUpperBound/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</SnippetReplacements>
							</ConditionalSnippet>
							<Snippet ref="CardinalityMultipleInstances">
								<IterateRanges listStyle="CompactSimpleOrList">
									<ConditionalSnippet>
										<Snippet ref="CountRangeExact" conditionalMatch="RangeExact"/>
										<Snippet ref="CountRangeMaxUnbounded" conditionalMatch="RangeUpperUnbounded"/>
										<Snippet ref="CountRangeMinUnbounded" conditionalMatch="RangeLowerUnbounded"/>
										<Snippet ref="CountRangeMinAndMax"/>
										<SnippetReplacements>
											<RangeLowerBound/>
											<RangeUpperBound/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</IterateRanges>
							</Snippet>
						</ConditionalReplacement>
					</Snippet>
				</Snippet>
			</Constraint>
			<Constraint patternGroup="UnaryRoleCardinalityConstraint" type="UnaryRoleCardinalityConstraint">
				<Snippet ref="ImpliedModalNecessityOperator" alternateSign="positive">
					<Snippet ref="UnaryRoleCardinality">
						<Fact/>
						<Snippet ref="ObjectType">
							<ContextName isObjectType="true"/>
							<ContextId/>
						</Snippet>
						<IterateRanges listStyle="CompactSimpleOrList">
							<ConditionalSnippet>
								<Snippet ref="CountRangeExact" conditionalMatch="RangeExact"/>
								<Snippet ref="CountRangeMaxUnbounded" conditionalMatch="RangeUpperUnbounded"/>
								<Snippet ref="CountRangeMinUnbounded" conditionalMatch="RangeLowerUnbounded"/>
								<Snippet ref="CountRangeMinAndMax"/>
								<SnippetReplacements>
									<RangeLowerBound/>
									<RangeUpperBound/>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateRanges>
					</Snippet>
				</Snippet>
			</Constraint>
			<!-- End ObjectType Cardinality Constraint-->
			<Constraint type="RingConstraint" patternGroup="SetConstraint" deferMatchesTo="VerbalizeByRingType"/>
			<!-- Implementation note on ring constraints:
			The following child helper classes (with adjustments for custom subscript settings) can be combined into
			one verbalization implementation of RingConstraint. However, the resulting function is huge and cyclomatically
			off the charts, and the conditions are significantly different for the combinations, so the final result would
			end up being even larger. Breaking into pieces duplicates some runtime effort for the combined settings,
			but the maintenance and combination enhancements are worth the tradeoff. -->
			<Constraint type="AcyclicRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive" sameConstraintRolePlayers="true" rolePlayerLimitedToConstraintRoles="true">
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="Acyclicity">
								<IterateRoles match="included" listStyle="null" pass="first"/>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="AcyclicityWithRoleNumbers">
								<IterateRoles match="included" listStyle="null" pass="first"/>
								<Fact readingChoice="Context"/>
								<IterateRoles match="included" listStyle="null" pass="first">
									<RoleIndex/>
								</IterateRoles>
								<IterateRoles match="included" listStyle="null" pass="notFirst">
									<RoleIndex/>
								</IterateRoles>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="AntisymmetricRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ConditionalMultiLineIndented">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<Snippet ref="SameTypeIdentityInequalityOperator">
								<IterateRoles match="constraintRoles" listStyle="null" pass="first"/>
								<IterateRoles match="constraintRoles" listStyle="null" pass="notFirst"/>
							</Snippet>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ConditionalMultiLineIndented">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<Snippet ref="CompatibleTypesIdentityInequalityOperator">
								<IterateRoles match="constraintRoles" listStyle="null" pass="first" subscript="true"/>
								<IterateRoles match="constraintRoles" listStyle="null" pass="notFirst" subscript="true"/>
							</Snippet>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="AsymmetricRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ConditionalMultiLineIndented">
						<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
							<Fact readingChoice="ConditionalContext">
								<PredicateReplacement match="included">
									<Snippet ref="SelfReference"/>
								</PredicateReplacement>
								<PredicateReplacement subscript="false">
									<Snippet ref="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ConditionalMultiLineIndented">
						<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
							<Fact readingChoice="ConditionalContext">
								<PredicateReplacement match="included">
									<Snippet ref="ExistentialQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement subscript="false">
									<Snippet ref="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="IrreflexiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultPlain"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReadingNoFrontText" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier" alternateSign="negative"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary">
											<Snippet ref="IdentityReferenceQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement subscript="true">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1">
					<!-- sign="negative" is implied -->
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReadingNoFrontText" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary">
											<Snippet ref="IdentityReferenceQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement subscript="true">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<!-- UNDONE: This is correct for binaries, but not quite right for n-aries, which need to pick
								a reading where the first role encountered in the constrained roles (not necessarily the lead role)
								matches the current primary reading. This currently gives '...same A r some A...' instead of
								'...some A r the -->
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary">
											<Snippet ref="IdentityReferenceQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement subscript="true">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="IntransitiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultPlain"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ConditionalMultiLineIndented">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" factArity="2" sign="positive">
					<!-- Section 8.4.2, binary with different role players -->
					<Snippet ref="ConditionalMultiLineIndented">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="0">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other" overflowSubscript="0">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ConditionalMultiLineIndented">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="StronglyIntransitiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="ConditionalMultiLineIndented">
								<IterateRoles match="included" pass="first" listStyle="null">
									<Fact readingChoice="PreferPrimaryLeadReading">
										<PredicateReplacement match="primary">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement match="included">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="excluded" subscript="false">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<Snippet ref="StronglyIntransitiveConsequent">
									<IterateRoles match="included" pass="first" listStyle="null"/>
									<IterateRoles match="included" pass="notFirst" listStyle="null"/>
								</Snippet>
							</Snippet>
						</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="SymmetricRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLineIndented">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLineIndented">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="ReflexiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<!-- We have a lead reading for one of the constrained roles, so we know the variable
							for this role will be defined before it is referenced with 'itself'.-->
							<IterateRoles pass="first" listStyle="null" match="included" conditionalReading="RequirePrimaryLeadReading">
								<Snippet ref="ImpliedModalNecessityOperator">
									<Snippet ref="ConditionalMultiLineIndented">
										<Fact readingChoice="ConditionalContext">
											<PredicateReplacement match="secondary">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded" subscript="false">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
										<Fact readingChoice="ConditionalContext">
											<PredicateReplacement match="secondary">
												<Snippet ref="ReflexivePronoun"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded" subscript="false">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</Snippet>
								</Snippet>
							</IterateRoles>
						</ReadingChoice>
						<ReadingChoice>
							<!-- Use the clumsier fallback form, using 'x itself r x' -->
							<IterateRoles pass="first" listStyle="null" match="included" conditionalReading="PreferLeadReading">
								<Snippet ref="ImpliedModalNecessityOperator">
									<Snippet ref="ConditionalMultiLineIndented">
										<Fact readingChoice="Context">
											<PredicateReplacement match="secondary">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded" subscript="false">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
										<Fact readingChoice="Context">
											<PredicateReplacement match="secondary" alternateRolePlayer="primary">
												<Snippet ref="ReflexiveQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded" subscript="false">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</Snippet>
								</Snippet>
							</IterateRoles>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="PurelyReflexiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<IterateRoles pass="first" listStyle="null" match="included">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="ConditionalMultiLineIndented">
								<Fact readingChoice="PreferLeadReading">
									<PredicateReplacement match="secondary">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded" subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
								<IterateContextRoles listStyle="EqualsList" match="included"/>
							</Snippet>
						</Snippet>
					</IterateRoles>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="TransitiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultPlain"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLineIndented">
							<Snippet ref="LogicalAndOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="included">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary" alternateRolePlayer="other">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" factArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLineIndented">
							<Snippet ref="LogicalAndOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" overflowSubscript="0">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary" alternateRolePlayer="other" overflowSubscript="0">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" overflowSubscript="1">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
							<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLineIndented">
							<Snippet ref="LogicalAndOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary" alternateRolePlayer="other">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="EqualityConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1" constraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachIndentedQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles listStyle="null" match="providedConstraintRoles" pass="first" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<Snippet ref="Equality">
								<IterateSequences listStyle="null" pass="first">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
								<IterateSequences listStyle="null" pass="notFirst">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachIndentedQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles listStyle="SimpleLogicalAndList" match="providedConstraintRoles" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<Snippet ref="Equality">
								<IterateSequences listStyle="null" pass="first">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
								<IterateSequences listStyle="null" pass="notFirst">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles minConstraintArity="3" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleLogicalAndList" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<Snippet ref="GroupEquality">
								<IterateSequences listStyle="MultilineIndentedCompoundList" compositeList="true">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- 
				6.1.1: Exclusion constraint but no inclusive-or constraint over the same roles 
				6.1.2: Exclusion plus Inclusive-or constraint over the same roles
			-->
			<Constraint type="ExclusionConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1" minConstraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleLogicalAndList" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<ConditionalSnippet>
								<Snippet ref="GroupExclusiveOr" conditionalMatch="ExclusionIsExclusiveOrConstraint"/>
								<Snippet ref="GroupExclusion"/>
								<SnippetReplacements>
									<IterateSequences listStyle="MultilineIndentedCompoundList" compositeList="true">
										<SequenceJoinPath markTrailingOutdentStart="true">
											<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="true"/>
													<ProvidedPredicateReplacement quantify="true"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</IterateSequences>
								</SnippetReplacements>
							</ConditionalSnippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="2" columnArity="2" constraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator" conditionalBlockContext="BinaryLeadReading">
						<ConditionalSnippet>
							<Snippet conditionalMatch="IsBinaryLeadReading" ref="ExclusionBinaryLeadReading"/>
							<Snippet conditionalMatch="IsBinaryLeadReadingReverse" ref="ExclusionBinaryLeadReading"/>
							<Snippet ref="ForEachCompactQuantifier"/>
							<SnippetReplacements>
								<ConditionalReplacement>
									<Snippet ref="ExclusionCombined" conditionalMatch="IsBinaryLeadReading">
										<IterateSequences listStyle="null" pass="first">
											<IterateRoles match="providedConstraintRoles" listStyle="null" pass="first"/>
										</IterateSequences>
										<IterateSequences listStyle="SimpleLogicalAndList" compositeList="true">
											<IterateRoles match="constraintRoles" pass="first" listStyle="null">
												<Fact readingChoice="PreferPrimaryLeadReadingInfixTextOnlyNotHyphenBound">
													<PredicateReplacement>
														<Snippet ref="null"/>
													</PredicateReplacement>
												</Fact>
											</IterateRoles>
										</IterateSequences>
									</Snippet>
									<Snippet ref="ExclusionCombined" conditionalMatch="IsBinaryLeadReadingReverse">
										<IterateSequences listStyle="null" pass="first">
											<IterateRoles match="providedConstraintRoles" listStyle="null" pass="notFirst"/>
										</IterateSequences>
										<IterateSequences listStyle="SimpleLogicalAndList" compositeList="true">
											<IterateRoles match="constraintRoles" pass="notFirst" listStyle="null">
												<Fact readingChoice="PreferPrimaryLeadReadingInfixTextOnlyNotHyphenBound">
													<PredicateReplacement>
														<Snippet ref="null"/>
													</PredicateReplacement>
												</Fact>
											</IterateRoles>
										</IterateSequences>
									</Snippet>
									<IterateSequences listStyle="null" pass="first">
										<IterateRoles match="providedConstraintRoles" listStyle="SimpleLogicalAndList" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
									</IterateSequences>
								</ConditionalReplacement>
								<ConditionalReplacement>
									<IterateSequences listStyle="null" pass="first" conditionalMatch="IsBinaryLeadReading">
										<IterateRoles match="providedConstraintRoles" listStyle="null" pass="notFirst"/>
									</IterateSequences>
									<IterateSequences listStyle="null" pass="first" conditionalMatch="IsBinaryLeadReadingReverse">
										<IterateRoles match="providedConstraintRoles" listStyle="null" pass="first"/>
									</IterateSequences>
									<Snippet ref="GroupExclusion">
										<IterateSequences listStyle="MultilineIndentedCompoundList" compositeList="true">
											<SequenceJoinPath markTrailingOutdentStart="true">
												<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
													<Fact>
														<ProvidedPredicateReplacement match="included" quantify="true"/>
														<ProvidedPredicateReplacement quantify="true"/>
													</Fact>
												</IterateRoles>
											</SequenceJoinPath>
										</IterateSequences>
									</Snippet>
								</ConditionalReplacement>
							</SnippetReplacements>
						</ConditionalSnippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles minConstraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleLogicalAndList" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<Snippet ref="GroupExclusion">
								<IterateSequences listStyle="MultilineIndentedCompoundList" compositeList="true">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
		</Constraints>
		<SampleInstances>
			<SingleSnippet type="FactTypeInstanceBlockStart" childHelperFor="FactType" snippetRef="FactTypeInstanceBlockStart"/>
			<SingleSnippet type="FactTypeInstanceBlockEnd" childHelperFor="FactType" snippetRef="FactTypeInstanceBlockEnd"/>
			<SampleInstance type="FactTypeInstanceVerbalizer" childHelperFor="FactType">
				<!-- UNDONE: Collapse this to use a mechanism similar to ObjectTypeInstanceVerbalizer.
				IterateInstances should support a FactType parent, and the BlockStart/BlockEnd snippets
				should be folded into a normal listStyle. -->
				<FactInstance/>
				<Snippet ref="FactTypeInstanceIdentifier" conditionalMatch="ObjectifyingInstance">
					<ObjectifyingInstanceIdentifierName/>
				</Snippet>
			</SampleInstance>
			<SampleInstance type="ObjectTypeInstanceVerbalizer" childHelperFor="ObjectType">
				<IterateInstances listStyle="ObjectTypeInstanceList">
					<ObjectTypeInstanceValue/>
				</IterateInstances>
			</SampleInstance>
		</SampleInstances>
	</Constructs>
</VerbalizationRoot>